<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://husy-dev.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Husy">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://husy-dev.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-golang语言深度解析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/30/golang%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2021-03-30T03:18:27.000Z" itemprop="datePublished">2021-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/30/golang%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">golang语言深度解析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="预备方法"><a href="#预备方法" class="headerlink" title="预备方法"></a>预备方法</h2><p>查询golang源码的实现可以这么操作：</p>
<ol>
<li>写一个简单的测试代码，用<code>go build -gcflags=all=&quot;-N -l&quot; main.go</code>编译成二进制文件</li>
<li>用<code>go tool objdump -s &quot;main\.main&#123;要查看的函数名称&#125;&quot; main</code>来查看汇编代码</li>
<li>一般可以看到一些CALL runtime.func的函数。此时用gdb main进入gdb调试状态。</li>
<li>用b {汇编代码里看到的funcname} ，就是输出具体函数的代码在哪个文件里。</li>
</ol>
<h2 id="1-Channel结构详解"><a href="#1-Channel结构详解" class="headerlink" title="1. Channel结构详解"></a>1. Channel结构详解</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//channel对应的结构体</span></span><br><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>  <span class="comment">// chan 里元素数量</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>  <span class="comment">// chan 底层循环数组的长度</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 指向底层循环数组的指针,只针对有缓冲的 channel</span></span><br><span class="line">    elemsize <span class="type">uint16</span> <span class="comment">// chan 中元素大小</span></span><br><span class="line">    closed   <span class="type">uint32</span> <span class="comment">// chan 是否被关闭的标志</span></span><br><span class="line">    elemtype *_type <span class="comment">// chan 中元素的类型</span></span><br><span class="line">    sendx    <span class="type">uint</span>   <span class="comment">// 已发送元素在循环数组中的索引</span></span><br><span class="line">    recvx    <span class="type">uint</span>   <span class="comment">// 已接收元素在循环数组中的索引</span></span><br><span class="line">    recvq    waitq  <span class="comment">// 等待接收的 goroutine 队列，也就是执行了 &lt;-chan 的goroutine 队列</span></span><br><span class="line">    sendq    waitq  <span class="comment">// 等待发送的 goroutine 队列，也就是执行了 -&gt;chan 的goroutine 队列</span></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//recvq和sendq是一个由sudog构造的双向链表。其中sudog对应一个goroutine，用来记录需要操作channel的goroutine。</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿channel接收数据为例，通过汇编可以知道在执行 &lt;-chan这种操作时，最后执行的是下面的函数。可以通过注释来看逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chanrecv 位于 src/runtime/chan.go </span></span><br><span class="line"><span class="comment">//返回值 selected 代表的是在select关键字语义中，case &lt;-chan 是否会被命中。注意，有时候一个关闭的chan也能命中case就是这个原因。</span></span><br><span class="line"><span class="comment">//received 用来指示返回的数据是真实从channel里读取的，还是因为关闭后返回的该数据类型的零值。也就是 a,ok:=&lt;-chan 的ok的含义。</span></span><br><span class="line"><span class="comment">// 参数 block的含义是是否阻塞，如果是阻塞模式，那么一定要等数据接收到，并且读取完成才会返回；而非阻塞模式下，如果没有数据接可以接收，那么就立即返回。（⚠️ 非阻塞与异步的区别）</span></span><br><span class="line"><span class="comment">// 接收的主要逻辑是：</span></span><br><span class="line"><span class="comment">// 1. 非缓冲型，从sendq里读取数据写入参数ep指向的地址里。</span></span><br><span class="line"><span class="comment">// 2. 缓冲型，从buf里读取数据写入参数ep指向的地址里。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 省略 debug 内容 …………</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是一个 nil 的 channel</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不阻塞，直接返回 (false, false)</span></span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，接收一个 nil 的 channel，goroutine 挂起</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">&quot;chan receive (nil chan)&quot;</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 不会执行到这里</span></span><br><span class="line">        throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在非阻塞模式下，如果数据没有准备好，就可以立马返回。</span></span><br><span class="line">    <span class="comment">// 因为都是只读的属性，可以不加锁读取，所以放在前面判断。</span></span><br><span class="line">    <span class="comment">// channel 没准备好接收的情况有：</span></span><br><span class="line">    <span class="comment">// 1. 非缓冲型，等待发送列队 sendq 里没有 goroutine 在等待。</span></span><br><span class="line">    <span class="comment">// 2. 缓冲型，但 buf 里没有元素</span></span><br><span class="line">    <span class="comment">// 并且需要 closed == 0，即 channel 未关闭。因为如果closed关闭了的话，是可以命中select的case的，selected要返回true。</span></span><br><span class="line">    <span class="comment">// 因为 channel 不可能被重复打开，所以前一个观测的时候 channel 也是未关闭的，</span></span><br><span class="line">    <span class="comment">// 因此在这种情况下可以直接宣布接收失败，返回 (false, false)</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">        c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel 已关闭，并且循环数组 buf 里没有元素</span></span><br><span class="line">    <span class="comment">// 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况</span></span><br><span class="line">    <span class="comment">// 也就是说即使是关闭状态，但在缓冲型的 channel，buf 里有元素的情况下还能接收到元素</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(unsafe.Pointer(c))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 从一个已关闭的 channel 执行接收操作，且未忽略返回值</span></span><br><span class="line">            <span class="comment">// 那么接收的值将是一个该类型的零值</span></span><br><span class="line">            <span class="comment">// typedmemclr 根据类型清理相应地址的内存</span></span><br><span class="line">            typedmemclr(c.elemtype, ep)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从一个已关闭的 channel 接收，selected 会返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待发送队列里有 goroutine 存在，说明 buf 是满的</span></span><br><span class="line">    <span class="comment">// 这有可能是：</span></span><br><span class="line">    <span class="comment">// 1. 非缓冲型的 channel</span></span><br><span class="line">    <span class="comment">// 2. 缓冲型的 channel，但 buf 满了</span></span><br><span class="line">    <span class="comment">// 针对 1，直接进行内存拷贝（从 sender goroutine -&gt; receiver goroutine）</span></span><br><span class="line">    <span class="comment">// 针对 2，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">        <span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">        <span class="comment">// and add sender&#x27;s value to the tail of the queue (both map to</span></span><br><span class="line">        <span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">        recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲型，buf 里有元素，可以正常接收</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 直接从循环数组里找到要接收的元素</span></span><br><span class="line">        qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="comment">// …………</span></span><br><span class="line">        <span class="comment">// 代码里，没有忽略要接收的值，不是 &quot;&lt;- ch&quot;，而是 &quot;val &lt;- ch&quot;，ep 指向 val</span></span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清理掉循环数组里相应位置的值</span></span><br><span class="line">        typedmemclr(c.elemtype, qp)</span><br><span class="line">        <span class="comment">// 接收游标向前移动</span></span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="comment">// 接收游标归零</span></span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// buf 数组里的元素个数减 1</span></span><br><span class="line">        c.qcount--</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !block &#123; <span class="comment">// 非阻塞接收，解锁。selected 返回 false，因为没有接收到值</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是处理阻塞模式下（目前默认使用的模式），没有数据可以读取应该怎么阻塞调用&lt;-chan的giroutine</span></span><br><span class="line">    gp := getg() <span class="comment">//获取当前的goroutine</span></span><br><span class="line">    mysg := acquireSudog() <span class="comment">//sudog底层实现是一个缓存池，而不是新创建</span></span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待接收数据的地址保存下来</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 进入该 channel 的等待接收队列，也就是等待从该channel里读取数据</span></span><br><span class="line">    c.recvq.enqueue(mysg)</span><br><span class="line">    <span class="comment">// 将当前 goroutine 挂起</span></span><br><span class="line">    goparkunlock(&amp;c.lock, <span class="string">&quot;chan receive&quot;</span>, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被唤醒了，接着从这里继续执行一些扫尾工作</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    closed := gp.param == <span class="literal">nil</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg) <span class="comment">// 释放sudog回缓存池</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74613114">深度解密Go语言之channel </a> 因此channel的接收和发送不过是一系列内存拷贝，以及对相关goroutine的管理。</p>
<h2 id="2-select关键字详解"><a href="#2-select关键字详解" class="headerlink" title="2. select关键字详解"></a>2. select关键字详解</h2><p>从汇编代码里可以看出select主要是调用了<code>runtime.selectnbrecv</code>函数那么去<code>(gdb) b runtime.selectnbrecv Breakpoint 1 at 0x4058b0: file /usr/local/go/src/runtime/chan.go, line 635</code>文件里找找。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compiler implements</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	select &#123;</span></span><br><span class="line"><span class="comment">//	case v = &lt;-c:</span></span><br><span class="line"><span class="comment">//		... foo</span></span><br><span class="line"><span class="comment">//	default:</span></span><br><span class="line"><span class="comment">//		... bar</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// as</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	if selectnbrecv(&amp;v, c) &#123;</span></span><br><span class="line"><span class="comment">//		... foo</span></span><br><span class="line"><span class="comment">//	&#125; else &#123;</span></span><br><span class="line"><span class="comment">//		... bar</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected <span class="type">bool</span>) &#123;</span><br><span class="line">	selected, _ = chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>意思就是把select翻译成了if else语句，selectnbrecv能够命中的话就进入if语句，default则是最后的else，不难想象如果还有多的case，则会翻译成else if语句。selectnbrecv的逻辑很简单，用channel结构里的chanrecv来判断是否命中select。那么这样有一个问题，如果第一个case持续命中，如何解决后面的case的饥饿问题？</p>
<p>多给一个case条件，其汇编代码则用了runtime.selectgo，而不是runtime.selectnbrecv函数。<code>(gdb) b runtime.selectgo Breakpoint 1 at 0x433fb0: file /usr/local/go/src/runtime/select.go, line 115.</code>开始重头戏，可以看看注释。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Changes here must also be made in src/cmd/internal/gc/select.go&#x27;s scasetype.</span></span><br><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">	c           *hchan         <span class="comment">// chan</span></span><br><span class="line">	elem        unsafe.Pointer <span class="comment">// data element</span></span><br><span class="line">	kind        <span class="type">uint16</span>  <span class="comment">//case的类型，有default，chan recv,chan send,nil</span></span><br><span class="line">	pc          <span class="type">uintptr</span> <span class="comment">// race pc (for race detector / msan)</span></span><br><span class="line">	releasetime <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// selectgo implements the select statement.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// cas0 points to an array of type [ncases]scase, and order0 points to</span></span><br><span class="line"><span class="comment">// an array of type [2*ncases]uint16. Both reside on the goroutine&#x27;s</span></span><br><span class="line"><span class="comment">// stack (regardless of any escaping in selectgo).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// selectgo returns the index of the chosen scase, which matches the</span></span><br><span class="line"><span class="comment">// ordinal position of its respective select&#123;recv,send,default&#125; call.</span></span><br><span class="line"><span class="comment">// Also, if the chosen scase was a receive operation, it reports whether</span></span><br><span class="line"><span class="comment">// a value was received.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *<span class="type">uint16</span>, ncases <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">//....debug的信息</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">//下面的是将cas0转化成一个2^16长度的scase数组的指针</span></span><br><span class="line">  <span class="comment">//将order0转化成一个2^17长度的uint16数组的指针</span></span><br><span class="line">	cas1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]scase)(unsafe.Pointer(cas0))</span><br><span class="line">	order1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">17</span>]<span class="type">uint16</span>)(unsafe.Pointer(order0))</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里的切片的语法不太常用，</span></span><br><span class="line">  <span class="comment">//其含义是s[low : high : max]从切片s的索引位置low到high处所获得的切片</span></span><br><span class="line">  <span class="comment">//主要的功能是len=high-low，cap=max-low</span></span><br><span class="line">	scases := cas1[:ncases:ncases]</span><br><span class="line">	pollorder := order1[:ncases:ncases] <span class="comment">//保存case的检查顺序</span></span><br><span class="line">	lockorder := order1[ncases:][:ncases:ncases] <span class="comment">//保存scase里的hchan的地址</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Replace send/receive cases involving nil channels with</span></span><br><span class="line">	<span class="comment">// caseNil so logic below can assume non-nil channel.</span></span><br><span class="line">  <span class="comment">//如果case里的channel是</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> scases &#123;</span><br><span class="line">		cas := &amp;scases[i]</span><br><span class="line">		<span class="keyword">if</span> cas.c == <span class="literal">nil</span> &amp;&amp; cas.kind != caseDefault &#123;</span><br><span class="line">			*cas = scase&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">			scases[i].releasetime = <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The compiler rewrites selects that statically have</span></span><br><span class="line">	<span class="comment">// only 0 or 1 cases plus default into simpler constructs.</span></span><br><span class="line">	<span class="comment">// The only way we can end up with such small sel.ncase</span></span><br><span class="line">	<span class="comment">// values here is for a larger select in which most channels</span></span><br><span class="line">	<span class="comment">// have been nilled out. The general code handles those</span></span><br><span class="line">	<span class="comment">// cases correctly, and they are rare enough not to bother</span></span><br><span class="line">	<span class="comment">// optimizing (and needing to test).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// generate permuted order</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		j := fastrandn(<span class="type">uint32</span>(i + <span class="number">1</span>))</span><br><span class="line">		pollorder[i] = pollorder[j]</span><br><span class="line">		pollorder[j] = <span class="type">uint16</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sort the cases by Hchan address to get the locking order.</span></span><br><span class="line">	<span class="comment">// simple heap sort, to guarantee n log n time and constant stack footprint.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		j := i</span><br><span class="line">		<span class="comment">// Start with the pollorder to permute cases on the same channel.</span></span><br><span class="line">		c := scases[pollorder[i]].c</span><br><span class="line">		<span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; scases[lockorder[(j<span class="number">-1</span>)/<span class="number">2</span>]].c.sortkey() &lt; c.sortkey() &#123;</span><br><span class="line">			k := (j - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">			lockorder[j] = lockorder[k]</span><br><span class="line">			j = k</span><br><span class="line">		&#125;</span><br><span class="line">		lockorder[j] = pollorder[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := ncases - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		o := lockorder[i]</span><br><span class="line">		c := scases[o].c</span><br><span class="line">		lockorder[i] = lockorder[<span class="number">0</span>]</span><br><span class="line">		j := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			k := j*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> k &gt;= i &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> k+<span class="number">1</span> &lt; i &amp;&amp; scases[lockorder[k]].c.sortkey() &lt; scases[lockorder[k+<span class="number">1</span>]].c.sortkey() &#123;</span><br><span class="line">				k++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.sortkey() &lt; scases[lockorder[k]].c.sortkey() &#123;</span><br><span class="line">				lockorder[j] = lockorder[k]</span><br><span class="line">				j = k</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		lockorder[j] = o</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i+<span class="number">1</span> &lt; ncases; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> scases[lockorder[i]].c.sortkey() &gt; scases[lockorder[i+<span class="number">1</span>]].c.sortkey() &#123;</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">&quot;i=&quot;</span>, i, <span class="string">&quot; x=&quot;</span>, lockorder[i], <span class="string">&quot; y=&quot;</span>, lockorder[i+<span class="number">1</span>], <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">				throw(<span class="string">&quot;select: broken sort&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock all the channels involved in the select</span></span><br><span class="line">	sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		gp     *g</span><br><span class="line">		sg     *sudog</span><br><span class="line">		c      *hchan</span><br><span class="line">		k      *scase</span><br><span class="line">		sglist *sudog</span><br><span class="line">		sgnext *sudog</span><br><span class="line">		qp     unsafe.Pointer</span><br><span class="line">		nextp  **sudog</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">	<span class="comment">// pass 1 - look for something already waiting</span></span><br><span class="line">	<span class="keyword">var</span> dfli <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> dfl *scase</span><br><span class="line">	<span class="keyword">var</span> casi <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> cas *scase</span><br><span class="line">	<span class="keyword">var</span> recvOK <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		casi = <span class="type">int</span>(pollorder[i])</span><br><span class="line">		cas = &amp;scases[casi]</span><br><span class="line">		c = cas.c</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">		<span class="keyword">case</span> caseNil:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseRecv:</span><br><span class="line">			sg = c.sendq.dequeue()</span><br><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> recv</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> bufrecv</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> rclose</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseSend:</span><br><span class="line">			<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">				racereadpc(c.raceaddr(), cas.pc, chansendpc)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> sclose</span><br><span class="line">			&#125;</span><br><span class="line">			sg = c.recvq.dequeue()</span><br><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> send</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">				<span class="keyword">goto</span> bufsend</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseDefault:</span><br><span class="line">			dfli = casi</span><br><span class="line">			dfl = cas</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> dfl != <span class="literal">nil</span> &#123;</span><br><span class="line">		selunlock(scases, lockorder)</span><br><span class="line">		casi = dfli</span><br><span class="line">		cas = dfl</span><br><span class="line">		<span class="keyword">goto</span> retc</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pass 2 - enqueue on all chans</span></span><br><span class="line">	gp = getg()</span><br><span class="line">	<span class="keyword">if</span> gp.waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;gp.waiting != nil&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	nextp = &amp;gp.waiting</span><br><span class="line">	<span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">		casi = <span class="type">int</span>(casei)</span><br><span class="line">		cas = &amp;scases[casi]</span><br><span class="line">		<span class="keyword">if</span> cas.kind == caseNil &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		c = cas.c</span><br><span class="line">		sg := acquireSudog()</span><br><span class="line">		sg.g = gp</span><br><span class="line">		sg.isSelect = <span class="literal">true</span></span><br><span class="line">		<span class="comment">// No stack splits between assigning elem and enqueuing</span></span><br><span class="line">		<span class="comment">// sg on gp.waiting where copystack can find it.</span></span><br><span class="line">		sg.elem = cas.elem</span><br><span class="line">		sg.releasetime = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">		sg.c = c</span><br><span class="line">		<span class="comment">// Construct waiting list in lock order.</span></span><br><span class="line">		*nextp = sg</span><br><span class="line">		nextp = &amp;sg.waitlink</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">		<span class="keyword">case</span> caseRecv:</span><br><span class="line">			c.recvq.enqueue(sg)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseSend:</span><br><span class="line">			c.sendq.enqueue(sg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait for someone to wake us up</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	gopark(selparkcommit, <span class="literal">nil</span>, waitReasonSelect, traceEvGoBlockSelect, <span class="number">1</span>)</span><br><span class="line">	gp.activeStackChans = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line">	gp.selectDone = <span class="number">0</span></span><br><span class="line">	sg = (*sudog)(gp.param)</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// pass 3 - dequeue from unsuccessful chans</span></span><br><span class="line">	<span class="comment">// otherwise they stack up on quiet channels</span></span><br><span class="line">	<span class="comment">// record the successful case, if any.</span></span><br><span class="line">	<span class="comment">// We singly-linked up the SudoGs in lock order.</span></span><br><span class="line">	casi = <span class="number">-1</span></span><br><span class="line">	cas = <span class="literal">nil</span></span><br><span class="line">	sglist = gp.waiting</span><br><span class="line">	<span class="comment">// Clear all elem before unlinking from gp.waiting.</span></span><br><span class="line">	<span class="keyword">for</span> sg1 := gp.waiting; sg1 != <span class="literal">nil</span>; sg1 = sg1.waitlink &#123;</span><br><span class="line">		sg1.isSelect = <span class="literal">false</span></span><br><span class="line">		sg1.elem = <span class="literal">nil</span></span><br><span class="line">		sg1.c = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">		k = &amp;scases[casei]</span><br><span class="line">		<span class="keyword">if</span> k.kind == caseNil &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sglist.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">			k.releasetime = sglist.releasetime</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg == sglist &#123;</span><br><span class="line">			<span class="comment">// sg has already been dequeued by the G that woke us up.</span></span><br><span class="line">			casi = <span class="type">int</span>(casei)</span><br><span class="line">			cas = k</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c = k.c</span><br><span class="line">			<span class="keyword">if</span> k.kind == caseSend &#123;</span><br><span class="line">				c.sendq.dequeueSudoG(sglist)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				c.recvq.dequeueSudoG(sglist)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sgnext = sglist.waitlink</span><br><span class="line">		sglist.waitlink = <span class="literal">nil</span></span><br><span class="line">		releaseSudog(sglist)</span><br><span class="line">		sglist = sgnext</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cas == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// We can wake up with gp.param == nil (so cas == nil)</span></span><br><span class="line">		<span class="comment">// when a channel involved in the select has been closed.</span></span><br><span class="line">		<span class="comment">// It is easiest to loop and re-run the operation;</span></span><br><span class="line">		<span class="comment">// we&#x27;ll see that it&#x27;s now closed.</span></span><br><span class="line">		<span class="comment">// Maybe some day we can signal the close explicitly,</span></span><br><span class="line">		<span class="comment">// but we&#x27;d have to distinguish close-on-reader from close-on-writer.</span></span><br><span class="line">		<span class="comment">// It&#x27;s easiest not to duplicate the code and just recheck above.</span></span><br><span class="line">		<span class="comment">// We know that something closed, and things never un-close,</span></span><br><span class="line">		<span class="comment">// so we won&#x27;t block again.</span></span><br><span class="line">		<span class="keyword">goto</span> loop</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c = cas.c</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;wait-return: cas0=&quot;</span>, cas0, <span class="string">&quot; c=&quot;</span>, c, <span class="string">&quot; cas=&quot;</span>, cas, <span class="string">&quot; kind=&quot;</span>, cas.kind, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cas.kind == caseRecv &#123;</span><br><span class="line">		recvOK = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		<span class="keyword">if</span> cas.kind == caseRecv &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			raceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> cas.kind == caseSend &#123;</span><br><span class="line">			raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		<span class="keyword">if</span> cas.kind == caseRecv &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			msanwrite(cas.elem, c.elemtype.size)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> cas.kind == caseSend &#123;</span><br><span class="line">			msanread(cas.elem, c.elemtype.size)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufrecv:</span><br><span class="line">	<span class="comment">// can receive from buffer</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			raceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc)</span><br><span class="line">		&#125;</span><br><span class="line">		raceacquire(chanbuf(c, c.recvx))</span><br><span class="line">		racerelease(chanbuf(c, c.recvx))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		msanwrite(cas.elem, c.elemtype.size)</span><br><span class="line">	&#125;</span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	qp = chanbuf(c, c.recvx)</span><br><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		typedmemmove(c.elemtype, cas.elem, qp)</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemclr(c.elemtype, qp)</span><br><span class="line">	c.recvx++</span><br><span class="line">	<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">		c.recvx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount--</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufsend:</span><br><span class="line">	<span class="comment">// can send to buffer</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceacquire(chanbuf(c, c.sendx))</span><br><span class="line">		racerelease(chanbuf(c, c.sendx))</span><br><span class="line">		raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(cas.elem, c.elemtype.size)</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)</span><br><span class="line">	c.sendx++</span><br><span class="line">	<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">		c.sendx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount++</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">recv:</span><br><span class="line">	<span class="comment">// can receive from sleeping sender (sg)</span></span><br><span class="line">	recv(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;syncrecv: cas0=&quot;</span>, cas0, <span class="string">&quot; c=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">rclose:</span><br><span class="line">	<span class="comment">// read at end of closed channel</span></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	recvOK = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		typedmemclr(c.elemtype, cas.elem)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceacquire(c.raceaddr())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">send:</span><br><span class="line">	<span class="comment">// can send to a sleeping receiver (sg)</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(cas.elem, c.elemtype.size)</span><br><span class="line">	&#125;</span><br><span class="line">	send(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;syncsend: cas0=&quot;</span>, cas0, <span class="string">&quot; c=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">retc:</span><br><span class="line">	<span class="keyword">if</span> cas.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(cas.releasetime-t0, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> casi, recvOK</span><br><span class="line"></span><br><span class="line">sclose:</span><br><span class="line">	<span class="comment">// send on closed channel</span></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-从引导和初始化说起"><a href="#3-从引导和初始化说起" class="headerlink" title="3. 从引导和初始化说起"></a>3. 从引导和初始化说起</h2><p>​    编译器会给程序加一层引导代码，根据运行平台来进行不同的初始化。从rt0_*{平台}.s文件里找到rt0_go函数，这就是初始化的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$0 </span><br><span class="line">	...</span><br><span class="line">	// 调用初始化函数</span><br><span class="line">	CALL runtime·args(SB)</span><br><span class="line">	CALL runtime·osinit(SB) </span><br><span class="line">	CALL runtime·schedinit(SB)</span><br><span class="line">	// 创建 main goroutine 用于执行 runtime.main</span><br><span class="line">	MOVQ $runtime·mainPC(SB), AX</span><br><span class="line">	PUSHQ AX</span><br><span class="line">	PUSHQ $0</span><br><span class="line">	CALL runtime·newproc(SB) POPQ AX</span><br><span class="line">	POPQ AX</span><br><span class="line">	//让当前线程开始执行 main goroutine</span><br><span class="line">	CALL runtime·mstart(SB)</span><br><span class="line">	RET</span><br><span class="line">DATA runtime·mainPC+0(SB)/8,$runtime·main(SB) </span><br><span class="line">GLOBL runtime·mainPC(SB),RODATA,$8</span><br></pre></td></tr></table></figure>

<p>可以看到，就是一次调用了<code>runtime·args（整理命令行参数）, runtime·osinit（获取CPU core的数量）,runtime·schedinit（内存分配器，垃圾回收器，并发调度器的初始化都在此执行，后面详述）  </code>，然后通过newproc创建goroutine来执行runtime.main（执行runtime_init函数，执行main_init函数，最后执行用户逻辑入口main.main函数）。</p>
<h2 id="5-内存分配"><a href="#5-内存分配" class="headerlink" title="5. 内存分配"></a>5. 内存分配</h2><p><a target="_blank" rel="noopener" href="https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed">A visual guide to Go Memory Allocator from scratch (Golang)</a></p>
<p>分配器管理两层内存块，span（由多个地址连续的页组成的），object（将span按特定大小切分成多个小块来分配对象）。</p>
<h2 id="6-Golang汇编"><a href="#6-Golang汇编" class="headerlink" title="6. Golang汇编"></a>6. Golang汇编</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://www.ershicimi.com/p/dd7414381b510cfc8cea5bb400854fa2">Golang 汇编入门知识总结</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019753885">Go 函数调用 ━ 栈和寄存器视角</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/yangyuqian/technical-articles/blob/master/asm/golang-plan9-assembly-cn.md#golang%E4%B8%AD%E7%9A%84plan9%E6%B1%87%E7%BC%96%E5%99%A8">Golang中的Plan9汇编器 </a> </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://lrita.github.io/2017/12/12/golang-asm/#c2goasm">golang 汇编 </a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://colobu.com/2018/12/29/get-assembly-output-for-go-programs/">得到Go程序的汇编代码的方法</a></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2021/03/30/golang%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" data-id="cl0t1dd1800568slf77418hpu" data-title="golang语言深度解析" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【CSAPP】Ch3-计算机编码" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/30/%E3%80%90CSAPP%E3%80%91Ch3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81/" class="article-date">
  <time class="dt-published" datetime="2021-03-30T03:18:27.000Z" itemprop="datePublished">2021-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/30/%E3%80%90CSAPP%E3%80%91Ch3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81/">CSAPP-ch3-计算机编码</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xoh6Oh/submissions/">https://leetcode-cn.com/problems/xoh6Oh/submissions/</a><br>这道题最简单的思路是用减法，先判断是否是异号，结果要为负的，然后获取两个数的绝对值，不断相减。但是有一个问题就是上述所说的，INT_MIN的绝对值不是INT_MAX，而是INT_MAX+1。那么当a&#x3D;INT_MIN时，就需要额外操作了。</p>
<ol>
<li>一个负数的二进制补码是怎么样的？</li>
<li>为什么负数会比正数的范围大一，因此要做一些操作的时候是不是可以统一到负数范围去搞？</li>
<li>一个二进制补码除以2的n次方是怎么表示的？</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sd631032049/article/details/72781138">https://blog.csdn.net/sd631032049/article/details/72781138</a></p>
<ol>
<li>详细介绍了什么是原码，反码和补码，以及为什么要这么做的原因：计算机只有加法运算（所以计算负数的时候想要用负数的反码），并且不希望每一个整数都是一一对应一个二进制编码的（反码里+0和-0的表示方式不一样，会造成很很多计算的不方便，因此用补码）。</li>
<li>要区分出人的逻辑和计算机的逻辑，对于人来讲，数字有正负，并且规定说最高位是符号位。但是计算机CPU只能做加法，以及进位，不管是不是符号位计算机都一视同仁将它纳入计算中。所谓的原码，反码和补码都是人类推导的一种工具，计算机里只有二进制。</li>
<li>Int8表示的范围是[-128,127]，其实很好理解，画一个横轴，以0为界限，往右边是+1（0000 0001），+2（0000 0010）….，左边是-128（没有对应的原码和反码，但在计算机里的二进制是1000 0000），-127（1000 0001）……这里-128有一些怪异，其实是之前用原码表示的-0，被映射到了-128。</li>
<li>这里的巧妙之处还有就是在比较有符号数字的大小的时候，符号位相同，可以直接比较后面位的大小，比如-16[1000]会让-15[1001]就可以直接比较这两个二进制的大小。</li>
<li>还有一些数学上的推理，和系统的介绍可以参考CSAPP第三章的计算机编码的表示。</li>
</ol>
<p>因此，涉及到正负整数的计算的时候，要注意溢出。比如，int8 a &#x3D;-128，求绝对值就不会是128。<br>后续：写一个进制转换和有符号无符号转换的alfred工具<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97749860">https://zhuanlan.zhihu.com/p/97749860</a><br>这个位移还可以看作是乘以一个2^n次方和除以一个2的幂次方。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2021/03/30/%E3%80%90CSAPP%E3%80%91Ch3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81/" data-id="cl0t217c300019alfhflu6041" data-title="CSAPP-ch3-计算机编码" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【CSAPP】Ch7-链接" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/22/%E3%80%90CSAPP%E3%80%91Ch7-%E9%93%BE%E6%8E%A5/" class="article-date">
  <time class="dt-published" datetime="2021-03-22T06:12:53.000Z" itemprop="datePublished">2021-03-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/22/%E3%80%90CSAPP%E3%80%91Ch7-%E9%93%BE%E6%8E%A5/">【csapp】Ch7-链接</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ol>
<li>目标文件：一种是可重定位目标文件，比如.o文件；可执行目标文件，也就是链接完成后，可以直接复制到内存中运行的文件；还有一种共享目标文件，可以在加载或者运行时被动态加载进内存并链接。</li>
<li>ELF：linux系统下的目标文件格式。其主要由ELF头，各类型的节和节头部表组成。</li>
<li>ELF符号表中的符号可以分为三种：1. 自己模块定义，别人引用的叫做全局符号；2. 自己模块引用，别的模块定义的叫做外部符号；3. 自己定义自己引用的叫做局部符号（注意这里不是局部变量，局部变量运行后放入函数的栈中，而局部符号其实时全局变量，不归函数所有，比如定义在函数里的static变量。）</li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    C语言程序的编译已经是老生常谈，最常见的编译流程是：源代码（.c文件）-&gt;<strong>预处理</strong>-&gt;.i主要是处理宏定义和头文件等-&gt;<strong>编译</strong>-&gt;汇编文件（.s文件），就是汇编语言的代码-&gt;<strong>汇编器</strong>-&gt;可重定位目标文件（后续都称为.o文件）-&gt;<strong>链接器</strong>-&gt;可执行目标文件。    </p>
<p>​    这一章主要是说从汇编后的多个.o文件到变成一个完整的可执行目标文件的逻辑。首先，为了说明多个.o文件是如何合并成一个可执行目标文件，需要先介绍一些.o文件的结构，主要是引入符号和符号表的概念。然后第一个部分是广义的链接的步骤，主要就是符号解析和重定位。第二部分是对程序常用的标准库的链接方式，比如静态库和共享库。第三部分是对标准库函数的拦截，利用这个特点，我们能进行很多代码的调试。    </p>
<p><em>该文章以Linux X86-64架构，ELF目标文件为例说明链接的知识点。</em></p>
<h2 id="可重定向目标文件"><a href="#可重定向目标文件" class="headerlink" title="可重定向目标文件"></a>可重定向目标文件</h2><p>具体用C来说，这一部分主要是从.c文件到.o文件的逻辑。其核心在于将各个变量和函数分门别类的组织好，在linux下，.o文件被组织成多个节（section），每个节按照类型和作用来区分。典型的ELF可重定位目标文件的主要结构如下图所示：</p>
<p><img src="/Users/husyhu/Library/Mobile%20Documents/com~apple~CloudDocs/husy1994.github.io/source/_posts/image-20210325170253936.png" alt="image-20210325170253936"></p>
<p>而链接的核心部分就是.symtab这一节，这是该目标文件的所有符号的集合，包括了函数，全局变量和静态变量。它不仅记录了名字，类型还有定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux 64-bit下，一个符号的结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> name; <span class="comment">//字符串表中的字节偏移，指向符号的字符串名字</span></span><br><span class="line">	<span class="type">char</span> type:<span class="number">4</span>, <span class="comment">// 说明是函数还是数据</span></span><br><span class="line">	binding:<span class="number">4</span>; <span class="comment">//表示符号是本地的还是全局的，全局的需要重定位</span></span><br><span class="line">	<span class="type">char</span> reserved; <span class="comment">//保留位</span></span><br><span class="line">	<span class="type">short</span> section; <span class="comment">//表明该符号在哪个节里，值为节头部表的索引</span></span><br><span class="line">	<span class="type">long</span> value; <span class="comment">//对可重定位目标文件来讲，这是该符号的定义相对于所在节的偏移，比如一个函数名相对于.text起始位置的偏移；而对于最终的可执行目标文件，这个就是一个绝对地址。</span></span><br><span class="line">	<span class="type">long</span> size; <span class="comment">//该符号的大小，以字节为单位</span></span><br><span class="line">&#125;ELF64_Symbol;</span><br></pre></td></tr></table></figure>

<p>等所有的目标模块都解析完了，就可以开始链接成一个文件了。</p>
<ol>
<li>符号表和符号，每个可重定位目标文件都有一个符号表，也就是.symtab节。它保存了该段代码定义和引用的符号信息。（注意⚠️：本地链接器符号和本地程序变量不一样，.symtab不包含本地非静态程序变量的任何符号，也就是那些分配在栈上的变量）。下面就是符号的一个数据结构。</li>
</ol>
<h2 id="符号解析和重定位"><a href="#符号解析和重定位" class="headerlink" title="符号解析和重定位"></a>符号解析和重定位</h2><p>​    真正的链接主要就是两个部分，首先将各个.o文件的各个相同的section合并起来，然后修改对应的内存地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="type">long</span> offset;    <span class="comment">/* Offset of the reference to relocate */</span> </span><br><span class="line">    <span class="type">long</span> type:<span class="number">32</span>,   <span class="comment">/* Relocation type */</span> </span><br><span class="line">	 symbol:<span class="number">32</span>; <span class="comment">/* Symbol table index */</span> </span><br><span class="line">    <span class="type">long</span> addend;    <span class="comment">/* Constant part of relocation expression */</span></span><br><span class="line">&#125; Elf64_Rela; </span><br></pre></td></tr></table></figure>



<h3 id="同名符号的选择"><a href="#同名符号的选择" class="headerlink" title="同名符号的选择"></a>同名符号的选择</h3><p>​    可重定位目标文件仅仅是汇编器输出的文件，单一模块下不允许出现名字和类型相同的符号，当出现不在本模块定义的符号时默认会在别的模块定义。但是在链接的时候如何去区分不同模块的相同符号则有一些规则。</p>
<p>​    其算法很简单：</p>
<pre><code>1.    函数和初始化的全局变量是强定义
 2.    未初始化的全局变量是弱定义（包括extern引用的）
 3.    同名定义只能有一个强定义和0或若干个弱定义。 有强取其强，都弱随机取。
</code></pre>
<h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>​    考虑一个问题，大型软件的链接过程肯定需要很多的可重定位目标文件，并且包含大量基础的功能，比如数学算法，标准I&#x2F;O。如果把这些写到一个可重定位目标文件的话，会造成最后可执行文件的冗余，因为我们不一定使用了所有的符号。但是分开写成一个个.o文件的话，命令又太复杂。于是，提出来静态库来解决这个问题。</p>
<p>​    .a文件（archive）会让链接器只复制被程序引用的目标模块，而且也可以将很多的符号打包成一份.a文件，简化了链接时的命令（甚至有些链接器直接将一些约定俗成的.a文件默认加上）。</p>
<p>​    那么是按照什么逻辑来解析外部符号的呢？</p>
<pre><code>1. 维护三个集合，E（保存目标模块），U（保存未找到定义的外部引用），D（保存已经找到定义的符号集合）。
 2. 按照命令从左到右开始解析，如果是.o文件，就将其加入E，然后解析其符号分别修改U集合和D集合。
 3. 如果是.a文件，就依次用.a文件里的成员尝试去匹配U集合中的符号，找到了就将其成员放入E，修改对应的U和D。（也就是说，链接器不会解析.a文件里未定义的外部符号。）不包含在E中的成员目标文件都被丢弃，知道所有成员目标文件都处理完。
 4. 最后如果U中还存在有符号，则链接错误。
</code></pre>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>7.1 分别用<code>gcc -c m.c</code>和<code>gcc -c swap.c</code>得到可重定位目标文件，然后用<code>readelf -s m.o</code>和<code>readelf -s swap.o</code>来获取节信息。可以看到buf在m.o和swap.o的.symtab里都有，对于定义buf的swap.o来说，buf是全局符号，分配在.data上。而对于使用buf的swap.o来说，它则是外部符号，分配在UNF节中。</p>
<p>注意两个个细节，bufp1是在swap.c里定义的int指针，应该是全局符号，分配在.data里，但是实际上在COM里，意思是未初始化的全局变量。而bufp0同样是int型指针，却在.data节里。这里可以在7.6中的符号解析里说明原因，因为bufp1是一个弱符号。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">readelf -s swap.o</span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 12 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS swap.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     8: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 bufp0</span><br><span class="line">     9: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND buf</span><br><span class="line">    10: 0000000000000008     8 OBJECT  GLOBAL DEFAULT  COM bufp1</span><br><span class="line">    11: 0000000000000000    59 FUNC    GLOBAL DEFAULT    1 swap</span><br><span class="line">    </span><br><span class="line">readelf -s m.o   </span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 11 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS m.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     8: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 buf</span><br><span class="line">     9: 0000000000000000    21 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND swap</span><br></pre></td></tr></table></figure>

<p>7.3 C问题有一点疑惑就是，实践上来讲，.a文件是不能有外部符号的，因为链接器是不会对.a文件进行外部引用解析的。因此这里答案是<code>gcc p.o libx.a liby.a libx.a</code>而不是<code>gcc p.o libx.a liby.a libx.a p.o</code>这样和前面的解析过程是一样的。</p>
<p>### 重定位</p>
<p>重定位主要是分为两个步骤，第一个就是把所有文件链接起来以后，讲各自的节合并以后（a.o文件的.text节和b.o文件的.text节合并为一个整的.text节），叫做重定位节，最终的目的是把符号定义的地址更新。第二个是对重定位节里的符号进行重定位。</p>
<p>\4. 代码的重定位条目放在.rel.text里，<strong>已初始化数据</strong>的重定位条目放在.rel.data里。 重定位条目结构如下</p>
<p>`&#96;&#96;C</p>
<p>typedef sturct{</p>
<p>long offset; &#x2F;&#x2F;节偏移，比如该符号在.text节中被引用，那么就是相对于.text节的偏移</p>
<p>long type:32, &#x2F;&#x2F;重定位的类型，比如相对引用地址还是绝对引用地址</p>
<p>symbol:32; &#x2F;&#x2F;符号节（.symtab）里的对应符号</p>
<p>long addend; &#x2F;&#x2F;有一些类型的重定位需要偏移一个常数</p>
<p>}ELF65_Rela;</p>
<p>`&#96;&#96;</p>
<p>## 标准库的链接</p>
<p>### 可执行目标文件</p>
<p>基本结构也还是elf的结构，但是细节上有一些不一样。比如没有.rel.text等重定位节，但是除了节头部表，多了段头部表，这是为了后续加载器将代码段和数据段分开加载而出现的。</p>
<p>加载该可执行文件的工作主要有驻留在存储器中的OS代码进行加载，在linux下就是execve函数。程序的内存分布概念图如下（具体的细节请参考第8章和第9章）</p>
<p><img src="evernotecid://CAFA12C3-2596-44D8-8611-FC6C695ECC22/appyinxiangcom/17083332/ENResource/p11" alt="81d1cfecc5b84d4f92be47df25a71aef.png"></p>
<p>### 静态库</p>
<p>链接静态库的算法是：</p>
<p>\1. 维护三个集合（需要链接的.o文件集，引用了但未找到定义的集合，定义集合）从左到右扫描.a和.o文件。</p>
<p>\2. 解析每一个文件，更新上述三个集合。（这里还会涉及一个多重定义问题。）</p>
<p>\3. 最后如果引用集合非空则报错。</p>
<p>### 共享库</p>
<p>前面讲了静态库，将程序要用的标准库里的文件复制到整个程序文件目录里，但是这样又有一个问题。比如一些常用的标准输入输出函数，每一个程序都会有，那么在一台电脑上运行多个程序时，就会有多个备份。这显然也是一种浪费。</p>
<p>于是思路变成了在操作系统层面讲标准库加载一份，其余都重定位到这一份标准库的内存空间上。也就是可以被所有进程共享。</p>
<p>#### 加载时链接</p>
<p>在linux下的方式就是有一个动态链接器（ld-linux.so），在加载的时候自动进行动态链接。标准库libc.so就经常被动态链接上。注意是先加载再用动态链接器链接。相当于链接了两次。</p>
<p><img src="evernotecid://CAFA12C3-2596-44D8-8611-FC6C695ECC22/appyinxiangcom/17083332/ENResource/p12" alt="f6359d6aa1229bf7982e3e1679a7d251.png"></p>
<p>#### 运行时链接</p>
<p>在linux中就是由dlopen()接口，这个是由在代码层面写好代码来实现的。</p>
<p>### 拦截</p>
<p>## 疑问</p>
<p>\1. P468 7.5中说目标模块的符号表有三种符号，对应于非静态函数和全局变量(全局符号)，以及带static的静态函数和全局变量（局部符号）这里的全局变量也是针对非静态全局变量和static全局变量吗？我记得const全局变量类似于宏定义#define只是多了编译器的类型检查 。那么static全局变量和非static全局变量有什么区别吗？</p>
<p>\1. 是。 2. static的全局变量和非static的全局变量的区别就是<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3525576/internal-linkage-with-static-keyword-in-c">参考</a></p>
<p>\2. 在c语言文件中，任何带static的函数和变量都是私有的，而不带static的是公共的。</p>
<p>\3. 重定位符号什么时候是使用绝对地址什么时候使用pc相对地址？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2021/03/22/%E3%80%90CSAPP%E3%80%91Ch7-%E9%93%BE%E6%8E%A5/" data-id="cl0t1dcy600068slf48yobw84" data-title="【csapp】Ch7-链接" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-mit6.824课程笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/30/mit6.824%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-01-30T03:18:27.000Z" itemprop="datePublished">2021-01-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/30/mit6.824%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">mit6.824课程笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>课程首先从mapreduce入手，提出一种在大数据场景下的分布式处理方式。然后提出raft协议，这个协议构建的集群对于分布式系统可以提供一个基础服务，比如保存集群里的元数据。根据</p>
<h2 id="raft协议"><a href="#raft协议" class="headerlink" title="raft协议"></a>raft协议</h2><p>主要介绍：</p>
<ol>
<li>raft协议的选举过程，也就是leader，candidate和follower的状态转变，开发时要注意并发读写的问题。</li>
<li>Leader当选后，如何通过log队列来达到数据同步。leader获取到操作命令后转化成log entry复制给follower，当超过一半数量的follower都复制完毕后，才可以commit该log entry。而commit才意味着client对该分布式服务器的操作成功。<br>￼<br>继续扩展一些细节处理，比如crash recovery以及log的压缩。有一个很重要的概念是Linearizability（线性一致性），这是对分布式系统复杂操作结果的正确性的定义。用我自己的话介绍一下就是：<ol>
<li>考虑到一个简单操作对于分布式系统来讲是一个耗时操作，并且其真正的执行顺序不依照操作的请求顺序。</li>
<li>而一个操作的结果被另一个线程或者请求感知的时间点可以发生在该操作的任何时候，所以只要两个操作有时间上的重叠，那么操作A在任何时间点上都可能观察到操作B修改的数据。</li>
<li>将操作抽象成原子的，如果你能找到一种顺序让它们彼此获取到的结果不相矛盾。<br>那么这个系统就是符合线性一致性的。</li>
</ol>
</li>
</ol>
<p>这就扩展到了一个细分领域，分布式系用的一致性问题，暂且不表。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59119088">https://zhuanlan.zhihu.com/p/59119088</a></p>
<h2 id="Fault-Toleration"><a href="#Fault-Toleration" class="headerlink" title="Fault Toleration"></a>Fault Toleration</h2><p>￼<br>￼</p>
<h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><p>￼<br>Zookeeper - 博客<br>通过介绍zookeeper的案例，来介绍以下几个问题的答案：</p>
<ol>
<li>如何设计一个独立通用的分布式协调服务给分布式业务集群使用？它的api是怎样的？</li>
<li>别的分布式应用要怎么使用它？<br> 1. </li>
<li>它的性能可以随着机器的增加而线性增加吗？<ol>
<li>首先是写肯定是随着follower的增加而降低效率，因为需要保证线性一致性。</li>
<li>但是如果可以向follower读数据的话，其负载量就可以随着follower成倍扩张。但这样一来，读到的数据就不能保证是最新的。Linearizablity是不允许过期数据的。</li>
<li>zookeeper通过保证一种巧妙的秩序来放松对linearizability来实现负载的线性增长。<ol>
<li>Linearizability Writes（leader接收写请求，并给它编号顺序）</li>
<li>每一个client都接收read请求，但要等到该client本地log在该read请求之前的写请求都已经执行完毕。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Craq"><a href="#Craq" class="headerlink" title="Craq"></a>Craq</h2><p>￼<br>￼<br>前面raft的拓扑结构是放射状的，由leader去给所有follower交互，这里leader的带宽也是一个瓶颈。craq的处理办法是，用链形的拓扑结构，leader只会同步数据给一个follower，然后follower1同步给follower2。缺点就是这个链的容灾很脆弱，链中间的一环要是crash了，后面就都无法获取到数据了。</p>
<h2 id="frangipani"><a href="#frangipani" class="headerlink" title="frangipani"></a>frangipani</h2><p>￼<br>主要是通过介绍frangipani这个分布式</p>
<p>文件系统的实现，来介绍下面三个概念。</p>
<ol>
<li><p>cache coherence。也就</p>
</li>
<li><p>是不同单机上的修改，如何同步到其余单机上：通过锁服务器(LS)去保护每一个文件的读写，修改先只在本地workstaion1缓存，并修改LS的记录。当有别的单机workstation2需要访问时，LS会去通知workstaion1将缓存写回分布式文件系统，从而保证workstaion2读取到的文件内容是最新的。</p>
</li>
<li><p>distributed transaction。</p>
</li>
<li><p>也就是如果一个事物的逻辑处理在不同的单机上，要如何保证操作的原子性？</p>
<ol>
<li>通过2PL（2-phase locking）在事务开始前获取一个事物级别的锁，然后对要处理的每一个文件对象都要获取相应的锁，直到所有操作都完成，才能依次释放每一个锁。</li>
<li>通过2PC（2-phase commit），事务协调者（transaction coordinator，TC）给事务参与者发送一个prepare指令，询问参与者是否可以执行。如果所有参与者都返回ok，就发送一个commit，让参与者执行对应操作。这里参与者获取到prepare询问后，可以将操作先写入log，或者先写入缓存，等到commit指令为执行时就去执行，或者写会硬盘。</li>
</ol>
</li>
<li><p>Crash recovery：written-ahead log，也就是在修改数据前，先将操作记录写入log，然后再操作。这样可以在crash后从log中重新执行来保证数据的一致性。<br>分布式的应用的设计思路大多都来自于上面的概念，至于具体的实现，则需要自己根据实际去优化。比如frangipani里的优化有：</p>
</li>
<li><p>读和写对锁的要求不一样，读不需要独占锁，写才需要独占锁；</p>
</li>
<li><p>将不同workstation拥有的锁的文件和其修改状态分别写在不同的文件&#x2F;机器上，这样可以减少写的冲突。</p>
</li>
</ol>
<h2 id="raft和2PC"><a href="#raft和2PC" class="headerlink" title="raft和2PC"></a>raft和2PC</h2><pre><code>这里开始介绍了一个非常重要的分布式事务的概念——2PC。而raft里也有一个机制是，先把请求写进log channel，等到leader提交commit 请求后，才会真正去执行这个log的内容。看起来，这里的raft也用到了2PC这个机制。但这是错误的，这是两个完全不相关的概念。唯一相同的只是两次请求的形式。

在raft的复制里，追求的是log被多数follower接受认可，从而达到数据在多台机器上保持一致，这个集群里每个机器上的数据是一样的，至少目标是一样的。 它的作用是为了高可用（HA）。

而2PC是为了解决分布式事务提出来的，它也是会向多台机器发送请求，也就是prepare，但是这里的prepare是不同的数据操作请求，此时的集群每个机器保存的数据都不一样，之所以需要两次提交，是因为事务的要求。这里的目标是数据一致性。
</code></pre>
<h2 id="ACID和CAP"><a href="#ACID和CAP" class="headerlink" title="ACID和CAP"></a>ACID和CAP</h2><p>ACID是数据库的一个要求，也就是Atomicity（可以执行事务），Consistency（对数据的操作不会破坏对数据的约束），isolation（可以并发请求事务）和durability（容错）。 CAP理论是分布式集群的一个评价标准，也就是Consistency，availability和Partition tolerance。这三种要求只能实现两种。</p>
<p>这里ACID和CAP里都有一个Consistency，但其实是完全不同的维度。ACID里指对数据的修改要始终符合一定的规则，不被篡改等。而CAP里是指在同一时刻，不同机器上的数据要相同。当然这里还有一些程度上区分，根据多久能达到一致分为最终一致性等。</p>
<h3 id="单机系统的数据同步"><a href="#单机系统的数据同步" class="headerlink" title="单机系统的数据同步"></a>单机系统的数据同步</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247486479&amp;idx=1&amp;sn=433a551c37a445d068ffbf8ac85f0346&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247486479&amp;idx=1&amp;sn=433a551c37a445d068ffbf8ac85f0346&amp;scene=21#wechat_redirect</a><br>这里是介绍了多核CPU的缓存一致性：用MESI协议来保证。其基本思路就是：<br>    1. 写传播（Wreite Propagation)，有修改到共享变量需要广播给其余核；<br>    2.事务的串形化（Transaction Serialization)，也就是多个cpu操作对其余内核而言需要封装成原子性操作，这就引入了锁的概念（实际上这里是通过一个状态机去模拟的锁）。<br>数据同步不仅仅出现在宏观的分布式服务里，也会出现在多核的cpu计算单元里，虽然实现不同，但基本思路都是一样的。</p>
<h2 id="Spanner"><a href="#Spanner" class="headerlink" title="Spanner"></a>Spanner</h2><p>￼<br>上面讲完了不同服务器之间数据同步，Spanner的难点在于多个Datacenter之间的数据同步，比如执行一些不同shard之间的事务操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2021/01/30/mit6.824%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" data-id="cl0t217c200009alfbn9z5wdr" data-title="mit6.824课程笔记" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-golang语言笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/06/golang%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-01-06T02:51:00.000Z" itemprop="datePublished">2021-01-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/06/golang%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/">golang语言笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-range关键字"><a href="#1-range关键字" class="headerlink" title="1. range关键字"></a>1. range关键字</h2><p><a target="_blank" rel="noopener" href="https://studygolang.com/articles/9701">go语言坑之for range</a> 简单来讲就是用<code>for k,v:=range data</code>的方式获取元素的话，v变量只会创建一个，地址是一样的，所以坑就在于如果对v直接做什么操作的话是不会操作到真正的data里的元素上去的。</p>
<p>参考<a target="_blank" rel="noopener" href="https://golang.org/ref/spec#RangeClause">go官方文档</a></p>
<blockquote>
<p>The iteration variables may be declared by the “range” clause using a form of <a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Short_variable_declarations">short variable declaration</a> (<code>:=</code>). In this case their types are set to the types of the respective iteration values and their <a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Declarations_and_scope">scope</a> is the block of the “for” statement; they are <strong>re-used</strong> in each iteration. If the iteration variables are declared outside the “for” statement, after execution their values will be those of the last iteration.</p>
</blockquote>
<p>因此好的习惯是，一般情况下用<code>for i,_:=range data</code>，用索引来取值防止一些错误，更重要的是防止不必要的实例创建。</p>
<h2 id="2-引用类型"><a href="#2-引用类型" class="headerlink" title="2. 引用类型"></a>2. 引用类型</h2><p>slice是golang里的引用类型，但和C++里的引用毫无关系。其底层的实现实际上是</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span>            <span class="comment">// 长度 </span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span>            <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以看出，slice就是一个含有指针的结构体。因此也会有一些结构体传输的特点，比如传递一个切片，在修改某一个值时形参和实参会同时变化，因为指向的是同一个数组。但当操作涉及到修改数组长度的时候，由于runtime会另外开辟一个空间复制整个数组，因此形参和实参指向的数组就变化了。</p>
<p>​    但是同为引用类型的map，chan就不一样了，它们的底层实现就是特定结构体的指针，因此不需要再去注意形参和实参的问题了。另外，map和chan一定要用make创建，不然其零值为nil。但是slice可以看出，不需要make创建，就算是单独声明一个也不是nil，而是一个array指针指向nil的slice对象。</p>
<p>​    因此，传递slice的时候还是尽量用指针，传递map和chan的时候就不需要了。</p>
<h2 id="3-闭包与参数传递"><a href="#3-闭包与参数传递" class="headerlink" title="3. 闭包与参数传递"></a>3. 闭包与参数传递</h2><p>​    <a target="_blank" rel="noopener" href="https://jingwei.link/2019/06/01/golang-outer-variable-in-clousure.html">Golang 闭包内的外部变量</a>，匿名闭包函数直接使用外部变量是地址传递，也就是在执行的时候是会根据变量的变化获取的数据也不一样。</p>
<p>​    但是如果加上了go或defer关键字，则情况有所不同。因为在处理go或者defer时，编译器要准备好后面函数的参数堆栈，从而就要确定参数的值。也就是说defer和go关键字会先在声明处将参数堆栈等准备好，只是说延后了函数的执行。参考<a target="_blank" rel="noopener" href="https://tonybai.com/2018/03/23/the-analysis-of-the-param-evaluation-of-defer-functions/">defer函数参数求值简要分析</a></p>
<p>​    总的来说就是外部变量如果是函数体内直接使用，实际上是获取其地址，在执行的时候才会去求值；而放在参数上的变量，在声明时就求值了，因为golang里所有参数传递都是值传递。</p>
<h2 id="5-指针接收和结构体接收"><a href="#5-指针接收和结构体接收" class="headerlink" title="5. 指针接收和结构体接收"></a>5. 指针接收和结构体接收</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> bb <span class="keyword">struct</span>&#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(b *bb)</span></span> Read()&#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Read  my name is %v\n&quot;</span>,b.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(b *bb)</span></span> Write(newName <span class="type">string</span>)&#123;</span><br><span class="line">    b.Name=newName</span><br><span class="line">    fmt.Printf(<span class="string">&quot;write my newName is %v\n&quot;</span>,b.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(b bb)</span></span> Read1()&#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Read  my name is %v\n&quot;</span>,b.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(b bb)</span></span> Write1(newName <span class="type">string</span>)&#123;</span><br><span class="line">    b.Name=newName</span><br><span class="line">    fmt.Printf(<span class="string">&quot;write my newName is %v\n&quot;</span>,b.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   b1:=&amp;bb&#123;</span><br><span class="line">      Name:<span class="string">&quot;husy&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   b2:=bb&#123;</span><br><span class="line">      Name:<span class="string">&quot;husy&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   b1.Read()</span><br><span class="line">   b1.Write(<span class="string">&quot;husyhu&quot;</span>)</span><br><span class="line">   b1.Read()  </span><br><span class="line">  </span><br><span class="line">   b2.Read1()</span><br><span class="line">   b2.Write1(<span class="string">&quot;husyhu&quot;</span>)</span><br><span class="line">   b2.Read1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Read  my name is husy</span></span><br><span class="line"><span class="comment">write my newName is husyhu</span></span><br><span class="line"><span class="comment">Read  my name is husyhu</span></span><br><span class="line"><span class="comment">Read  my name is husy</span></span><br><span class="line"><span class="comment">write my newName is husyhu</span></span><br><span class="line"><span class="comment">Read  my name is husy</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​    由上可知，如果是结构体接收者，因为在调用的时候是把整个结构体赋给一个临时的结构体对象，然后进行操作。除非该结构体内的数据都是指针类型，否则基本上就意味着这个结构体内的数据只可读，并不能改变其值。一般来讲，应该用指针接受者。可以参考一个坑来帮助理解<a target="_blank" rel="noopener" href="https://tonybai.com/2018/03/20/the-analysis-of-output-results-of-a-go-code-snippet/">对一段Go语言代码输出结果的简要分析</a></p>
<h2 id="6-interface与类型转换"><a href="#6-interface与类型转换" class="headerlink" title="6. interface与类型转换"></a>6. interface与类型转换</h2><p>​    还是以5的代码为例，若是有一个interface a声明了Read而没有声明Write，当把bb赋值给a类型的时候，但是通过a无法调用write了。这里虽然看起来像是一个动态类型转换，但其实调用reflect获取a的type和value和获取bb的一样，不会变。所以这里不是真正的动态类型转化，一旦声明了，其类型就是一个静态的不会变了。但转换的好处是，方便抽象化以及限制了不属于该接口的方法调用。</p>
<p>​    有一个常见的设计模式是工厂模式，先声明一个interface{}变量A，然后根据实际情况来更换具体实现赋值给该变量A。这在C++里是很好的设计模式，在Golang里就不行了，因为变量A一旦被赋值了一个具体实现，其类型就确定了不能更改了。如果想替换成另一个具体实现，就要重新声明变量。</p>
<h2 id="7-继承对象的初始化"><a href="#7-继承对象的初始化" class="headerlink" title="7. 继承对象的初始化"></a>7. 继承对象的初始化</h2><p>匿名对象的初始化必须遵循一层一层的初始化的逻辑，其类型名就是属性名。比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Foo struct&#123;</span><br><span class="line">    A string</span><br><span class="line">    B int</span><br><span class="line">&#125;</span><br><span class="line">type Foo2 struct&#123;</span><br><span class="line">	Foo</span><br><span class="line">	C bool</span><br><span class="line">&#125;</span><br><span class="line">//此时要初始化Foo2的话</span><br><span class="line">a:=Foo2&#123;&#125;</span><br><span class="line">a.Foo=Foo&#123;A:&quot;a&quot;,B:1&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-逃逸分析"><a href="#8-逃逸分析" class="headerlink" title="8. 逃逸分析"></a>8. 逃逸分析</h2><p>​    为什么需要了解逃逸分析是因为</p>
<blockquote>
<p> <strong>stack allocation is cheap and heap allocation is expensive</strong>.</p>
</blockquote>
<p>​    所以目标就是尽量让能分配在stack上的分配在stack上。</p>
<p>​    golang语言在编译时才会决定某个对象是分配在堆上还是栈上。按照C++的传统来说，除了用new分配的局部变量，其余的局部变量都会分配在栈上，退出函数后立即回收。但是Golang虽然也有new，但是无论是局部变量还是new的对象都会经过编译器的分析来决定放在堆上还是栈上。</p>
<p>​    当然各个版本的编译会有细微差别，具体问题具体分析，可以用<code>go build -gcflags &quot;-m&quot;</code> 来查看。总结来讲，通过下面例子可以总结几点：</p>
<p><img src="/Users/husyhu/Library/Mobile%20Documents/com~apple~CloudDocs/husy1994.github.io/source/_posts/image-20210318153230968.png" alt="image-20210318153230968"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//下面是输出结果</span><br><span class="line">go run -gcflags &quot;-m -l&quot; ex1.go</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">command-line-arguments</span></span><br><span class="line">./ex1.go:14:9: leaking param: title</span><br><span class="line">./ex1.go:15:16: do ... argument does not escape</span><br><span class="line">./ex1.go:15:16: title escapes to heap</span><br><span class="line">./ex1.go:9:8: func literal escapes to heap</span><br></pre></td></tr></table></figure>

<p>​    任何一个函数调用都伴随着参数的传递，也就是内存的分配。</p>
<ol>
<li>main函数的s逃逸到了堆上，因为闭包函数引用了外部变量。编译器无法保证goroutine里的do函数什么时候会不需要s对象了，因此不敢放在栈上。</li>
<li>do函数的参数title没有逃逸，它就在do函数的栈上。 等do函数执行完成，就会被回收。</li>
<li>fmt.Println的参数title会逃逸到堆上，而不是在fmt.Println的栈上，因为这个函数的接收参数类型是interface{}，interface类型的参数也会直接分配到堆上。因为编译器不确定其类型。</li>
<li>另外就是，如果栈内存不够了，也会分配到堆上。</li>
<li>以及被发送到channel里的对象，也会全部在堆上。</li>
<li>被slice，map和数组引用的对象。注意是每一个元素，不是slice或者map本身。</li>
</ol>
<h2 id="9-go-mod的replace"><a href="#9-go-mod的replace" class="headerlink" title="9. go.mod的replace"></a>9. go.mod的replace</h2><p>​    参考<a target="_blank" rel="noopener" href="https://seanxp.com/2019/05/go-module-note/">Go Module Notes</a>， 要理解顶层依赖和间接依赖，replace只能替换顶层依赖。也就是说自己的业务代码引用了A包，被替换成了B包，这是可以的。但是如果是引用的A包和B包，A包又引用了B包，那么A包引用的那个B包是间接依赖，go.mod的replace是不能替换的，这也是站在A包的角度考虑。</p>
<h2 id="10-断言"><a href="#10-断言" class="headerlink" title="10. 断言"></a>10. 断言</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> foo1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> foo2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	B <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = &amp;foo1&#123;A: <span class="number">1</span>&#125;</span><br><span class="line">	aa := a.(*foo2)</span><br><span class="line">	<span class="comment">// aa, ok := a.(*foo2)</span></span><br><span class="line">	<span class="comment">// if ok &#123;</span></span><br><span class="line">	<span class="comment">// 	fmt.Print(aa)</span></span><br><span class="line">	<span class="comment">// 	return</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	fmt.Print(aa)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有返回ok的判定，那么就不会引起panic，因此断言最好是加上ok的处理。</p>
<h2 id="11-map"><a href="#11-map" class="headerlink" title="11. map"></a>11. map</h2><p>下面的代码是不会崩溃的，尽管map的默认初始化是nil。但是如果对<code>b[&quot;test&quot;]</code>赋值才会panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">	fmt.Println(b[<span class="string">&quot;test&quot;</span>] )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2021/01/06/golang%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/" data-id="cl0t1dd10004l8slfehwh03nl" data-title="golang语言笔记" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-mit6-824-lab2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/02/mit6-824-lab2/" class="article-date">
  <time class="dt-published" datetime="2020-12-02T05:07:50.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mit6-824/">mit6.824</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/02/mit6-824-lab2/">mit6.824-lab2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>任何一个goroutine都需要有return的逻辑，也就是先保存好这个goroutine开启时的raft term和state，一旦检测到raft的即时term和state不符合开启时保存的term和state，立即结束该goroutine的逻辑操作，return。这样一来可以防止不符合条件的raft执行过期的操作，二来也防止goroutine泄漏，一直在执行。</li>
<li>对于锁来讲，最方便的方式是对一个逻辑从头锁到尾。但是要注意不要锁住耗时操作，比如rpc请求就需要放入goroutine里等等。被锁分开的上下的临界区，应该要立即检查状态是否变更。</li>
<li>在unreliable network背景下，不能假设rpc 请求的先后顺序，以及reply抵达的先后顺序。考虑一个情况：<br> A. Leader A在接收到LogEntry1时发送复制请求1，然后又接收到LogEntry2，再次发送复制请求2。<br> B. 复制请求2先于1到达，由于请求1还没有成功返回，所以复制请求2会带上1的logEntry。follower也会复制所有的logEntry，请求2完成后follower的log已经是最新的了，但是此时，请求1到达了，如果只是简单地比较term等复制的话，log反而会回退。<br> C. 上述引起的后果是<br> a. Leader的commitIndex可能会偏高，因为它已经收到了大部分日志复制请求成功的reply，但实际上有一些follower回退了。<br> b. 此时如果有人竞选，一定情况下可能会导致日志不是那么新的peer成功竞选，从而覆盖掉了已经被commit的logEntry。<br> D. 为了避免这个问题：不能让老的日志请求更新log<br> a. Follower处理日志复制请求的时候，直接一个个地比对，遇上不匹配的（下标一致，term不一致等），就截断，开始复制替换，否则不会替换截断。</li>
<li>如果reply可以知道该请求复制完成后有多少个log（XLen），是否可以直接更新NextIndex？<br> A. 如果我们复制日志的时候确定就是Follower多的log都截掉。<br> B. 遇上heartbeat请求，没有带LogEntry，但是又匹配上了prevLogIndex和prevLogTerm，此时会直接截断掉prevLogIndex后面的log吗？应该要分开来处理吗？</li>
<li>为什么raft的nextIndex需要用args.PrevLogIndex+len(args.LogEntries)？ note上说如果state变化了，就会有问题，但是变化了state，就不会再用到nextIndex了。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2020/12/02/mit6-824-lab2/" data-id="cl0t1ddcb005h8slf2id92f3x" data-title="mit6.824-lab2" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/distributed/" rel="tag">distributed</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/raft/" rel="tag">raft</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-mit6-824-guide" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/10/mit6-824-guide/" class="article-date">
  <time class="dt-published" datetime="2020-11-10T07:26:26.000Z" itemprop="datePublished">2020-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mit6-824/">mit6.824</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/10/mit6-824-guide/">mit6.824-guide</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文主要是对<a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/instructors-guide-to-raft/">Instructors’ Guide to Raft</a>的总结。</p>
<ol>
<li><p>heartbeat RPCs不是一个特殊的RPC，它也是AppendEntry，只是携带的Log为空。也就是说，对AppendEntry请求的一些检查，对heartbeat也要有。比如term的比较，比如prevLogIndex等等，甚至也需要更新自身和leader的commitIndex。</p>
</li>
<li><p>AppendEntry不应该是简单的比对完prevLogIndex后发现没有冲突，就把Log append到prevLogIndex后面，而是要仔细比对，直到出现有冲突的log，才进行数据的修改。删掉该index及往后的log。这样做的原因是AppendEntry可能有旧的RPC晚到，直接append会导致LOG反而变短了，那么就可能导致commit后的Log并没有出现在大部分的服务器中。</p>
</li>
<li><p>出现LiveLocks的常见情况是，集群不停地在选举，但是没有leader选出来，或者刚选出来又有新的candidate要竞选。有一个常见原因是reset election timer的时机不对，只有三个情况要reset</p>
<ol>
<li>从当前的leader收到了AppendEntry请求，也就是args.term要等于自己的currentTerm。</li>
<li>自身开始了竞选，也就是在竞选函数最开始就可以reset了。</li>
<li>给别的peer投了一票，也就是在检查了日志是否是最新的，检查了term等等，可以给该candidate投票的时候才reset，而不是一收到RPC就reset。</li>
</ol>
<p>reset election timer的时机越多，选举成功的概率就越小，因为发起竞选的概率变小。所以思路一定是让日志更多更“新”的peer快速发起竞选成为leader。</p>
</li>
<li><p>选举过程中election timeout了，应该自增一个term，开启另一个新的竞选，尽量赶紧结束当前term的竞选。因为有可能有一些丢弃的rpc返回，或者网络延时，不能让raft服务器一直卡在一个流程里。</p>
</li>
<li><p>一旦遇到term比自身currentTerm大的request或者response，立马回滚为follower，更新currentTerm，然后再做别的操作。比如收到一个term大于自己的voteRequest，那么应该是将自己立即回滚为follower然后再继续处理这个request，看是否需要投票。</p>
</li>
<li><p>如果有一个操作足以能够确定reply false，那么就立即返回，不要再往下走了，一来可以尽早释放抢占的锁；二来可以防止多余的操作会修改一些共享变量。</p>
</li>
<li><p>如果你收到了一个prevLogIndex比自身的日志最大下标还要大的AppendEntry RPC，和term不匹配一样的处理，也是返回false。当然还可以再增加一些字段让log的回溯更加快速。</p>
</li>
<li><p>commitIndex&#x3D;min（leaderCommitIndex，log当前的最大下标）。</p>
</li>
<li><p>比较日志的新旧标准：先比log的长度，更长的更新；一样长的比较最后一个logEntyr的term，更大的更新。</p>
</li>
<li><p>任何时候都要保证commitIndex要大于lastApplied</p>
</li>
<li><p>当leader的appendEntry收到的rpc回复是false，而不是因为log不匹配的时候（一般是因为term已经过期了）回退为follower但是最好不要再更改nextIndex了，因为很有可能你立马开始重新选举，就会造成竞争。</p>
</li>
</ol>
<h2 id="debug的建议"><a href="#debug的建议" class="headerlink" title="debug的建议"></a>debug的建议</h2><ol>
<li>使用awk过滤日志</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;/.*(kv\[2\]|raft\[2\]).+/&#123;print&#125;&#x27; log.txt &gt;log_2.txt</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ctrl+\打印goroutine堆栈查看死锁</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2020/11/10/mit6-824-guide/" data-id="cl0t1ddca005d8slf9buy7uex" data-title="mit6.824-guide" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/raft/" rel="tag">raft</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-mit6-824-lab3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/10/mit6-824-lab3/" class="article-date">
  <time class="dt-published" datetime="2020-11-10T02:59:32.000Z" itemprop="datePublished">2020-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mit6-824/">mit6.824</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/10/mit6-824-lab3/">mit6.824-lab3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-实验概述"><a href="#1-实验概述" class="headerlink" title="1. 实验概述"></a>1. 实验概述</h2><p>lab3开始了raft的应用部分，主要是写一个简单的分布式存储数据库，其数据主要是存储在各个kvserver的内存map中。lab3A要完成的是Put，Append和Get功能，lab3B要完成的是数据快照及日志压缩的逻辑。</p>
<h2 id="2-lab3A"><a href="#2-lab3A" class="headerlink" title="2. lab3A"></a>2. lab3A</h2><h2 id="2-1-从client一次请求全流程"><a href="#2-1-从client一次请求全流程" class="headerlink" title="2.1 从client一次请求全流程"></a>2.1 从client一次请求全流程</h2><ol>
<li>client向server发起请求；</li>
<li>如果该server对应的raft状态机不是leader，就直接返回WrongLeader错误给client；</li>
<li>如果该server对应的raft状态机是leader状态，就接收这个请求，将其写入自己的logs里，然后进行同步，等该raft commit；</li>
<li>等到raft把该logEntry送入applyCh的时候，server会收到该logEntry一一执行（也就是给本地map做一些增删改查的操作），然后再把结果返回给client。</li>
</ol>
<h2 id="2-2-几个核心问题"><a href="#2-2-几个核心问题" class="headerlink" title="2.2 几个核心问题"></a>2.2 几个核心问题</h2><ol>
<li>client对server的请求是直接从0开始轮循，如果请求返回WrongLeader，则直接+1下一个；</li>
<li>所有的请求都需要被commit，然后从applyCh里获取到执行了，才能返回给client；</li>
<li>要考虑网络的不可靠性。比如rpc请求发送了也执行了，但是返回时失败了。那么client一定时间内没收到response的策略肯定是重试，那么此时server要保证一次请求的幂等性。不能让命令重复操作。策略是：因为我们保证client是单线程的，那么一个请求没有完成是不会再请求另一个的。所以可以给每一个client的每一个不同的request指定一个自增id，在kvserver端去检查是否已经执行了。</li>
<li>因为从接收到请求到获取到结果实际上是异步操作，那么要如何通知到接收请求的函数该请求已经执行完毕可以返回结果了呢？策略是：比较容易想到的是对于每一个从applyCh里接收到的logEntry，它在raft集群里的log index是确定且唯一的，那么可以对每一个log index创建一个channel用于server内部response的接收和发送。但有一个风险点：logA请求从start函数获取到了index，创建了channel，但是最后这个log commit失败了，该index被别的logB请求覆盖掉了，那么此时可能有两个地方在读取这个channel，但只有一个地方写，并且只会写一个。这种方法不好保证写入channel的数据会被正确的logB请求读取到，那么就会产生错误的返回。一个解决办法是，从channel中读取到response的时候，检查一下是否是自己的请求回应，如果不是，重新写回channel以供别的channel去读。</li>
<li>对于一个请求，如何确定它？ 用clientID+seq</li>
<li>TestBasic3A和TestConcurrent3A比较好解决，就是按照说明来，也不需要给去重；记得给本地存储data的map的读写加锁就好</li>
<li>TestUnreliable3A这个实验引入了网络的不稳定，raft的不稳定可以不管，lab2已经解决了，这里的不稳定有两个地方：a.底层raft随时有可能重新选举，更改了leader，那么发送给了old term leader的logEntry要怎么处理？b.上层client的调用会出现超时错误，这里有处理逻辑吗？<br>A. 看一下labrpc.go代码就知道，unreliable的影响有两个，一个是request没有发出去，一个是发出去了，对raft等有作用了，但没有收到状态为ok的reply的。<br>B. 这里就需要我们注意不要重复apply 相同的logEntry。这个检测是在commit阶段做呢还是在apply LogEntry阶段去做呢？ 如果不做重复检验，直接start，最后在apply的时候检验重复，会造成Log的冗余，但如果在commit阶段就做，可能有一个request没有commit成功，但是因为已经被提交过了，所以不会再次被提交。</li>
<li>有一个要注意的是，不能在LogEntry apply了以后，才去申请锁，然后去读data map，这样是不符合线性逻辑的。因为get如果比put早提交，就应该只读到put操作以前的数据，但是这里申请锁去读data map很有可能已经执行了别的put操作了。</li>
<li>如何维护一份数据，记录已经执行过的seq的client命令？<br>A. 最暴力的是保存一份map，记录下每一个seq命令是否执行。<br>B. 只记录当前最大的seq，这是建立在同一个clerk只会被串行执行命令的假设下。（论文里是这样假设的）</li>
<li>Linearizable的含义：并发的请求与获得response之间的时间差内，能够观察到的数据结果都是ok的。所以尽管一个Get先执行，但是获取到的是后执行的put命令执行完的结果，这也是ok的。</li>
<li>关于超时错误，一般来讲是因为发送的leader过期了迟迟没有commit，因此最好也是继续轮询，而不是重试。</li>
<li>关于snapshot，需要存储raft的state防止宕机重启后可以恢复，另一方面也要存储kvserver的data数据，从而可以压缩log，防止占用的内存无限扩大。</li>
</ol>
<h2 id="3-lab3B"><a href="#3-lab3B" class="headerlink" title="3. lab3B"></a>3. lab3B</h2><p>快照功能是为了解决log太长的问题。有两个线索，第一个是对于每一个raft来讲，他要独立地进行快照，裁剪log。第二个是当leader发现某个followe的log落后太多（nextIndex比lastIncludeIndex还要小），那么先不发AppendEntry RPC，而是发送InstallSnapshot RPC。</p>
<h2 id="3-1-几个核心问题"><a href="#3-1-几个核心问题" class="headerlink" title="3.1 几个核心问题"></a>3.1 几个核心问题</h2><ol>
<li>什么时候检测log的大小？</li>
<li>appendEntry时如果prevLog对不上要快速回退，这里就会有一个问题，如果follower的LastIncludeIndex比较小，那么leader去取的时候是会取不到的，这个时候的策略应该是不要管follower的reply传过来的，因为说明此时follower的log已经过期很久了，lastIncludeIndex追不上了。</li>
<li>有一个错误是applyChan要做成缓冲的，否则只要kv去压缩快照就会要获取rf的锁，但是rf再applyLog处会抢到锁然后卡住，最后会形成死锁。一个宗旨还是，不要用锁去锁耗时阻塞操作。</li>
<li>InstallSanpshot的RPC调用也需要一系列的判断，比如term比如是否是最新的（通过比较LastInclude和LastApplied等等）</li>
<li>raft存储当前状态的时候也要存储LastIncludIndex和LastIncludeTerm。</li>
<li>如何去提醒server提交的log已经被apply了，有几种方式<br>A. Server的请求不断去轮训raft的lastappliedIndex，等到比自己的收到的index大的时候，比较一下该log与自己提交的是不是一致，然后就可以判断了。缺点是需要系统对lastAppliedIndex会多了很多读写，而这个读写是加锁的，这就会造成系统效率不高。<br>B. 整个server维护一个map[index]chan，对于每一个提交的log的index都有一个chan去写协作，applyLog以后就往对应的index里发送一条消息，而server端会阻塞在读这条消息。但有一个问题是，如果我有两个client发送消息，A提交log获取到的index是10，但是这条消息没有被commit，紧接着Client-B也提交了一个log，获得的index也是10，此时该server的raft执行下标为10的log，给chan发送消息，A先收到，会导致A去检查发现不符合，B一直收不到请求，但是其实已经成功了。有一种解决办法是，引入超时机制，然后呢，再加入重复检测，在apply阶段遇到了已经执行过的seq就不再执行，直接返回，给chan写通知。<br>C. 如果直接在command里加一份chan，作为apply结果的返回channel，有一个问题是，其实每一个index理论上只有一个读，但是apply会有很多个写，因为follower也需要apply log，但只有leader需要读chan。</li>
<li>各司其职：由于请求是kvserver传向raft，因此只能在kvserver里检测log是否太大；logSize超过了以后，将kvserver的data结果序列化发送给raft，再由raft去持久化.</li>
<li>活锁问题：</li>
</ol>
<ul>
<li>现象：TestSnapshotRecover3B的测试有时候会出现两个raft轮流竞选leader，没有其余raft的log打印。这个问题的根源应该在于另外3个raft被锁住了没有进展也接收不了投票请求，从而导致没锁的两个开始疯狂竞选。仔细观察日志，发现另外三个在最后的Get操作前有一次snapshot操作。首先，我们调用start，然后appendLogEntry会拿到一个raft的锁，然后在释放前要执行完applyMsg的逻辑。而applyMsg的逻辑里有和kvserver交互的，如果此时kvserver检查发现需要snapshot后，就会让raft执行snapshot，而这个snapshot也需要raft的锁。此时就锁住了。<br>• 所以还是一个原则，有任何耗时操作都要注意，是否应该放入锁中。无论是rpc调用还是对外部系统的请求；<br>• 其二是对于并发请求的变量，要时刻注意锁带来的原子性。比如getAgreeCh哪里。</li>
<li>因此，这个applyMsg需要开协程完成。但又要注意apply如果开协程，那么执行时的状态和当时调用applyMsg的状态不一致了，很有可能导致重复执行。因此要把当时的状态传进去，然后里面再加一个锁来看。</li>
<li>如果对snapshot开启goroutine，很容易造成一种现象就是，</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2020/11/10/mit6-824-lab3/" data-id="cl0t1ddce00688slf6u3t4v9h" data-title="mit6.824-lab3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/distributed/" rel="tag">distributed</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/raft/" rel="tag">raft</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-经典算法-快慢指针" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/07/31/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" class="article-date">
  <time class="dt-published" datetime="2019-07-31T12:16:48.000Z" itemprop="datePublished">2019-07-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E5%AE%9D%E5%85%B8/">面试算法宝典</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/07/31/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/">经典算法-快慢指针</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>原题1:<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a><br>原题2:<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">42. 环形链表 II</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li><p>首先这里介绍一个快慢指针的奇淫巧计，专门用来检测链表是否有环。对于一个有序序列，设置两个指针，慢指针一次走1步，快指针一次走2步，那么如果快指针每次都多走一步，如果存在环的话就一定会追上慢指针。原题1就完全可以用这个解出来。</p>
</li>
<li><p>原题2的难度增加在，你除了要知道有没有环，还要知道是在第几个节点上形成的环。仔细思考一下，上面的算法在快慢指针相遇的时候可以得出什么结论？</p>
<ul>
<li>如果慢针走了n步，那么快针就走了2*n步；</li>
<li>快针会比慢针整整多走t圈环形链表。</li>
<li>因此2n-n就是环形链表的节点数；</li>
</ul>
</li>
</ul>
<h2 id="练练手"><a href="#练练手" class="headerlink" title="练练手"></a>练练手</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a> </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/byrhuangqiang/p/4708608.html">Leetcode解题思想总结篇：双指针</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2019/07/31/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" data-id="cl0t1dd0p003v8slf64tdfurz" data-title="经典算法-快慢指针" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algroithm/" rel="tag">Algroithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【leetcode】刷题笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/07/31/%E3%80%90leetcode%E3%80%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2019-07-31T09:11:28.000Z" itemprop="datePublished">2019-07-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E5%AE%9D%E5%85%B8/">面试算法宝典</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/07/31/%E3%80%90leetcode%E3%80%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/">【leetcode】刷题笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/158747775/">1. Two Sum</a>-98.73%</p>
<ul>
<li><p>暴力法很容易，但其实可以通过把数据存在哈希表里，或者二叉树的数据结构里，从而使得“找”这个操作更加快速。不需要像暴利法一样遍历所有的数据。</p>
</li>
<li><p>C++ stl里的map是一种红黑树，其找一个值的时间复杂度是O(logn)。而哈希表找一个值的时间复杂度是一个常数。会更快。但是这些都是牺牲空间复杂度来提高杂度。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/158746345/">13 Roman to integer</a> -24.45%</p>
<p>知识点：</p>
<ul>
<li>unordered_map的初始化方式</li>
<li>string可以直接用下标表示</li>
<li>s.back()表示返回stirng s的最后一个字符.</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flipping-an-image/description/">832. Flipping an Image</a>-无分布数据16ms</p>
<ul>
<li>思路就是对每一个vector的头尾进行比较分类，相同的直接各自取反。不相同的则不需要变化。<ul>
<li>一开始我直接对int取反，其实这是错误的。因为int不是一个bit，而是32个bit。取反后再转化成signed int的形式则会变成负数。所以不用按位取反，用逻辑否。</li>
<li><code>reverse(x.begin(),x.end())</code>可以达到反转vector的效果，但是这个处理方式并没有比我手工的快。</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/array-partition-i/description/">561. Array Partition I</a>-78.50%</p>
<ul>
<li>这个题的话其实仔细想一下就知道把序列排序一下，然后把偶数项加起来就可以获得最大的最小值之和。 但是的算法只是超过了70%多的人，也就是说还有更快的方法。<br>首先我们这里的排序是快排。然后循环一遍相加。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/toeplitz-matrix/description/">766. Toeplitz Matrix</a></p>
<ul>
<li><p>如果把这个矩阵看作的每一个看作（i，j）序列的话，就是要比较（i，j）与（i+1，j+1）……到（i+n,j+n)，这个n的边界就是看哪一个超过了这个输入向量的边界。 如果一个一个的看，一开始我直接很暴力的上三角，下三角来匹配。但这其实是人的思维。因为这样有两次for循环，性能不好。</p>
</li>
<li><p>再仔细观察，我其实不必每次都把整个斜线上的数都检查一遍，我可以每次两行两行的来，这样对数据的获取也容易一点。另外我观察到其实两行之间的比较就是第一行的前n-1个与第二行的第2到第n个之间的对比。根据<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container/vector/operator_cmp">这里</a>可知，两个vector是可以直接用&#x3D;&#x3D;来判断其元素是不是相等的。</p>
</li>
<li><p>std::bad_alloc’ what(): std::bad_alloc”错误。<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/23444844/c-error-terminate-called-after-throwing-an-instance-of-stdbad-alloc">stackoverflow</a>上说是因为你把一个本地变量的内存地址存储起来。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="type">int</span> m = matrix[i].<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">m1</span><span class="params">(matrix[i].begin(),matrix[i].end()<span class="number">-2</span>)</span></span>; <span class="comment">//当我把这里的额end()改成begin()的形式以后，就work了</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">m2</span><span class="params">(matrix[i+<span class="number">1</span>].begin()+<span class="number">1</span>,matrix[i+<span class="number">1</span>].end()<span class="number">-1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(m1!=m2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>  也就是</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="type">int</span> m = matrix[i].<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">m1</span><span class="params">(matrix[i].begin(),matrix[i].begin()+m<span class="number">-1</span>)</span></span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">m2</span><span class="params">(matrix[i+<span class="number">1</span>].begin()+<span class="number">1</span>,matrix[i+<span class="number">1</span>].begin()+m)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(m1!=m2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>其实这里并不是说end()不能用。而是当我们的的vector &lt;int&gt; 只有一个数的时候，end ()-2这样的表示是错误的。但是用begin()+m-1 就可以。</p>
</li>
<li><p>但是这样效率更低了。从超过55%降到超过37%。我想主要是新建vector m1和m2那里要复制数据（<strong>不确定是不是深拷贝，明天查。</strong>）花了时间。所以需要再改进。</p>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-integer/description/">7. reverse integer</a>-98.39%</p>
<p>知识点：</p>
<ul>
<li>INT_MAX 和INT_MIN表示int 的最大值和最小值,这是一个确定值.</li>
<li>%的符号。 一般来讲%在有些语言里是求模，有些语言里时求余。这两个操作有一点细微的差别,会根据语言和甚至编译器的不同而不同。</li>
</ul>
<blockquote>
<p>参考C++ primer 第5版里的说法：<br>对于除法来讲，一律向0取整； 对于%求余运算来讲，m%n的值与m同符号。和n的符号无关。只需要使得 ${m \over n} \times n+m%n&#x3D;m$</p>
</blockquote>
<p>更为细致一点的参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/solstice/article/details/5139302">带符号整数的除法与余数</a>。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-common-prefix/">14. Longest Common Prefix</a>-95.85%</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parentheses/">20 Valid Parentheses</a>-95.53%</p>
<ul>
<li>要利用栈的特性</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china">21. Merge Two Sorted Lists</a></p>
<ul>
<li>这里主要是联系链表的使用。一开始想在l1或者l2上直接变换，其实这样会比较复杂。在没有内存限制的情况下，可以另申请一个链表来存储。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-path-sum/description/">64. Minimum Path Sum</a></p>
<ul>
<li><p>一开始我的想法是从右下角往回推，但其实这是一种贪心算法，无法从全局来优化这个问题。做动态规划的时候子问题一定要代表着当前最优。</p>
</li>
<li><p>首先这里的矩阵长和高不一定相等，所以如果单纯的用一个变量比如dp(n)来表示minSum的话，有点不够。所以我们用dp(i,j)实际上就是一个二维数组来表示从(0，0)到(i，j)的minSum。</p>
</li>
<li><p>于是整个转换过程就很简单了：<br>$$<br>dp(i,j) &#x3D; min(dp(i-1,j),dp(i,j-1))+grid[i][j]<br>$$</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindromic-substrings/description/">647. Palindromic Substrings</a></p>
<ul>
<li>一开始我是这么想的，首先如果我们找到一个最长的回文，然后同时去掉两头，是不是又是一个新回文？所以如果我们知道了一个回文的长度是l，那么他就可以生成l&#x2F;2个新回文（因为我们默认每一个单独的字符都是一个回文，因此不考虑长度是奇数还是偶数）。所以问题转换为找不重叠的最长回文的个数以及其长度。但是这里有一个例外，比如我们找到一段回文是aaaaa，那么这个回文能生成的新回文数就不止2个了，而是9个。尽管我们可以分来来处理这两种情况，但应该还有更好的处理方式。</li>
<li>如果用dp的思想，那么我们就应该找子问题。当然最直接的想法是通过字符的长度来构造，比如dp(n-1)表示n-1个字符串的回文数。但是如何通过dp(n-1)来表示dp(n)呢？<br>显然很难，我们可以这么想，我如果要知道一个n个字符的字符串的回文数，我需要哪些信息？</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/array-partition-i/description/">561. Array Partition I</a>-78.50%</p>
<ul>
<li>这个题的话其实仔细想一下就知道把序列排序一下，然后把偶数项加起来就可以获得最大的最小值之和。 但是的算法只是超过了70%多的人，也就是说还有更快的方法。<br>首先我们这里的排序是快排。然后循环一遍相加。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/">167. Two Sum II - Input array is sorted</a></p>
<ul>
<li><p>首先我们要知道vector的 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/">查找</a> lower_bound会返回一个不小于某值的数。</p>
</li>
<li><p>思路很简单，就是找到小于target&#x2F;2.0的最大值，然后从两边开始加。大了就让左边的指针移一下，小了就让右边的指针移一下。</p>
</li>
<li><p>但是出现了一个错误：迭代器虽然我们知道本质是一种指针，但是它被封装成一个容器专属的数据类型，是不能直接赋值给独立的指针的。 </p>
</li>
<li><p>还有一个问题是，一开始我打算先找到大于target一半和小于target一般的部分，然后用两个指针来遍历。但是这样就有很多种情况要讨论，这其实就是不妥的。而且你考虑到这么分和用两个指针一个指头一个指尾的复杂度是差不多的。</p>
</li>
<li><p>比较这两种写法：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">1</span>, end = numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (numbers[start - <span class="number">1</span>] + numbers[end - <span class="number">1</span>] != target)&#123;</span><br><span class="line">            <span class="keyword">while</span> (numbers[start - <span class="number">1</span>] + numbers[end - <span class="number">1</span>] &gt; target) </span><br><span class="line">                end--;</span><br><span class="line">            <span class="keyword">while</span> (numbers[start - <span class="number">1</span>] + numbers[end - <span class="number">1</span>] &lt; target)  start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;start, end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>这一种要慢一点，因为每一次我们都要先判断numbers[start - 1] + numbers[end - 1] !&#x3D; target然后才进行下面的判断。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">1</span>, end = numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (numbers[start - <span class="number">1</span>] + numbers[end - <span class="number">1</span>] != target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[start - <span class="number">1</span>] + numbers[end - <span class="number">1</span>] &gt; target) </span><br><span class="line">                end--;</span><br><span class="line">            <span class="keyword">else</span>  start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;start, end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">3. Longest Substring Without Repeating Characters</a> </p>
</li>
<li><p>这个题思路其实很简单，就是遍历string s，然后往回找有没有出现过，出现过了就先把当前的substring长度记下来，再把substring的起始更新为第一次出现的位置后面那个字符。继续遍历。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sqrtx/description/">69. Sqrt(x)</a></p>
<ul>
<li>首先要注意的是<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11466.html">整型溢出</a>。最好的注意方法是不要用乘法用除法。</li>
<li>另一个就是<a target="_blank" rel="noopener" href="http://www.cnblogs.com/grandyang/p/6854825.html">二分查找法的应用</a>，一定要注意的是二分查找法的前提是有序。</li>
<li>还有一种方法是<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20690553">牛顿方法</a>，虽然它的前提要求是开始循环的点要接近所求值，但是在求平方根时是无所谓的。</li>
<li>但在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division">求整数根值</a>的时候，初始点是从最大的来。才会有$x_n -x_{n+1}&#x3D;1$。很奇怪。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/">744. Find Smallest Letter Greater Than Target</a></p>
<ul>
<li>这个的话用二分法一开始我是这样的：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l=<span class="number">0</span>,r=letters.<span class="built_in">size</span>(),m;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        m=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(letters[m]&gt;target) r= m<span class="number">-1</span>;  <span class="comment">//注意这一条 </span></span><br><span class="line">        <span class="keyword">else</span> l=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> letters[r];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这样子最后返回的是r所指向的位置，而经过上面的while可以保证此时的r+1所指向的位置是大于target的。但是有一个问题是r所指向的位置却不能保证是不是大于target的。比如考虑一个test：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;c&quot;</span><br><span class="line">Output: &quot;f&quot;</span><br></pre></td></tr></table></figure></li>
<li>但是这里的输出就不是“f”,而是“c”。我们要返回的要保证大于target，其次再保证是最小的。因此我们应该在if语句那里调整一下。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/description/">5. Longest Palindromic Substring</a></p>
<ul>
<li>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaoli_nu/article/details/76694843">求区间中1的个数最多的数 若有多个输出最小的</a><br>有时候要反过来想，抓住能够固定的条件。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-all-duplicates-in-an-array/description/">442. Find All Duplicates in an Array</a></p>
<ul>
<li>这道题有一个特征可以利用的是1&lt;a[i]&lt;&#x3D;n(n&#x3D;size of array)。也就是说一个长为5的数组，其最大的值为5，最小的值为1。且都为正整数。</li>
<li>可以利用这一特征，然后让nums[i]里的值当作nums的下表。如果有同样的值则会只想到nums里的同一个数，而第一次指向则改为负数，第二次指向的时候就是出现了重复值的时候，此时指向的值是负数。这个只需127ms。</li>
<li>但我之前的思路是，一边遍历一边把数字放到hash_map<br>里去，然后一边检查hash map里有没有，一边加入。虽然hash map的find理论上只需要常数的时间，但比起前一种方法的比较大小，还是会要多费出时间。需要165ms。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets/description/">78. Subsets</a></p>
<ul>
<li>这个题一开始出现一个memory  limited 的错误。这个错误其实很容易犯，就是在对vector做循环遍历的时候，在for的逻辑结构里我对这个vector又有了增加，于是导致那个循环条件i&lt;subset.size()一直出不去。从而一直在加。</li>
<li>这个题的思路其实很简单，就是遇到一个数，我们就把这个数的先作为子集添加进去。然后对于每一个已经在子集里的vector都添加这个数，然后构成的新子集也添加进去。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-matching-subsequences/description/">792. Number of Matching Subsequences</a></p>
<ul>
<li><p>这个用暴力法肯定无法解决。查看讨论后得到一个非常巧妙的方法。主要是利用string用c_str这个转换成char数组后，最后一个元素是0。</p>
</li>
<li><p>有一个<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18481740/pointer-expressions-ptr-ptr-and-ptr">知识点</a>是++和*，*++p–*(++p)首先，++和*是同一个优先级，于是我们看结合性。都是从右到左，也就是都先和左边的结合，于是先++和p结合，然后*和++p结合。</p>
</li>
<li><p>我们可以构造出一个字典索引从a到b开头，把字典里的每一个string变成char数组放进去。然后把它看成是一个未与所求string S匹配的目录。然后一个个地遍历S的字符，从索引开始，遇到匹配的这个字符，就把这个char数组匹配的那个去掉，重新放入新的索引下。于是匹配到最后，如果都匹配完了，那么最终肯定会被放到0对应的索引下的。因为，string转char 数组最后一个字符的值是0。 </p>
</li>
<li><p>这个是代码：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numMatchingSubseq</span><span class="params">(string S, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; index[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;w:words)&#123; </span><br><span class="line">            index[w[<span class="number">0</span>]].<span class="built_in">push_back</span>(w.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; s:S)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(index[s].<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> i:index[s])&#123;</span><br><span class="line">                    index[*++i].<span class="built_in">push_back</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//index[s].clear(); 加上这个就没有runtime error了，但是算出来的结果是错的。显然逻辑上要清除这个索引，因为我们已经比较完了。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> index[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>参考答案发现要把index[s].clear() 放在index[*++i].push_back(i);的前面，因为有可能有一个词语是aaaa，那么它刚刚加入又被清除了。所以就有错误。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/assign-cookies/description/">455. Assign Cookies</a></p>
<ul>
<li>这个没什么要说的。主要是了解到一个sort的用法，它默认是按从小到大排序，如果想要从大到小，就用greater<int>作为第三个参数。事实上这个参数是一个函数模板，可以用来决定两个object哪一个比较大。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/min-cost-climbing-stairs/description/">746. Min Cost Climbing Stairs</a></p>
<ul>
<li><p>首先要搞清一个题意就是，对于包含n个cost的序列，我们最后的落脚点只能是在cost[n-1]和cost[n-1]，也就是倒数第一个和倒数第二个。倒数第三个是不行的。</p>
</li>
<li><p>看起来似乎是每次往后check两个直，并选择小的那一个就行了。但考虑一种情况[1,2,9,1],首先我们考虑1和2，选择1，然后选择2，然后选择1，最后的结果是4.但是如果我们一开始在1和2中选择2，然后就选择1，那么结果是3. </p>
</li>
<li><p>如果我们从后往前推呢？实质是一样的。因此我们这里无法用贪心算法。要从全局来看就要用到DP。</p>
<ul>
<li><p>首先思考，一个n长的cost序列，我们遍历到下标n-1，或者n-2都可以看作是结束的标志，我们只需要比较这两种遍历哪一种cost最小。而这个问题的子问题就是，一个n-1长的cost序列，我们遍历到下标n-2，或者n-3都可以看作是结束的标志……。</p>
</li>
<li><p>于是不难想到，如果及L(n)为n长的cost序列的最小cost和，我们能不能构建一个状态转移函数？还有一些变数，那么我们假设DP(n)为在一个包含n个cost的序列里以最后一个作为最后的落脚点的方案所能达到的最小和。那么<br>  $$<br>  \begin{align*}<br>  &amp;DP(0)&#x3D;cost[0] \\<br>  &amp;DP(1)&#x3D;cost[1] \\<br>  &amp;DP(n) &#x3D; cost[n] +min(DP(n-1), DP(n-2))<br>  \end{align*}<br>  $$</p>
</li>
<li><p>因为cost[n]是一定要选的，然后再来看到底是从n-1跳，还是从n-2跳。</p>
</li>
</ul>
</li>
<li><p>总结一下，就是：</p>
<ol>
<li>首先要知道这是一个全局最优，那么就不能用贪心算法</li>
<li>然后要巧妙地设置好状态，这样才能把状态转移函数写得简单。最重要的就是要固定住一些变量，比如这一题里，我们就不是简单的用L(n)而是用的DP(n)就把最后的落脚点固定住了，方便后面的分析。</li>
<li>固定住变量以后，需要在最前面的初始化里体现。也就是这题里的dp[0]和dp[1].</li>
</ol>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/climbing-stairs/description/">70. Climbing Stairs</a></p>
<ul>
<li><p>这一题我们同样可以用DP，比如假设DP(n)表示上n层楼梯拥有的方法数。那么DP(n+1)就可以用DP(n)来表示,但是显然我们的某些情况还是没有固定，比如最后一步是1 step和2 step会影响到我们的推导。因此我们通过设置DP1(n)和DP2(n)来表示，前者表示n层楼里，最后一步是1 step的方法数，后者表示最后一步是2 step的方法数。那么推导就好进行了。</p>
<p>  $$<br>  \begin{align*}<br>  &amp;DP_0(n) &#x3D; DP_1(n)+DP_2(n) \\<br>  &amp;DP_1(n) &#x3D; DP_1(n-1)+DP_2(n-1) \\<br>  &amp;DP_2(n) &#x3D; DP_1(n-2)+DP_2(n-2)<br>  \end{align*}<br>  $$</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/range-sum-query-immutable/description/">303. Range Sum Query - Immutable</a></p>
<ul>
<li><p>第一个想法是通过建一个表来代替频繁的计算，用内存换时间。于是NumArray初始化的时候就可以建一个二维数组 sum[i][j]就表示从i到j的和，然后在sumRange这个方法里就只需要返回这个二维数组的某个值就好。</p>
</li>
<li><p>用vector创建二维数组的方式是：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sum = <span class="keyword">new</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(len,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是这样其实非常的繁琐，需要用到3个for。仔细想你会发现如果我用一个一维数组sum[I]表示从i开始到最后的累加和。那么从I到j的累加和就是sum[i]-sum[j]了。</p>
</li>
<li><p>要注意，一个空的vector无法用下标的方式扩充vector。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/">122. Best Time to Buy and Sell Stock II</a></p>
<ul>
<li>这就是一个贪心算法，看起来好似很多种情况要考虑。但其实我们只需要把当天买和第二天买的差价大于0的利润全加起来就是能赚到的总和。就是一个贪心算法。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lemonade-change/description/">860. Lemonade Change</a></p>
<ul>
<li>这里要注意的就是20的找零，优先使用10块。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-anagram/description/">242. Valid Anagram</a></p>
<ul>
<li>一个往dict里添，一个往dict里拿，如果只是顺序重排，最后dict应该是没有变动。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-1-bits/description/">191. Number of 1 Bits</a></p>
<ul>
<li>最简单的就是循环，然后将n一位一位地右移。 但是还有一种骚操作——<a target="_blank" rel="noopener" href="http://6460646.blog.163.com/blog/static/27779875201132893614412/">n&amp;(n-1)的妙用</a>  </li>
<li>其实就是把二进制数第一个不为0的那一位变为0，后面的位都变为1。然后做一个与运算的话，就把第一位不为0的改成了0.那么在判断的时候就不需要一个个地遍历了，只需要遍历1的个数的次数。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/power-of-three/description/">326. Power of Three</a></p>
<ul>
<li>可以简单地循环，但是有一个<a target="_blank" rel="noopener" href="http://www.aichengxu.com/other/2460321.htm">数学知识</a>可以快速解决它。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/counting-bits/description/">338. Counting Bits</a></p>
<ul>
<li><p>首先很容易想到的是，后一个状态是可以根据前一个状态得到的。从偶数+1变成奇数后的#（1）一定会加1，而奇数+1变成偶数就有一点麻烦。它会把第一个不是1的位的后面的1都变成0，而这个第一个不是1的位变成1.前面的1我们不会变，那么我们的任务其实就是数这个奇数第一个不为1的位后面有几个1以及前面有几个1.</p>
</li>
<li><p>但是这依然很麻烦，不如先写几个看一下规则，假设dp(n)表示数字n的二进制包含的1的个数。那么<br>$$<br>\begin{align*}<br>&amp;dp(0) &#x3D; 0  \\<br>&amp;dp(1) &#x3D; 1   \\<br>&amp;dp(2) &#x3D; 1 &#x3D; dp(2-0)+1 \\<br>&amp;dp(3) &#x3D; 2 &#x3D; dp(3-2)+1 \\<br>&amp;dp(4) &#x3D; 1   \\<br>&amp;dp(5) &#x3D; 2 &#x3D; dp(5-4)+1 \\<br>&amp;dp(6) &#x3D; 2 &#x3D; dp(6-4)+1 \\<br>&amp;dp(7) &#x3D; 3 &#x3D; dp(7-4)+1 \\<br>&amp;dp(8) &#x3D; 1 \\<br>&amp;dp(9) &#x3D; 2 &#x3D; dp(9-8)+1  \\<br>……<br>\end{align*}<br>$$</p>
</li>
<li><p>那么规则就出现了。为什么是这样呢? 首先那个+1其实是对应的$dp(2_i)$的值，因为它总是1，所以我们直接+1了。</p>
</li>
<li><p>所以规律是$dp(n) &#x3D; dp(n-2_i)+dp(2_i)$.把$2_i$作为起始点，因为它总是以一个1后面跟若干个0结尾。那么往上加1的话，它的1的个数就很好推断。仔细体会。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/power-of-four/description/">342. Power of Four</a></p>
<ul>
<li><p>4的n次方可以看作是n个4的相乘，而一个数乘以4相当于往左移2位（乘以2是往左移1位，以此类推）。</p>
</li>
<li><p>所以只需要检查当前数的二进制只有一个1，并且在其奇数位上。</p>
</li>
<li><p>由于int是32位,0101010101010101010101010101写成16进制是0x55555555</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (num&gt;<span class="number">0</span>) &amp;&amp;((num&amp;(num<span class="number">-1</span>))==<span class="number">0</span>)&amp;&amp;((num&amp;<span class="number">0x55555555</span>)==num);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">121. Best Time to Buy and Sell Stock</a></p>
<ul>
<li><p>这里的优秀解法<a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39038/Kadane's-Algorithm-Since-no-one-has-mentioned-about-this-so-far-:">参考</a> 也就是把这个题转变成了一个求子串最大和的问题。</p>
</li>
<li><p>首先要理解这个公式： $maxSum(i) &#x3D; max(maxSum(i-1)+[i],[i])$。只能是这两个值之间的一个，因为紫川要是连续的，也就是说如果不能把[i]纳入maxSum里，那么就要重新开始计maxSum。</p>
</li>
<li><p>然后这样遍历一次最后得到的还不是真正的max，真正的max应该是从前面的各种maxSum里选一个最大的。</p>
</li>
<li><p>还有一个问题是，在这个题里，maxSum要大于0。为什么要这么设置是因为，我们可以通过一个子串也不选来达到最大的子串和。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/description/">53. Maximum Subarray</a></p>
<ul>
<li><p>这个套路差不多，但是这里有一个不同是，这里必须至少包含一个元素。也就是说如果都是负数，那么maxSum的返回值也会是负数。</p>
</li>
<li><p>还有一种方法是分而治之的方法：首先我们分析，最大和的子串能出现在哪：</p>
<ol>
<li>前半部分</li>
<li>后半部分</li>
<li>跨越中间部分</li>
</ol>
</li>
<li><p>那么我们只需要找到这这三者的最大子串和的最大值就是整个子串的最大值。</p>
</li>
<li><p>前半部分和后半部分就是递归，暂且不管。看一下横跨中间的那部分。那么很显然，要横跨，就必须把最中间的值写入。然后往左边遍历，一直在中间累加，直到出现最大。这里的二分法的迭代要注意要有结束条件。也就是当len&#x3D;0，后者len&#x3D;1 的时候要能直接返回一个值而不是继续递归。因为我们的递归是针对len&gt;1 的情况来说的。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-arrays/discuss/139344/C++-2ms">349. Intersection of Two Arrays</a></p>
<ul>
<li>首先介绍一个数据结构unordered_set。它保存所有不同的值，但是不保证顺序。因为它内部也是一个hashtable。只不过它的值就是它的key。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">26. Remove Duplicates from Sorted Array</a></p>
<ul>
<li>这个题很trick， 要明白cur下标和next下标的含义。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2019/07/31/%E3%80%90leetcode%E3%80%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" data-id="cl0t1dcyk00158slf2aqb1j8m" data-title="【leetcode】刷题笔记" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algroithm/" rel="tag">Algroithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mit6-824/">mit6.824</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/quant%E9%9D%A2%E8%AF%95%E7%BA%A2%E5%AE%9D%E4%B9%A6/">quant面试红宝书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">数据结构笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E5%AE%9D%E5%85%B8/">面试算法宝典</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APUE/" rel="tag">APUE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algroithm/" rel="tag">Algroithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/I-O/" rel="tag">I&#x2F;O</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pprof/" rel="tag">Pprof</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test/" rel="tag">Test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/" rel="tag">code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/distributed/" rel="tag">distributed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gc/" rel="tag">gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lock-free/" rel="tag">lock-free</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quant-interview/" rel="tag">quant interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raft/" rel="tag">raft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ucore/" rel="tag">ucore</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/APUE/" style="font-size: 10px;">APUE</a> <a href="/tags/Algroithm/" style="font-size: 18.57px;">Algroithm</a> <a href="/tags/CSAPP/" style="font-size: 20px;">CSAPP</a> <a href="/tags/Golang/" style="font-size: 17.14px;">Golang</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/I-O/" style="font-size: 10px;">I/O</a> <a href="/tags/Leetcode/" style="font-size: 18.57px;">Leetcode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a> <a href="/tags/OS/" style="font-size: 15.71px;">OS</a> <a href="/tags/Pprof/" style="font-size: 10px;">Pprof</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/code/" style="font-size: 10px;">code</a> <a href="/tags/distributed/" style="font-size: 11.43px;">distributed</a> <a href="/tags/gc/" style="font-size: 10px;">gc</a> <a href="/tags/golang/" style="font-size: 12.86px;">golang</a> <a href="/tags/k8s/" style="font-size: 10px;">k8s</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/lock-free/" style="font-size: 10px;">lock-free</a> <a href="/tags/quant-interview/" style="font-size: 14.29px;">quant interview</a> <a href="/tags/raft/" style="font-size: 12.86px;">raft</a> <a href="/tags/ucore/" style="font-size: 17.14px;">ucore</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 12.86px;">双指针</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18.57px;">算法</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 11.43px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/26/Prometheus-Histograms-Observation%E7%9A%84%E6%97%A0%E9%94%81%E5%AE%9E%E7%8E%B0/">Prometheus笔记</a>
          </li>
        
          <li>
            <a href="/2021/08/09/k8s%E5%AE%9E%E6%93%8D%E7%AC%94%E8%AE%B0/">k8s实操笔记</a>
          </li>
        
          <li>
            <a href="/2021/07/16/golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">golang垃圾回收</a>
          </li>
        
          <li>
            <a href="/2021/06/03/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%A4%87%E5%BF%98%E5%BD%95/">golang测试备忘录</a>
          </li>
        
          <li>
            <a href="/2021/05/02/defer%E8%AF%A6%E8%A7%A3/">defer详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Husy<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>