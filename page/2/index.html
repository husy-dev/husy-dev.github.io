<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Husy">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-golang反射详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/golang%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T10:28:04.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/golang%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3/">golang反射详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    描述一个变量无非是从type和value下手，分别对应reflect的TypeOf和ValueOf接口。前者返回一个Type接口变量（其真正实现是rtype），后者返回一个Value结构体对象。这两个对象分别都有很多方法，要注意的是不是每一个类型都可以调用所有方法，用的时候可以看看接口的注释，看某些方法是针对某些类型的。</p>
<p>对变量type的描述则用rtype来定义，其中那个kind的后五位（因为一共定义了27个类型）则用来描述基本类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> rtype <span class="keyword">struct</span> &#123;</span><br><span class="line">	size       <span class="type">uintptr</span></span><br><span class="line">	ptrdata    <span class="type">uintptr</span>  <span class="comment">// number of bytes in the type that can contain pointers</span></span><br><span class="line">	hash       <span class="type">uint32</span>   <span class="comment">// hash of type; avoids computation in hash tables</span></span><br><span class="line">	tflag      tflag    <span class="comment">// extra type information flags</span></span><br><span class="line">	align      <span class="type">uint8</span>    <span class="comment">// alignment of variable with this type</span></span><br><span class="line">	fieldAlign <span class="type">uint8</span>    <span class="comment">// alignment of struct field with this type</span></span><br><span class="line">	kind       <span class="type">uint8</span>    <span class="comment">// enumeration for C</span></span><br><span class="line">	alg        *typeAlg <span class="comment">// algorithm table</span></span><br><span class="line">	gcdata     *<span class="type">byte</span>    <span class="comment">// garbage collection data</span></span><br><span class="line">	str        nameOff  <span class="comment">// string form</span></span><br><span class="line">	ptrToThis  typeOff  <span class="comment">// type for pointer to this type, may be zero</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reflect包定义了最基本的类型，并将类型的类型（有点拗口）定义为Kind。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Kind <span class="type">uint</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Invalid Kind = <span class="literal">iota</span></span><br><span class="line">	Bool</span><br><span class="line">	Int</span><br><span class="line">	Int8</span><br><span class="line">	Int16</span><br><span class="line">	Int32</span><br><span class="line">	Int64</span><br><span class="line">	Uint</span><br><span class="line">	Uint8</span><br><span class="line">	Uint16</span><br><span class="line">	Uint32</span><br><span class="line">	Uint64</span><br><span class="line">	Uintptr</span><br><span class="line">	Float32</span><br><span class="line">	Float64</span><br><span class="line">	Complex64</span><br><span class="line">	Complex128</span><br><span class="line">	Array</span><br><span class="line">	Chan</span><br><span class="line">	Func</span><br><span class="line">	Interface</span><br><span class="line">	Map</span><br><span class="line">	Ptr</span><br><span class="line">	Slice</span><br><span class="line">	String</span><br><span class="line">	Struct</span><br><span class="line">	UnsafePointer</span><br><span class="line">)	</span><br></pre></td></tr></table></figure>

<h2 id="函数的反射"><a href="#函数的反射" class="headerlink" title="函数的反射"></a>函数的反射</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013532622">go rpc 源码分析</a>，rpc的调用就使用了反射机制。</p>
<h2 id="三大定理"><a href="#三大定理" class="headerlink" title="三大定理"></a>三大定理</h2><p><a target="_blank" rel="noopener" href="https://blog.golang.org/laws-of-reflection">The Laws of Reflection</a> 前两条讲的是interface{}和其反射对象的相互转化，第三条比较重要。当我们用ValueOf获取到的反射对象来修改原来变量的值的时候，需要首先将变量的指针作为参数传入，然后要用到Elem()方法获取到变量的值，才能够修改。原因可以看看参考的原文。</p>
<h3 id="尽量少使用"><a href="#尽量少使用" class="headerlink" title="尽量少使用"></a>尽量少使用</h3><p>原因一是使用不当就很可能panic；原因二是性能非常低。拿利用反射调用函数来说，其性能大概慢了将近1800倍（8核 16GB）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/07/golang%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3/" data-id="cl0t1dd0y004f8slfgt7o1j7g" data-title="golang反射详解" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-linux环境开发备忘录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/02/linux%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2021-04-02T09:01:28.703Z" itemprop="datePublished">2021-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/02/linux%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98%E5%BD%95/">linux环境开发备忘录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="linux环境开发备忘录"><a href="#linux环境开发备忘录" class="headerlink" title="linux环境开发备忘录"></a>linux环境开发备忘录</h1><h2 id="linux基本命令"><a href="#linux基本命令" class="headerlink" title="linux基本命令"></a>linux基本命令</h2><h3 id="Shell语法"><a href="#Shell语法" class="headerlink" title="Shell语法"></a>Shell语法</h3><ol>
<li>最开头需要添加<code>*#!/bin/bash*</code>。</li>
<li>变量的定义是<code>your_name=“runoob.com”</code>，不要有空格。用双引号可以解析变量，单引号则原封不动地输出。</li>
<li>使用变量用${parm}</li>
<li>预置变量</li>
</ol>
<table>
<thead>
<tr>
<th align="center">参数处理</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$#</td>
<td align="center">传递到脚本的参数个数,包括命令本身，其变量为$0</td>
</tr>
<tr>
<td align="center">$*</td>
<td align="center">以一个单字符串显示所有向脚本传递的参数,以”$1 $2 … $n”的形式输出所有参数。</td>
</tr>
<tr>
<td align="center">$$</td>
<td align="center">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td align="center">$!</td>
<td align="center">后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td align="center">$@</td>
<td align="center">与$*相同，但是以“$1”  “$2” … “$n”的形式将所有参数分开成多个字符串输出。</td>
</tr>
<tr>
<td align="center">$?</td>
<td align="center">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
<tr>
<td align="center">5. 使用$(command)来获取执行命令后的结果作为代码。</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol>
<li><code>wc -l &#123;文件名&#125;</code>是用来查看文件的newline的数量的。在linux系统中，newline字符就是 \n 字符。</li>
<li>查找字符串，其中搜寻字符串支持正则匹配式，注意为了避免shell的元字符对正则表达式的影响，请用单引号（’’）括起来，千万不要用双引号括起来（””）或者不括起来。</li>
</ol>
<blockquote>
<p>grep [-acinv] [–color&#x3D;auto] [-A n] [-B n] ‘搜寻字符串’ 文件名<br>参数说明：<br>-a：将二进制文档以文本方式处理<br>-c：显示匹配次数<br>-i：忽略大小写差异<br>-n：在行首显示行号<br>-A：After的意思，显示匹配字符串后n行的数据<br>-B：before的意思，显示匹配字符串前n行的数据<br>-v：显示没有匹配行<br>-A：After的意思，显示匹配部分之后n行<br>-B：before的意思，显示匹配部分之前n行<br>–color：以特定颜色高亮显示匹配关键字</p>
</blockquote>
<table>
<thead>
<tr>
<th>元数据</th>
<th>意义和范例</th>
</tr>
</thead>
<tbody><tr>
<td>^word</td>
<td>搜寻以word开头的行。 例如：搜寻以#开头的脚本注释行 grep –n ‘^#’ regular.txt word$    搜寻以word结束的行</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意一个字符。 例如：grep –n ‘e.e’ regular.txt 匹配e和e之间有任意一个字符，可以匹配eee，eae，eve，但是不匹配ee。</td>
</tr>
<tr>
<td>\</td>
<td>转义字符。 例如：搜寻’，’是一个特殊字符，在正则表达式中有特殊含义。必须要先转义。grep –n ‘,” regular.txt</td>
</tr>
<tr>
<td>*</td>
<td>前面的字符重复0到多次。 例如匹配gle，gogle，google，gooogle等等 grep –n ‘go*gle’ regular.txt</td>
</tr>
<tr>
<td>[list]</td>
<td>匹配一系列字符中的一个。 例如：匹配gl，gf。grep –n ‘g[lf]’ regular.txt</td>
</tr>
<tr>
<td>[n1-n2]</td>
<td>匹配一个字符范围中的一个字符。 例如：匹配数字字符 grep –n ‘[0-9]’ regular.txt</td>
</tr>
<tr>
<td>[^list]</td>
<td>匹配字符集以外的字符 例如：grep –n ‘[^o]‘ regular.txt 匹配非o字符</td>
</tr>
</tbody></table>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><h2 id="IO过程"><a href="#IO过程" class="headerlink" title="IO过程"></a>IO过程</h2><h3 id="1-1-iotop"><a href="#1-1-iotop" class="headerlink" title="1.1 iotop"></a>1.1 iotop</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Total DISK READ :       0.00 B/s | Total DISK WRITE :       0.00 B/s</span><br><span class="line">Actual DISK READ:       0.00 B/s | Actual DISK WRITE:      19.68 K/s</span><br><span class="line">  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND                                                                                                                          </span><br><span class="line">27159 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.01 % [kworker/4:1]</span><br><span class="line"> 2847 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % containerd</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure>

<ol>
<li>TID可以理解为线程ID，在linux下线程和进程是同等调度的。</li>
<li>PRIO是io的优先级，具体可以看看man ionice。只有io调度队列为cfq，才会有这些优先级的概念。</li>
</ol>
<h3 id="1-2-iostat"><a href="#1-2-iostat" class="headerlink" title="1.2 iostat"></a>1.2 iostat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ iostat -x 1</span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.38    0.00    0.15    0.01    0.00   99.47</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">vda               0.00     2.61    0.03    1.90     0.83    57.89    61.06     0.01    4.03    5.54    4.01   0.43   0.08</span><br><span class="line">vdb               0.00     0.10    0.00    0.10     0.00     0.80    16.00     0.00    0.13    0.56    0.13   0.10   0.00</span><br><span class="line">scd0              0.00     0.00    0.00    0.00     0.00     0.00     7.23     0.00    0.27    0.27    0.00   0.27   0.00</span><br></pre></td></tr></table></figure>

<ol>
<li>iowait和%util是比较关键的，vad，vdb代表了磁盘。avgrq-sz表示对io的请求大小（多少个扇区），avgqu-sz是io队列的长度。具体都可以man iostat看，比较好理解。</li>
<li>%util的值可以衡量当前io的使用率但可能存在误差，比如raid的磁盘阵列，比如向三块磁盘写数据，实际上是同时写到三个磁盘上去的，这样能提高效率，但是%util一般指表示一个磁盘的io占用率。</li>
</ol>
<h3 id="1-3-sar"><a href="#1-3-sar" class="headerlink" title="1.3 sar"></a>1.3 sar</h3><p>这是linux下的一个瑞士军刀，但没什么新鲜的信息。</p>
<h3 id="1-4-lsof"><a href="#1-4-lsof" class="headerlink" title="1.4 lsof"></a>1.4 lsof</h3><p>一直只用<code>lsof -i:&lt;port&gt;</code>，但其实lsof是list open file的缩写，它会展示所有打开的文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ lsof -p $$</span><br><span class="line">COMMAND  PID USER   FD   TYPE DEVICE  SIZE/OFF  NODE NAME</span><br><span class="line">zsh     5447 root  cwd    DIR  252,1      4096 52566 /root</span><br><span class="line">zsh     5447 root  rtd    DIR  252,1      4096     2 /</span><br><span class="line">zsh     5447 root  txt    REG  252,1    736312 51229 /usr/bin/zsh</span><br><span class="line">zsh     5447 root  mem    REG  252,1     70248 51238 /usr/lib64/zsh/5.0.2/zsh/computil.so</span><br><span class="line">......</span><br><span class="line">zsh     5447 root    0u   CHR  136,0       0t0     3 /dev/pts/0</span><br><span class="line">zsh     5447 root    1u   CHR  136,0       0t0     3 /dev/pts/0</span><br><span class="line">zsh     5447 root    2u   CHR  136,0       0t0     3 /dev/pts/0</span><br><span class="line">zsh     5447 root   10u   CHR  136,0       0t0     3 /dev/pts/0</span><br></pre></td></tr></table></figure>

<ol>
<li>FD的具体含义可以</li>
</ol>
<h2 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h2><h3 id="2-1-free"><a href="#2-1-free" class="headerlink" title="2.1 free"></a>2.1 free</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          15714        2178        3221         305       10315       13121</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure>

<p>别的不多说，主要说一下buff&#x2F;cacheh。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fanren224/article/details/89455109">内存free命令的含义 buffers和cache</a>里和man free里的说法是buff是块设备的内存，cache是普通文件和slab的内存。</p>
<h3 id="vmstate"><a href="#vmstate" class="headerlink" title="vmstate"></a>vmstate</h3><h2 id="3-网络"><a href="#3-网络" class="headerlink" title="3. 网络"></a>3. 网络</h2><h3 id="3-1-ping"><a href="#3-1-ping" class="headerlink" title="3.1 ping"></a>3.1 ping</h3><p>原理是利用网络协议网络层的ICMP协议，来确认网络是否可达。它没有单独的网络包结构，是嵌入IP包里的。具体可以参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaolincoding/p/12571184.html">20 张图解： ping 的工作原理</a></p>
<h3 id="3-2-ncat-x2F-nc"><a href="#3-2-ncat-x2F-nc" class="headerlink" title="3.2 ncat&#x2F;nc"></a>3.2 ncat&#x2F;nc</h3><p>是一整套网络工具，用于做一些简单的测试。</p>
<h3 id="3-3-netstat"><a href="#3-3-netstat" class="headerlink" title="3.3 netstat"></a>3.3 netstat</h3><p>用于监控网络出入包等情况。可以参考<a target="_blank" rel="noopener" href="https://www.howtogeek.com/513003/how-to-use-netstat-on-linux/">How to Use netstat on Linux</a>和<a target="_blank" rel="noopener" href="https://www.tecmint.com/20-netstat-commands-for-linux-network-management/">20 Netstat Commands for Linux Network Management</a></p>
<h2 id="linux基础"><a href="#linux基础" class="headerlink" title="linux基础"></a>linux基础</h2><h3 id="x2F-bin-x2F-sbin-x2F-usr-x2F-sbin-x2F-usr-x2F-bin-目录的区别"><a href="#x2F-bin-x2F-sbin-x2F-usr-x2F-sbin-x2F-usr-x2F-bin-目录的区别" class="headerlink" title="&#x2F;bin,&#x2F;sbin,&#x2F;usr&#x2F;sbin,&#x2F;usr&#x2F;bin 目录的区别"></a>&#x2F;bin,&#x2F;sbin,&#x2F;usr&#x2F;sbin,&#x2F;usr&#x2F;bin 目录的区别</h3><blockquote>
<p>/bin 是系统的一些指令。bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。<br> /sbin 一般是指超级用户指令。主要放置一些系统管理的必备程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。<br> /usr/bin 是你在后期安装的一些软件的运行脚本。主要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb、wget等。<br> /usr/sbin 放置一些用户安装的系统管理的必备程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等。</p>
</blockquote>
<h2 id="开发环境配置问题"><a href="#开发环境配置问题" class="headerlink" title="开发环境配置问题"></a>开发环境配置问题</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34024112">yum install的版本会落后很多，Linux 下安装python制定版本</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/778416">让Curl支持HTTP 2.0</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ohmyzsh/ohmyzsh/issues/8038">zsh终端配置失败 source ~&#x2F;.zshrc error #8038</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a20964b88f98">Mac 上 npm 升级</a></p>
<h3 id="vscode配置"><a href="#vscode配置" class="headerlink" title="vscode配置"></a>vscode配置</h3><ol>
<li><code>Error loading workspace: unsupported version of go</code> 一般是安装的一些tools和go的版本不一致，ctrl+shift+p调出控制命令框，然后Go install&#x2F;update Tools。参考<a target="_blank" rel="noopener" href="https://github.com/microsoft/vscode-go/issues/3092">After upgrade every time I open VS Code I get a <code>Error loading workspace folders</code></a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/02/linux%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98%E5%BD%95/" data-id="cl0t1ddca005g8slffadi1p2b" data-title="linux环境开发备忘录" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/code/" rel="tag">code</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-GMP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/02/GMP/" class="article-date">
  <time class="dt-published" datetime="2021-04-02T06:46:41.000Z" itemprop="datePublished">2021-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/02/GMP/">goroutine详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-Goroutine的堆栈输出说明"><a href="#1-Goroutine的堆栈输出说明" class="headerlink" title="1. Goroutine的堆栈输出说明"></a>1. Goroutine的堆栈输出说明</h2><p><img src="/Users/husyhu/Library/Mobile%20Documents/com~apple~CloudDocs/husy1994.github.io/source/_posts/image-20210324142746220.png" alt="image-20210324142746220"></p>
<p>​    大部分都很容易理解，主要是说明一下其中红色框框里的数据是什么。参考<a target="_blank" rel="noopener" href="https://www.joeshaw.org/understanding-go-panic-output/">Understanding Go panic output</a>和<a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2015/01/stack-traces-in-go.html">Stack Traces In Go</a> 主要结论如下：</p>
<ol>
<li>如果是一个有接收者的函数调用，先是接收者的一个数据打印；</li>
<li>然后以此是从左到右的参数的结构打印。</li>
<li>最后是返回值的结构打印。</li>
<li>最多打印十个字段，多了的就截断了。</li>
</ol>
<p>​    要注意的是，不同类型的数据打印的数量和方式不一样。比如int类型就是一个简单的十六进制数字，就是其值本身。而string类型要打印两个字段，第一个是该字段长度，第二个是指向字符串的指针。等等，这些可以去查看具体的类型定义来查看。</p>
<p>​    另外，<code>groutine 1[chan receive]</code>里的chan receive是一系列枚举值，在go语言里的类型为waitReason，用于描述goroutine挂起的原因。具体的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitReason <span class="type">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	waitReasonZero                  waitReason = <span class="literal">iota</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line">	waitReasonGCAssistMarking                         <span class="comment">// &quot;GC assist marking&quot;</span></span><br><span class="line">	waitReasonIOWait                                  <span class="comment">// &quot;IO wait&quot;</span></span><br><span class="line">	waitReasonChanReceiveNilChan                      <span class="comment">// &quot;chan receive (nil chan)&quot;</span></span><br><span class="line">	waitReasonChanSendNilChan                         <span class="comment">// &quot;chan send (nil chan)&quot;</span></span><br><span class="line">	waitReasonDumpingHeap                             <span class="comment">// &quot;dumping heap&quot;</span></span><br><span class="line">	waitReasonGarbageCollection                       <span class="comment">// &quot;garbage collection&quot;</span></span><br><span class="line">	waitReasonGarbageCollectionScan                   <span class="comment">// &quot;garbage collection scan&quot;</span></span><br><span class="line">	waitReasonPanicWait                               <span class="comment">// &quot;panicwait&quot;</span></span><br><span class="line">	waitReasonSelect                                  <span class="comment">// &quot;select&quot;</span></span><br><span class="line">	waitReasonSelectNoCases                           <span class="comment">// &quot;select (no cases)&quot;</span></span><br><span class="line">	waitReasonGCAssistWait                            <span class="comment">// &quot;GC assist wait&quot;</span></span><br><span class="line">	waitReasonGCSweepWait                             <span class="comment">// &quot;GC sweep wait&quot;</span></span><br><span class="line">	waitReasonGCScavengeWait                          <span class="comment">// &quot;GC scavenge wait&quot;</span></span><br><span class="line">	waitReasonChanReceive                             <span class="comment">// &quot;chan receive&quot;</span></span><br><span class="line">	waitReasonChanSend                                <span class="comment">// &quot;chan send&quot;</span></span><br><span class="line">	waitReasonFinalizerWait                           <span class="comment">// &quot;finalizer wait&quot;</span></span><br><span class="line">	waitReasonForceGGIdle                             <span class="comment">// &quot;force gc (idle)&quot;</span></span><br><span class="line">	waitReasonSemacquire                              <span class="comment">// &quot;semacquire&quot;</span></span><br><span class="line">	waitReasonSleep                                   <span class="comment">// &quot;sleep&quot;</span></span><br><span class="line">	waitReasonSyncCondWait                            <span class="comment">// &quot;sync.Cond.Wait&quot;</span></span><br><span class="line">	waitReasonTimerGoroutineIdle                      <span class="comment">// &quot;timer goroutine (idle)&quot;</span></span><br><span class="line">	waitReasonTraceReaderBlocked                      <span class="comment">// &quot;trace reader (blocked)&quot;</span></span><br><span class="line">	waitReasonWaitForGCCycle                          <span class="comment">// &quot;wait for GC cycle&quot;</span></span><br><span class="line">	waitReasonGCWorkerIdle                            <span class="comment">// &quot;GC worker (idle)&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>用一个例子来作为线索看其源码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> ()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    z := x + y</span><br><span class="line">		<span class="keyword">return</span> z </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">0x100</span></span><br><span class="line">    y := <span class="number">0x200</span></span><br><span class="line">		<span class="keyword">go</span> add(x, y) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//编译</span><br><span class="line">go build -o ex1 ex1.go</span><br><span class="line">go tool objdump -s &quot;main\.main&quot; ./ex1</span><br><span class="line">TEXT main.main(SB) /root/workspace/ex/ex1.go</span><br><span class="line">  ex1.go:6              0x4525d0                64488b0c25f8ffffff      MOVQ FS:0xfffffff8, CX</span><br><span class="line">  ex1.go:6              0x4525d9                483b6110                CMPQ 0x10(CX), SP</span><br><span class="line">  ex1.go:6              0x4525dd                7642                    JBE 0x452621</span><br><span class="line">  ex1.go:6              0x4525df                4883ec30                SUBQ $0x30, SP</span><br><span class="line">  ex1.go:6              0x4525e3                48896c2428              MOVQ BP, 0x28(SP)</span><br><span class="line">  ex1.go:6              0x4525e8                488d6c2428              LEAQ 0x28(SP), BP</span><br><span class="line">  ex1.go:9              0x4525ed                c7042418000000          MOVL $0x18, 0(SP)</span><br><span class="line">  ex1.go:9              0x4525f4                488d058d580200          LEAQ 0x2588d(IP), AX</span><br><span class="line">  ex1.go:9              0x4525fb                4889442408              MOVQ AX, 0x8(SP)</span><br><span class="line">  ex1.go:9              0x452600                48c744241000010000      MOVQ $0x100, 0x10(SP)</span><br><span class="line">  ex1.go:9              0x452609                48c744241800020000      MOVQ $0x200, 0x18(SP)</span><br><span class="line">  ex1.go:9              0x452612                e879b7fdff              CALL runtime.newproc(SB)</span><br><span class="line">  ex1.go:9              0x452617                488b6c2428              MOVQ 0x28(SP), BP</span><br><span class="line">  ex1.go:9              0x45261c                4883c430                ADDQ $0x30, SP</span><br><span class="line">  ex1.go:9              0x452620                c3                      RET</span><br><span class="line">  ex1.go:6              0x452621                e8da7affff              CALL runtime.morestack_noctxt(SB)</span><br><span class="line">  ex1.go:6              0x452626                eba8                    JMP main.main(SB)</span><br></pre></td></tr></table></figure>

<p>可以看到main.main部分的函数实际的汇编如上，做了一系列准备后，调用了runtime.newproc函数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb ex1</span><br><span class="line">(gdb) b runtime.newproc</span><br><span class="line">Breakpoint 2 at 0x42dd90: file /usr/local/go/src/runtime/proc.go, line 3251.</span><br></pre></td></tr></table></figure>

<p>于是去上述文件里找到对应的函数观察(后续基本都是这样子找函数的，不再赘述。)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器讲go关键字转化成调用该函数，fn为goroutine要运行的函数，size为fn的参数的内存大小。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="type">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">  <span class="comment">//在fn内存地址的基础上加上一个指针的长度（也就是fn存储的长度），由于这是栈，因此就可以指向在压fn之前的第一个参数的地址。</span></span><br><span class="line">	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">	gp := getg()</span><br><span class="line">	pc := getcallerpc() <span class="comment">//获取当前groutine的PC，也就是go func的位置。</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		newproc1(fn, (*<span class="type">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看看newproc1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new g running fn with narg bytes of arguments starting</span></span><br><span class="line"><span class="comment">// at argp. callerpc is the address of the go statement that created</span></span><br><span class="line"><span class="comment">// this. The new g is put on the queue of g&#x27;s waiting to run.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="type">uint8</span>, narg <span class="type">int32</span>, callergp *g, callerpc <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">		_g_.m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">		throw(<span class="string">&quot;go of nil func value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	acquirem() <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">	siz := narg</span><br><span class="line">	siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span> <span class="comment">//内存对齐</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// We could allocate a larger initial stack if necessary.</span></span><br><span class="line">	<span class="comment">// Not worth it: this is almost always an error.</span></span><br><span class="line">	<span class="comment">// 4*sizeof(uintreg): extra space added below</span></span><br><span class="line">	<span class="comment">// sizeof(uintreg): caller&#x27;s LR (arm) or return address (x86, in gostartcall).</span></span><br><span class="line">	<span class="keyword">if</span> siz &gt;= _StackMin<span class="number">-4</span>*sys.RegSize-sys.RegSize &#123;</span><br><span class="line">		throw(<span class="string">&quot;newproc: function arguments too large for new goroutine&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从当前p的空闲链表里获取goroutine,如果没有先从global runqueue里获取一批（保持32个）</span></span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">	newg := gfget(_p_)</span><br><span class="line">	<span class="keyword">if</span> newg == <span class="literal">nil</span> &#123; <span class="comment">//如果没获取到空闲goroutine，则创建一个goroutine</span></span><br><span class="line">		newg = malg(_StackMin)</span><br><span class="line">		casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">		allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#x27;t look at uninitialized stack.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> newg.stack.hi == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;newproc1: newg missing stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class="line">		throw(<span class="string">&quot;newproc1: new g is not Gdead&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	totalSize := <span class="number">4</span>*sys.RegSize + <span class="type">uintptr</span>(siz) + sys.MinFrameSize <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line">	totalSize += -totalSize &amp; (sys.SpAlign - <span class="number">1</span>)                  <span class="comment">// align to spAlign</span></span><br><span class="line">	sp := newg.stack.hi - totalSize</span><br><span class="line">	spArg := sp</span><br><span class="line">	<span class="keyword">if</span> usesLR &#123;</span><br><span class="line">		<span class="comment">// caller&#x27;s LR</span></span><br><span class="line">		*(*<span class="type">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">		prepGoExitFrame(sp)</span><br><span class="line">		spArg += sys.MinFrameSize</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> narg &gt; <span class="number">0</span> &#123;</span><br><span class="line">		memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), <span class="type">uintptr</span>(narg))</span><br><span class="line">		<span class="comment">// This is a stack-to-stack copy. If write barriers</span></span><br><span class="line">		<span class="comment">// are enabled and the source stack is grey (the</span></span><br><span class="line">		<span class="comment">// destination is always black), then perform a</span></span><br><span class="line">		<span class="comment">// barrier copy. We do this *after* the memmove</span></span><br><span class="line">		<span class="comment">// because the destination stack may have garbage on</span></span><br><span class="line">		<span class="comment">// it.</span></span><br><span class="line">		<span class="keyword">if</span> writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone &#123;</span><br><span class="line">			f := findfunc(fn.fn)</span><br><span class="line">			stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))</span><br><span class="line">			<span class="keyword">if</span> stkmap.nbit &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// We&#x27;re in the prologue, so it&#x27;s always stack map index 0.</span></span><br><span class="line">				bv := stackmapdata(stkmap, <span class="number">0</span>)</span><br><span class="line">				bulkBarrierBitmap(spArg, spArg, <span class="type">uintptr</span>(bv.n)*sys.PtrSize, <span class="number">0</span>, bv.bytedata)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">	newg.sched.sp = sp</span><br><span class="line">	newg.stktopsp = sp</span><br><span class="line">	newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">	newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">	gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">	newg.gopc = callerpc</span><br><span class="line">	newg.ancestors = saveAncestors(callergp)</span><br><span class="line">	newg.startpc = fn.fn</span><br><span class="line">	<span class="keyword">if</span> _g_.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">		newg.labels = _g_.m.curg.labels</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> isSystemGoroutine(newg, <span class="literal">false</span>) &#123;</span><br><span class="line">		atomic.Xadd(&amp;sched.ngsys, +<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	newg.gcscanvalid = <span class="literal">false</span></span><br><span class="line">	casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _p_.goidcache == _p_.goidcacheend &#123;</span><br><span class="line">		<span class="comment">// Sched.goidgen is the last allocated id,</span></span><br><span class="line">		<span class="comment">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span></span><br><span class="line">		<span class="comment">// At startup sched.goidgen=0, so main goroutine receives goid=1.</span></span><br><span class="line">		_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</span><br><span class="line">		_p_.goidcache -= _GoidCacheBatch - <span class="number">1</span></span><br><span class="line">		_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</span><br><span class="line">	&#125;</span><br><span class="line">	newg.goid = <span class="type">int64</span>(_p_.goidcache)</span><br><span class="line">	_p_.goidcache++</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		newg.racectx = racegostart(callerpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoCreate(newg, newg.startpc)</span><br><span class="line">	&#125;</span><br><span class="line">	runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &amp;&amp; mainStarted &#123;</span><br><span class="line">		wakep()</span><br><span class="line">	&#125;</span><br><span class="line">	releasem(_g_.m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考<a target="_blank" rel="noopener" href="https://medium.com/@ankur_anand/illustrated-tales-of-go-runtime-scheduler-74809ef6d19b">Illustrated Tales of Go Runtime Scheduler.</a>和<a target="_blank" rel="noopener" href="https://morsmachine.dk/go-scheduler">The Go scheduler</a>，<a target="_blank" rel="noopener" href="https://morsmachine.dk/netpoller">The Go netpoller</a>，<a target="_blank" rel="noopener" href="https://yizhi.ren/2019/06/03/goscheduler/">golang scheduler</a>，<a target="_blank" rel="noopener" href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/">也谈goroutine调度器 </a></p>
<h3 id="1-为什么会有goroutine？"><a href="#1-为什么会有goroutine？" class="headerlink" title="1.为什么会有goroutine？"></a>1.为什么会有goroutine？</h3><ol>
<li>线程依旧太expensive（还有一些是不需要的逻辑，比如signal mask）</li>
<li>gc的算法是stop the world，需要在数据一致时才能调用。如果单纯用thread的话，go runtime无法获取这一信息。</li>
</ol>
<h2 id="4-2-GMP"><a href="#4-2-GMP" class="headerlink" title="4.2 GMP"></a>4.2 GMP</h2><p>​    线程和Goroutine的映射关系模型有三种：1:1，M：1和M：N。GMP使用的是M：N模型，原因很简单，为了尽可能的压榨CPU的性能，缺点是调度器的设计会非常复杂。</p>
<p>​    用大白话简单说就是：G代表goroutine，有三种状态，running，runable和waiting，分别是正在运行，可运行和阻塞。M代表machine，也就是实际执行体（对应os thread），P代表process，通过P来连接G和M，管理相应的资源和调度，因此每一个P都有自己的context。P通过维护一个runqueue来管理可运行状态的goroutine，一个个依次执行，遇到阻塞的就放入阻塞队列中去，等阻塞完成后修改goroutine的状态重新放回runqueue里去。很简单对不对？如果不涉及细节的话，这一套结构和OS的线程调度大同小异。</p>
<p>​    深入一丢丢看看。</p>
<h4 id="4-2-1-获取可运行goroutine"><a href="#4-2-1-获取可运行goroutine" class="headerlink" title="4.2.1 获取可运行goroutine"></a>4.2.1 获取可运行goroutine</h4><p>先往本地runqueue去获取待运行的goroutine，如果没有再去全局runqueue去获取，再没有就去别的线程里的global runqueue里获取。</p>
<h4 id="4-2-2-阻塞goroutine的处理"><a href="#4-2-2-阻塞goroutine的处理" class="headerlink" title="4.2.2 阻塞goroutine的处理"></a>4.2.2 阻塞goroutine的处理</h4><p>阻塞的goroutine的情况无非是，channel接收和发送阻塞，请求锁，定时器，网络I&#x2F;O和阻塞的系统调用。</p>
<p>可以分为两个部分：</p>
<ol>
<li>一个是用户级别的阻塞，以channel的操作为例，当某goroutine A发送数据到channel阻塞后，channel会主动gopark这个goroutine，正常情况下，一定会有另一个goroutine B接收channel里的数据成功，goroutine B会唤醒goroutine A将其加入对应的runqueue中去。因此，当goroutine阻塞时，thread是不会阻塞的。</li>
<li>另一个是涉及系统调用。go的上层设计把所有的syscall封装一层，**runtime.entersyscall(SB)<strong>和</strong>runtime.exitsyscall(SB)**。如果系统调用是阻塞的，就把该M和P分离，让P去执行别的M里的G。后者则让M重新找到之前对应的P，让G加入其runqueue队列里继续执行。如果没找到就找一个idle的P，还没找到就将G加入global runqueue里去，然后将该M状态改为idle。</li>
</ol>
<h4 id="4-2-3-如何保证公平和效率？"><a href="#4-2-3-如何保证公平和效率？" class="headerlink" title="4.2.3 如何保证公平和效率？"></a>4.2.3 如何保证公平和效率？</h4><ol>
<li>goroutine每运行10ms就会被标记成可抢占，然后在该goroutine的下一次函数调用入口有编译器插入的协作抢占点。但这不是preemptive的，也就是说如果没有这个协作抢占点入口，那么该goroutine是不会被替换的。（在1.13版本之前）。</li>
<li>每隔N个调度就会去检查一下global runqueue，拉取一批goroutine去本地runqueue，防止饥饿。</li>
<li>在runtime初始化的sysmom那个函数里，会定时把fd注册到netpoller上，而一旦fd准备好了，就异步通知goroutine，将其放入runqueue中。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/02/GMP/" data-id="cl0t1dd0x004d8slfaihi9p2q" data-title="goroutine详解" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-golang语言深度解析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/30/golang%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2021-03-30T03:18:27.000Z" itemprop="datePublished">2021-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/30/golang%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">golang语言深度解析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="预备方法"><a href="#预备方法" class="headerlink" title="预备方法"></a>预备方法</h2><p>查询golang源码的实现可以这么操作：</p>
<ol>
<li>写一个简单的测试代码，用<code>go build -gcflags=all=&quot;-N -l&quot; main.go</code>编译成二进制文件</li>
<li>用<code>go tool objdump -s &quot;main\.main&#123;要查看的函数名称&#125;&quot; main</code>来查看汇编代码</li>
<li>一般可以看到一些CALL runtime.func的函数。此时用gdb main进入gdb调试状态。</li>
<li>用b {汇编代码里看到的funcname} ，就是输出具体函数的代码在哪个文件里。</li>
</ol>
<h2 id="1-Channel结构详解"><a href="#1-Channel结构详解" class="headerlink" title="1. Channel结构详解"></a>1. Channel结构详解</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//channel对应的结构体</span></span><br><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>  <span class="comment">// chan 里元素数量</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>  <span class="comment">// chan 底层循环数组的长度</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 指向底层循环数组的指针,只针对有缓冲的 channel</span></span><br><span class="line">    elemsize <span class="type">uint16</span> <span class="comment">// chan 中元素大小</span></span><br><span class="line">    closed   <span class="type">uint32</span> <span class="comment">// chan 是否被关闭的标志</span></span><br><span class="line">    elemtype *_type <span class="comment">// chan 中元素的类型</span></span><br><span class="line">    sendx    <span class="type">uint</span>   <span class="comment">// 已发送元素在循环数组中的索引</span></span><br><span class="line">    recvx    <span class="type">uint</span>   <span class="comment">// 已接收元素在循环数组中的索引</span></span><br><span class="line">    recvq    waitq  <span class="comment">// 等待接收的 goroutine 队列，也就是执行了 &lt;-chan 的goroutine 队列</span></span><br><span class="line">    sendq    waitq  <span class="comment">// 等待发送的 goroutine 队列，也就是执行了 -&gt;chan 的goroutine 队列</span></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//recvq和sendq是一个由sudog构造的双向链表。其中sudog对应一个goroutine，用来记录需要操作channel的goroutine。</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿channel接收数据为例，通过汇编可以知道在执行 &lt;-chan这种操作时，最后执行的是下面的函数。可以通过注释来看逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chanrecv 位于 src/runtime/chan.go </span></span><br><span class="line"><span class="comment">//返回值 selected 代表的是在select关键字语义中，case &lt;-chan 是否会被命中。注意，有时候一个关闭的chan也能命中case就是这个原因。</span></span><br><span class="line"><span class="comment">//received 用来指示返回的数据是真实从channel里读取的，还是因为关闭后返回的该数据类型的零值。也就是 a,ok:=&lt;-chan 的ok的含义。</span></span><br><span class="line"><span class="comment">// 参数 block的含义是是否阻塞，如果是阻塞模式，那么一定要等数据接收到，并且读取完成才会返回；而非阻塞模式下，如果没有数据接可以接收，那么就立即返回。（⚠️ 非阻塞与异步的区别）</span></span><br><span class="line"><span class="comment">// 接收的主要逻辑是：</span></span><br><span class="line"><span class="comment">// 1. 非缓冲型，从sendq里读取数据写入参数ep指向的地址里。</span></span><br><span class="line"><span class="comment">// 2. 缓冲型，从buf里读取数据写入参数ep指向的地址里。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 省略 debug 内容 …………</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是一个 nil 的 channel</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不阻塞，直接返回 (false, false)</span></span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，接收一个 nil 的 channel，goroutine 挂起</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">&quot;chan receive (nil chan)&quot;</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 不会执行到这里</span></span><br><span class="line">        throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在非阻塞模式下，如果数据没有准备好，就可以立马返回。</span></span><br><span class="line">    <span class="comment">// 因为都是只读的属性，可以不加锁读取，所以放在前面判断。</span></span><br><span class="line">    <span class="comment">// channel 没准备好接收的情况有：</span></span><br><span class="line">    <span class="comment">// 1. 非缓冲型，等待发送列队 sendq 里没有 goroutine 在等待。</span></span><br><span class="line">    <span class="comment">// 2. 缓冲型，但 buf 里没有元素</span></span><br><span class="line">    <span class="comment">// 并且需要 closed == 0，即 channel 未关闭。因为如果closed关闭了的话，是可以命中select的case的，selected要返回true。</span></span><br><span class="line">    <span class="comment">// 因为 channel 不可能被重复打开，所以前一个观测的时候 channel 也是未关闭的，</span></span><br><span class="line">    <span class="comment">// 因此在这种情况下可以直接宣布接收失败，返回 (false, false)</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">        c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel 已关闭，并且循环数组 buf 里没有元素</span></span><br><span class="line">    <span class="comment">// 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况</span></span><br><span class="line">    <span class="comment">// 也就是说即使是关闭状态，但在缓冲型的 channel，buf 里有元素的情况下还能接收到元素</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(unsafe.Pointer(c))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 从一个已关闭的 channel 执行接收操作，且未忽略返回值</span></span><br><span class="line">            <span class="comment">// 那么接收的值将是一个该类型的零值</span></span><br><span class="line">            <span class="comment">// typedmemclr 根据类型清理相应地址的内存</span></span><br><span class="line">            typedmemclr(c.elemtype, ep)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从一个已关闭的 channel 接收，selected 会返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待发送队列里有 goroutine 存在，说明 buf 是满的</span></span><br><span class="line">    <span class="comment">// 这有可能是：</span></span><br><span class="line">    <span class="comment">// 1. 非缓冲型的 channel</span></span><br><span class="line">    <span class="comment">// 2. 缓冲型的 channel，但 buf 满了</span></span><br><span class="line">    <span class="comment">// 针对 1，直接进行内存拷贝（从 sender goroutine -&gt; receiver goroutine）</span></span><br><span class="line">    <span class="comment">// 针对 2，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">        <span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">        <span class="comment">// and add sender&#x27;s value to the tail of the queue (both map to</span></span><br><span class="line">        <span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">        recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲型，buf 里有元素，可以正常接收</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 直接从循环数组里找到要接收的元素</span></span><br><span class="line">        qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="comment">// …………</span></span><br><span class="line">        <span class="comment">// 代码里，没有忽略要接收的值，不是 &quot;&lt;- ch&quot;，而是 &quot;val &lt;- ch&quot;，ep 指向 val</span></span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清理掉循环数组里相应位置的值</span></span><br><span class="line">        typedmemclr(c.elemtype, qp)</span><br><span class="line">        <span class="comment">// 接收游标向前移动</span></span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="comment">// 接收游标归零</span></span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// buf 数组里的元素个数减 1</span></span><br><span class="line">        c.qcount--</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !block &#123; <span class="comment">// 非阻塞接收，解锁。selected 返回 false，因为没有接收到值</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是处理阻塞模式下（目前默认使用的模式），没有数据可以读取应该怎么阻塞调用&lt;-chan的giroutine</span></span><br><span class="line">    gp := getg() <span class="comment">//获取当前的goroutine</span></span><br><span class="line">    mysg := acquireSudog() <span class="comment">//sudog底层实现是一个缓存池，而不是新创建</span></span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待接收数据的地址保存下来</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 进入该 channel 的等待接收队列，也就是等待从该channel里读取数据</span></span><br><span class="line">    c.recvq.enqueue(mysg)</span><br><span class="line">    <span class="comment">// 将当前 goroutine 挂起</span></span><br><span class="line">    goparkunlock(&amp;c.lock, <span class="string">&quot;chan receive&quot;</span>, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被唤醒了，接着从这里继续执行一些扫尾工作</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    closed := gp.param == <span class="literal">nil</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg) <span class="comment">// 释放sudog回缓存池</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74613114">深度解密Go语言之channel </a> 因此channel的接收和发送不过是一系列内存拷贝，以及对相关goroutine的管理。</p>
<h2 id="2-select关键字详解"><a href="#2-select关键字详解" class="headerlink" title="2. select关键字详解"></a>2. select关键字详解</h2><p>从汇编代码里可以看出select主要是调用了<code>runtime.selectnbrecv</code>函数那么去<code>(gdb) b runtime.selectnbrecv Breakpoint 1 at 0x4058b0: file /usr/local/go/src/runtime/chan.go, line 635</code>文件里找找。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compiler implements</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	select &#123;</span></span><br><span class="line"><span class="comment">//	case v = &lt;-c:</span></span><br><span class="line"><span class="comment">//		... foo</span></span><br><span class="line"><span class="comment">//	default:</span></span><br><span class="line"><span class="comment">//		... bar</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// as</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	if selectnbrecv(&amp;v, c) &#123;</span></span><br><span class="line"><span class="comment">//		... foo</span></span><br><span class="line"><span class="comment">//	&#125; else &#123;</span></span><br><span class="line"><span class="comment">//		... bar</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected <span class="type">bool</span>) &#123;</span><br><span class="line">	selected, _ = chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>意思就是把select翻译成了if else语句，selectnbrecv能够命中的话就进入if语句，default则是最后的else，不难想象如果还有多的case，则会翻译成else if语句。selectnbrecv的逻辑很简单，用channel结构里的chanrecv来判断是否命中select。那么这样有一个问题，如果第一个case持续命中，如何解决后面的case的饥饿问题？</p>
<p>多给一个case条件，其汇编代码则用了runtime.selectgo，而不是runtime.selectnbrecv函数。<code>(gdb) b runtime.selectgo Breakpoint 1 at 0x433fb0: file /usr/local/go/src/runtime/select.go, line 115.</code>开始重头戏，可以看看注释。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Changes here must also be made in src/cmd/internal/gc/select.go&#x27;s scasetype.</span></span><br><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">	c           *hchan         <span class="comment">// chan</span></span><br><span class="line">	elem        unsafe.Pointer <span class="comment">// data element</span></span><br><span class="line">	kind        <span class="type">uint16</span>  <span class="comment">//case的类型，有default，chan recv,chan send,nil</span></span><br><span class="line">	pc          <span class="type">uintptr</span> <span class="comment">// race pc (for race detector / msan)</span></span><br><span class="line">	releasetime <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// selectgo implements the select statement.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// cas0 points to an array of type [ncases]scase, and order0 points to</span></span><br><span class="line"><span class="comment">// an array of type [2*ncases]uint16. Both reside on the goroutine&#x27;s</span></span><br><span class="line"><span class="comment">// stack (regardless of any escaping in selectgo).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// selectgo returns the index of the chosen scase, which matches the</span></span><br><span class="line"><span class="comment">// ordinal position of its respective select&#123;recv,send,default&#125; call.</span></span><br><span class="line"><span class="comment">// Also, if the chosen scase was a receive operation, it reports whether</span></span><br><span class="line"><span class="comment">// a value was received.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *<span class="type">uint16</span>, ncases <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">//....debug的信息</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">//下面的是将cas0转化成一个2^16长度的scase数组的指针</span></span><br><span class="line">  <span class="comment">//将order0转化成一个2^17长度的uint16数组的指针</span></span><br><span class="line">	cas1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]scase)(unsafe.Pointer(cas0))</span><br><span class="line">	order1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">17</span>]<span class="type">uint16</span>)(unsafe.Pointer(order0))</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里的切片的语法不太常用，</span></span><br><span class="line">  <span class="comment">//其含义是s[low : high : max]从切片s的索引位置low到high处所获得的切片</span></span><br><span class="line">  <span class="comment">//主要的功能是len=high-low，cap=max-low</span></span><br><span class="line">	scases := cas1[:ncases:ncases]</span><br><span class="line">	pollorder := order1[:ncases:ncases] <span class="comment">//保存case的检查顺序</span></span><br><span class="line">	lockorder := order1[ncases:][:ncases:ncases] <span class="comment">//保存scase里的hchan的地址</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Replace send/receive cases involving nil channels with</span></span><br><span class="line">	<span class="comment">// caseNil so logic below can assume non-nil channel.</span></span><br><span class="line">  <span class="comment">//如果case里的channel是</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> scases &#123;</span><br><span class="line">		cas := &amp;scases[i]</span><br><span class="line">		<span class="keyword">if</span> cas.c == <span class="literal">nil</span> &amp;&amp; cas.kind != caseDefault &#123;</span><br><span class="line">			*cas = scase&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">			scases[i].releasetime = <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The compiler rewrites selects that statically have</span></span><br><span class="line">	<span class="comment">// only 0 or 1 cases plus default into simpler constructs.</span></span><br><span class="line">	<span class="comment">// The only way we can end up with such small sel.ncase</span></span><br><span class="line">	<span class="comment">// values here is for a larger select in which most channels</span></span><br><span class="line">	<span class="comment">// have been nilled out. The general code handles those</span></span><br><span class="line">	<span class="comment">// cases correctly, and they are rare enough not to bother</span></span><br><span class="line">	<span class="comment">// optimizing (and needing to test).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// generate permuted order</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		j := fastrandn(<span class="type">uint32</span>(i + <span class="number">1</span>))</span><br><span class="line">		pollorder[i] = pollorder[j]</span><br><span class="line">		pollorder[j] = <span class="type">uint16</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sort the cases by Hchan address to get the locking order.</span></span><br><span class="line">	<span class="comment">// simple heap sort, to guarantee n log n time and constant stack footprint.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		j := i</span><br><span class="line">		<span class="comment">// Start with the pollorder to permute cases on the same channel.</span></span><br><span class="line">		c := scases[pollorder[i]].c</span><br><span class="line">		<span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; scases[lockorder[(j<span class="number">-1</span>)/<span class="number">2</span>]].c.sortkey() &lt; c.sortkey() &#123;</span><br><span class="line">			k := (j - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">			lockorder[j] = lockorder[k]</span><br><span class="line">			j = k</span><br><span class="line">		&#125;</span><br><span class="line">		lockorder[j] = pollorder[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := ncases - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		o := lockorder[i]</span><br><span class="line">		c := scases[o].c</span><br><span class="line">		lockorder[i] = lockorder[<span class="number">0</span>]</span><br><span class="line">		j := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			k := j*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> k &gt;= i &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> k+<span class="number">1</span> &lt; i &amp;&amp; scases[lockorder[k]].c.sortkey() &lt; scases[lockorder[k+<span class="number">1</span>]].c.sortkey() &#123;</span><br><span class="line">				k++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.sortkey() &lt; scases[lockorder[k]].c.sortkey() &#123;</span><br><span class="line">				lockorder[j] = lockorder[k]</span><br><span class="line">				j = k</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		lockorder[j] = o</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i+<span class="number">1</span> &lt; ncases; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> scases[lockorder[i]].c.sortkey() &gt; scases[lockorder[i+<span class="number">1</span>]].c.sortkey() &#123;</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">&quot;i=&quot;</span>, i, <span class="string">&quot; x=&quot;</span>, lockorder[i], <span class="string">&quot; y=&quot;</span>, lockorder[i+<span class="number">1</span>], <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">				throw(<span class="string">&quot;select: broken sort&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock all the channels involved in the select</span></span><br><span class="line">	sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		gp     *g</span><br><span class="line">		sg     *sudog</span><br><span class="line">		c      *hchan</span><br><span class="line">		k      *scase</span><br><span class="line">		sglist *sudog</span><br><span class="line">		sgnext *sudog</span><br><span class="line">		qp     unsafe.Pointer</span><br><span class="line">		nextp  **sudog</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">	<span class="comment">// pass 1 - look for something already waiting</span></span><br><span class="line">	<span class="keyword">var</span> dfli <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> dfl *scase</span><br><span class="line">	<span class="keyword">var</span> casi <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> cas *scase</span><br><span class="line">	<span class="keyword">var</span> recvOK <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		casi = <span class="type">int</span>(pollorder[i])</span><br><span class="line">		cas = &amp;scases[casi]</span><br><span class="line">		c = cas.c</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">		<span class="keyword">case</span> caseNil:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseRecv:</span><br><span class="line">			sg = c.sendq.dequeue()</span><br><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> recv</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> bufrecv</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> rclose</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseSend:</span><br><span class="line">			<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">				racereadpc(c.raceaddr(), cas.pc, chansendpc)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> sclose</span><br><span class="line">			&#125;</span><br><span class="line">			sg = c.recvq.dequeue()</span><br><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> send</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">				<span class="keyword">goto</span> bufsend</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseDefault:</span><br><span class="line">			dfli = casi</span><br><span class="line">			dfl = cas</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> dfl != <span class="literal">nil</span> &#123;</span><br><span class="line">		selunlock(scases, lockorder)</span><br><span class="line">		casi = dfli</span><br><span class="line">		cas = dfl</span><br><span class="line">		<span class="keyword">goto</span> retc</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pass 2 - enqueue on all chans</span></span><br><span class="line">	gp = getg()</span><br><span class="line">	<span class="keyword">if</span> gp.waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;gp.waiting != nil&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	nextp = &amp;gp.waiting</span><br><span class="line">	<span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">		casi = <span class="type">int</span>(casei)</span><br><span class="line">		cas = &amp;scases[casi]</span><br><span class="line">		<span class="keyword">if</span> cas.kind == caseNil &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		c = cas.c</span><br><span class="line">		sg := acquireSudog()</span><br><span class="line">		sg.g = gp</span><br><span class="line">		sg.isSelect = <span class="literal">true</span></span><br><span class="line">		<span class="comment">// No stack splits between assigning elem and enqueuing</span></span><br><span class="line">		<span class="comment">// sg on gp.waiting where copystack can find it.</span></span><br><span class="line">		sg.elem = cas.elem</span><br><span class="line">		sg.releasetime = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">		sg.c = c</span><br><span class="line">		<span class="comment">// Construct waiting list in lock order.</span></span><br><span class="line">		*nextp = sg</span><br><span class="line">		nextp = &amp;sg.waitlink</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">		<span class="keyword">case</span> caseRecv:</span><br><span class="line">			c.recvq.enqueue(sg)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseSend:</span><br><span class="line">			c.sendq.enqueue(sg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait for someone to wake us up</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	gopark(selparkcommit, <span class="literal">nil</span>, waitReasonSelect, traceEvGoBlockSelect, <span class="number">1</span>)</span><br><span class="line">	gp.activeStackChans = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line">	gp.selectDone = <span class="number">0</span></span><br><span class="line">	sg = (*sudog)(gp.param)</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// pass 3 - dequeue from unsuccessful chans</span></span><br><span class="line">	<span class="comment">// otherwise they stack up on quiet channels</span></span><br><span class="line">	<span class="comment">// record the successful case, if any.</span></span><br><span class="line">	<span class="comment">// We singly-linked up the SudoGs in lock order.</span></span><br><span class="line">	casi = <span class="number">-1</span></span><br><span class="line">	cas = <span class="literal">nil</span></span><br><span class="line">	sglist = gp.waiting</span><br><span class="line">	<span class="comment">// Clear all elem before unlinking from gp.waiting.</span></span><br><span class="line">	<span class="keyword">for</span> sg1 := gp.waiting; sg1 != <span class="literal">nil</span>; sg1 = sg1.waitlink &#123;</span><br><span class="line">		sg1.isSelect = <span class="literal">false</span></span><br><span class="line">		sg1.elem = <span class="literal">nil</span></span><br><span class="line">		sg1.c = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">		k = &amp;scases[casei]</span><br><span class="line">		<span class="keyword">if</span> k.kind == caseNil &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sglist.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">			k.releasetime = sglist.releasetime</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg == sglist &#123;</span><br><span class="line">			<span class="comment">// sg has already been dequeued by the G that woke us up.</span></span><br><span class="line">			casi = <span class="type">int</span>(casei)</span><br><span class="line">			cas = k</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c = k.c</span><br><span class="line">			<span class="keyword">if</span> k.kind == caseSend &#123;</span><br><span class="line">				c.sendq.dequeueSudoG(sglist)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				c.recvq.dequeueSudoG(sglist)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sgnext = sglist.waitlink</span><br><span class="line">		sglist.waitlink = <span class="literal">nil</span></span><br><span class="line">		releaseSudog(sglist)</span><br><span class="line">		sglist = sgnext</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cas == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// We can wake up with gp.param == nil (so cas == nil)</span></span><br><span class="line">		<span class="comment">// when a channel involved in the select has been closed.</span></span><br><span class="line">		<span class="comment">// It is easiest to loop and re-run the operation;</span></span><br><span class="line">		<span class="comment">// we&#x27;ll see that it&#x27;s now closed.</span></span><br><span class="line">		<span class="comment">// Maybe some day we can signal the close explicitly,</span></span><br><span class="line">		<span class="comment">// but we&#x27;d have to distinguish close-on-reader from close-on-writer.</span></span><br><span class="line">		<span class="comment">// It&#x27;s easiest not to duplicate the code and just recheck above.</span></span><br><span class="line">		<span class="comment">// We know that something closed, and things never un-close,</span></span><br><span class="line">		<span class="comment">// so we won&#x27;t block again.</span></span><br><span class="line">		<span class="keyword">goto</span> loop</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c = cas.c</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;wait-return: cas0=&quot;</span>, cas0, <span class="string">&quot; c=&quot;</span>, c, <span class="string">&quot; cas=&quot;</span>, cas, <span class="string">&quot; kind=&quot;</span>, cas.kind, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cas.kind == caseRecv &#123;</span><br><span class="line">		recvOK = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		<span class="keyword">if</span> cas.kind == caseRecv &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			raceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> cas.kind == caseSend &#123;</span><br><span class="line">			raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		<span class="keyword">if</span> cas.kind == caseRecv &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			msanwrite(cas.elem, c.elemtype.size)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> cas.kind == caseSend &#123;</span><br><span class="line">			msanread(cas.elem, c.elemtype.size)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufrecv:</span><br><span class="line">	<span class="comment">// can receive from buffer</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			raceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc)</span><br><span class="line">		&#125;</span><br><span class="line">		raceacquire(chanbuf(c, c.recvx))</span><br><span class="line">		racerelease(chanbuf(c, c.recvx))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		msanwrite(cas.elem, c.elemtype.size)</span><br><span class="line">	&#125;</span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	qp = chanbuf(c, c.recvx)</span><br><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		typedmemmove(c.elemtype, cas.elem, qp)</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemclr(c.elemtype, qp)</span><br><span class="line">	c.recvx++</span><br><span class="line">	<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">		c.recvx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount--</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufsend:</span><br><span class="line">	<span class="comment">// can send to buffer</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceacquire(chanbuf(c, c.sendx))</span><br><span class="line">		racerelease(chanbuf(c, c.sendx))</span><br><span class="line">		raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(cas.elem, c.elemtype.size)</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)</span><br><span class="line">	c.sendx++</span><br><span class="line">	<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">		c.sendx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount++</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">recv:</span><br><span class="line">	<span class="comment">// can receive from sleeping sender (sg)</span></span><br><span class="line">	recv(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;syncrecv: cas0=&quot;</span>, cas0, <span class="string">&quot; c=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">rclose:</span><br><span class="line">	<span class="comment">// read at end of closed channel</span></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	recvOK = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		typedmemclr(c.elemtype, cas.elem)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceacquire(c.raceaddr())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">send:</span><br><span class="line">	<span class="comment">// can send to a sleeping receiver (sg)</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(cas.elem, c.elemtype.size)</span><br><span class="line">	&#125;</span><br><span class="line">	send(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;syncsend: cas0=&quot;</span>, cas0, <span class="string">&quot; c=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">retc:</span><br><span class="line">	<span class="keyword">if</span> cas.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(cas.releasetime-t0, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> casi, recvOK</span><br><span class="line"></span><br><span class="line">sclose:</span><br><span class="line">	<span class="comment">// send on closed channel</span></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-从引导和初始化说起"><a href="#3-从引导和初始化说起" class="headerlink" title="3. 从引导和初始化说起"></a>3. 从引导和初始化说起</h2><p>​    编译器会给程序加一层引导代码，根据运行平台来进行不同的初始化。从rt0_*{平台}.s文件里找到rt0_go函数，这就是初始化的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$0 </span><br><span class="line">	...</span><br><span class="line">	// 调用初始化函数</span><br><span class="line">	CALL runtime·args(SB)</span><br><span class="line">	CALL runtime·osinit(SB) </span><br><span class="line">	CALL runtime·schedinit(SB)</span><br><span class="line">	// 创建 main goroutine 用于执行 runtime.main</span><br><span class="line">	MOVQ $runtime·mainPC(SB), AX</span><br><span class="line">	PUSHQ AX</span><br><span class="line">	PUSHQ $0</span><br><span class="line">	CALL runtime·newproc(SB) POPQ AX</span><br><span class="line">	POPQ AX</span><br><span class="line">	//让当前线程开始执行 main goroutine</span><br><span class="line">	CALL runtime·mstart(SB)</span><br><span class="line">	RET</span><br><span class="line">DATA runtime·mainPC+0(SB)/8,$runtime·main(SB) </span><br><span class="line">GLOBL runtime·mainPC(SB),RODATA,$8</span><br></pre></td></tr></table></figure>

<p>可以看到，就是一次调用了<code>runtime·args（整理命令行参数）, runtime·osinit（获取CPU core的数量）,runtime·schedinit（内存分配器，垃圾回收器，并发调度器的初始化都在此执行，后面详述）  </code>，然后通过newproc创建goroutine来执行runtime.main（执行runtime_init函数，执行main_init函数，最后执行用户逻辑入口main.main函数）。</p>
<h2 id="5-内存分配"><a href="#5-内存分配" class="headerlink" title="5. 内存分配"></a>5. 内存分配</h2><p><a target="_blank" rel="noopener" href="https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed">A visual guide to Go Memory Allocator from scratch (Golang)</a></p>
<p>分配器管理两层内存块，span（由多个地址连续的页组成的），object（将span按特定大小切分成多个小块来分配对象）。</p>
<h2 id="6-Golang汇编"><a href="#6-Golang汇编" class="headerlink" title="6. Golang汇编"></a>6. Golang汇编</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://www.ershicimi.com/p/dd7414381b510cfc8cea5bb400854fa2">Golang 汇编入门知识总结</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019753885">Go 函数调用 ━ 栈和寄存器视角</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/yangyuqian/technical-articles/blob/master/asm/golang-plan9-assembly-cn.md#golang%E4%B8%AD%E7%9A%84plan9%E6%B1%87%E7%BC%96%E5%99%A8">Golang中的Plan9汇编器 </a> </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://lrita.github.io/2017/12/12/golang-asm/#c2goasm">golang 汇编 </a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://colobu.com/2018/12/29/get-assembly-output-for-go-programs/">得到Go程序的汇编代码的方法</a></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/30/golang%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" data-id="cl0t1dd1800568slf77418hpu" data-title="golang语言深度解析" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【CSAPP】Ch7-链接" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/22/%E3%80%90CSAPP%E3%80%91Ch7-%E9%93%BE%E6%8E%A5/" class="article-date">
  <time class="dt-published" datetime="2021-03-22T06:12:53.000Z" itemprop="datePublished">2021-03-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/22/%E3%80%90CSAPP%E3%80%91Ch7-%E9%93%BE%E6%8E%A5/">【csapp】Ch7-链接</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ol>
<li>目标文件：一种是可重定位目标文件，比如.o文件；可执行目标文件，也就是链接完成后，可以直接复制到内存中运行的文件；还有一种共享目标文件，可以在加载或者运行时被动态加载进内存并链接。</li>
<li>ELF：linux系统下的目标文件格式。其主要由ELF头，各类型的节和节头部表组成。</li>
<li>ELF符号表中的符号可以分为三种：1. 自己模块定义，别人引用的叫做全局符号；2. 自己模块引用，别的模块定义的叫做外部符号；3. 自己定义自己引用的叫做局部符号（注意这里不是局部变量，局部变量运行后放入函数的栈中，而局部符号其实时全局变量，不归函数所有，比如定义在函数里的static变量。）</li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    C语言程序的编译已经是老生常谈，最常见的编译流程是：源代码（.c文件）-&gt;<strong>预处理</strong>-&gt;.i主要是处理宏定义和头文件等-&gt;<strong>编译</strong>-&gt;汇编文件（.s文件），就是汇编语言的代码-&gt;<strong>汇编器</strong>-&gt;可重定位目标文件（后续都称为.o文件）-&gt;<strong>链接器</strong>-&gt;可执行目标文件。    </p>
<p>​    这一章主要是说从汇编后的多个.o文件到变成一个完整的可执行目标文件的逻辑。首先，为了说明多个.o文件是如何合并成一个可执行目标文件，需要先介绍一些.o文件的结构，主要是引入符号和符号表的概念。然后第一个部分是广义的链接的步骤，主要就是符号解析和重定位。第二部分是对程序常用的标准库的链接方式，比如静态库和共享库。第三部分是对标准库函数的拦截，利用这个特点，我们能进行很多代码的调试。    </p>
<p><em>该文章以Linux X86-64架构，ELF目标文件为例说明链接的知识点。</em></p>
<h2 id="可重定向目标文件"><a href="#可重定向目标文件" class="headerlink" title="可重定向目标文件"></a>可重定向目标文件</h2><p>具体用C来说，这一部分主要是从.c文件到.o文件的逻辑。其核心在于将各个变量和函数分门别类的组织好，在linux下，.o文件被组织成多个节（section），每个节按照类型和作用来区分。典型的ELF可重定位目标文件的主要结构如下图所示：</p>
<p><img src="/Users/husyhu/Library/Mobile%20Documents/com~apple~CloudDocs/husy1994.github.io/source/_posts/image-20210325170253936.png" alt="image-20210325170253936"></p>
<p>而链接的核心部分就是.symtab这一节，这是该目标文件的所有符号的集合，包括了函数，全局变量和静态变量。它不仅记录了名字，类型还有定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux 64-bit下，一个符号的结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> name; <span class="comment">//字符串表中的字节偏移，指向符号的字符串名字</span></span><br><span class="line">	<span class="type">char</span> type:<span class="number">4</span>, <span class="comment">// 说明是函数还是数据</span></span><br><span class="line">	binding:<span class="number">4</span>; <span class="comment">//表示符号是本地的还是全局的，全局的需要重定位</span></span><br><span class="line">	<span class="type">char</span> reserved; <span class="comment">//保留位</span></span><br><span class="line">	<span class="type">short</span> section; <span class="comment">//表明该符号在哪个节里，值为节头部表的索引</span></span><br><span class="line">	<span class="type">long</span> value; <span class="comment">//对可重定位目标文件来讲，这是该符号的定义相对于所在节的偏移，比如一个函数名相对于.text起始位置的偏移；而对于最终的可执行目标文件，这个就是一个绝对地址。</span></span><br><span class="line">	<span class="type">long</span> size; <span class="comment">//该符号的大小，以字节为单位</span></span><br><span class="line">&#125;ELF64_Symbol;</span><br></pre></td></tr></table></figure>

<p>等所有的目标模块都解析完了，就可以开始链接成一个文件了。</p>
<ol>
<li>符号表和符号，每个可重定位目标文件都有一个符号表，也就是.symtab节。它保存了该段代码定义和引用的符号信息。（注意⚠️：本地链接器符号和本地程序变量不一样，.symtab不包含本地非静态程序变量的任何符号，也就是那些分配在栈上的变量）。下面就是符号的一个数据结构。</li>
</ol>
<h2 id="符号解析和重定位"><a href="#符号解析和重定位" class="headerlink" title="符号解析和重定位"></a>符号解析和重定位</h2><p>​    真正的链接主要就是两个部分，首先将各个.o文件的各个相同的section合并起来，然后修改对应的内存地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="type">long</span> offset;    <span class="comment">/* Offset of the reference to relocate */</span> </span><br><span class="line">    <span class="type">long</span> type:<span class="number">32</span>,   <span class="comment">/* Relocation type */</span> </span><br><span class="line">	 symbol:<span class="number">32</span>; <span class="comment">/* Symbol table index */</span> </span><br><span class="line">    <span class="type">long</span> addend;    <span class="comment">/* Constant part of relocation expression */</span></span><br><span class="line">&#125; Elf64_Rela; </span><br></pre></td></tr></table></figure>



<h3 id="同名符号的选择"><a href="#同名符号的选择" class="headerlink" title="同名符号的选择"></a>同名符号的选择</h3><p>​    可重定位目标文件仅仅是汇编器输出的文件，单一模块下不允许出现名字和类型相同的符号，当出现不在本模块定义的符号时默认会在别的模块定义。但是在链接的时候如何去区分不同模块的相同符号则有一些规则。</p>
<p>​    其算法很简单：</p>
<pre><code>1.    函数和初始化的全局变量是强定义
 2.    未初始化的全局变量是弱定义（包括extern引用的）
 3.    同名定义只能有一个强定义和0或若干个弱定义。 有强取其强，都弱随机取。
</code></pre>
<h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>​    考虑一个问题，大型软件的链接过程肯定需要很多的可重定位目标文件，并且包含大量基础的功能，比如数学算法，标准I&#x2F;O。如果把这些写到一个可重定位目标文件的话，会造成最后可执行文件的冗余，因为我们不一定使用了所有的符号。但是分开写成一个个.o文件的话，命令又太复杂。于是，提出来静态库来解决这个问题。</p>
<p>​    .a文件（archive）会让链接器只复制被程序引用的目标模块，而且也可以将很多的符号打包成一份.a文件，简化了链接时的命令（甚至有些链接器直接将一些约定俗成的.a文件默认加上）。</p>
<p>​    那么是按照什么逻辑来解析外部符号的呢？</p>
<pre><code>1. 维护三个集合，E（保存目标模块），U（保存未找到定义的外部引用），D（保存已经找到定义的符号集合）。
 2. 按照命令从左到右开始解析，如果是.o文件，就将其加入E，然后解析其符号分别修改U集合和D集合。
 3. 如果是.a文件，就依次用.a文件里的成员尝试去匹配U集合中的符号，找到了就将其成员放入E，修改对应的U和D。（也就是说，链接器不会解析.a文件里未定义的外部符号。）不包含在E中的成员目标文件都被丢弃，知道所有成员目标文件都处理完。
 4. 最后如果U中还存在有符号，则链接错误。
</code></pre>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>7.1 分别用<code>gcc -c m.c</code>和<code>gcc -c swap.c</code>得到可重定位目标文件，然后用<code>readelf -s m.o</code>和<code>readelf -s swap.o</code>来获取节信息。可以看到buf在m.o和swap.o的.symtab里都有，对于定义buf的swap.o来说，buf是全局符号，分配在.data上。而对于使用buf的swap.o来说，它则是外部符号，分配在UNF节中。</p>
<p>注意两个个细节，bufp1是在swap.c里定义的int指针，应该是全局符号，分配在.data里，但是实际上在COM里，意思是未初始化的全局变量。而bufp0同样是int型指针，却在.data节里。这里可以在7.6中的符号解析里说明原因，因为bufp1是一个弱符号。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">readelf -s swap.o</span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 12 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS swap.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     8: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 bufp0</span><br><span class="line">     9: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND buf</span><br><span class="line">    10: 0000000000000008     8 OBJECT  GLOBAL DEFAULT  COM bufp1</span><br><span class="line">    11: 0000000000000000    59 FUNC    GLOBAL DEFAULT    1 swap</span><br><span class="line">    </span><br><span class="line">readelf -s m.o   </span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 11 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS m.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     8: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 buf</span><br><span class="line">     9: 0000000000000000    21 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND swap</span><br></pre></td></tr></table></figure>

<p>7.3 C问题有一点疑惑就是，实践上来讲，.a文件是不能有外部符号的，因为链接器是不会对.a文件进行外部引用解析的。因此这里答案是<code>gcc p.o libx.a liby.a libx.a</code>而不是<code>gcc p.o libx.a liby.a libx.a p.o</code>这样和前面的解析过程是一样的。</p>
<p>### 重定位</p>
<p>重定位主要是分为两个步骤，第一个就是把所有文件链接起来以后，讲各自的节合并以后（a.o文件的.text节和b.o文件的.text节合并为一个整的.text节），叫做重定位节，最终的目的是把符号定义的地址更新。第二个是对重定位节里的符号进行重定位。</p>
<p>\4. 代码的重定位条目放在.rel.text里，<strong>已初始化数据</strong>的重定位条目放在.rel.data里。 重定位条目结构如下</p>
<p>`&#96;&#96;C</p>
<p>typedef sturct{</p>
<p>long offset; &#x2F;&#x2F;节偏移，比如该符号在.text节中被引用，那么就是相对于.text节的偏移</p>
<p>long type:32, &#x2F;&#x2F;重定位的类型，比如相对引用地址还是绝对引用地址</p>
<p>symbol:32; &#x2F;&#x2F;符号节（.symtab）里的对应符号</p>
<p>long addend; &#x2F;&#x2F;有一些类型的重定位需要偏移一个常数</p>
<p>}ELF65_Rela;</p>
<p>`&#96;&#96;</p>
<p>## 标准库的链接</p>
<p>### 可执行目标文件</p>
<p>基本结构也还是elf的结构，但是细节上有一些不一样。比如没有.rel.text等重定位节，但是除了节头部表，多了段头部表，这是为了后续加载器将代码段和数据段分开加载而出现的。</p>
<p>加载该可执行文件的工作主要有驻留在存储器中的OS代码进行加载，在linux下就是execve函数。程序的内存分布概念图如下（具体的细节请参考第8章和第9章）</p>
<p><img src="evernotecid://CAFA12C3-2596-44D8-8611-FC6C695ECC22/appyinxiangcom/17083332/ENResource/p11" alt="81d1cfecc5b84d4f92be47df25a71aef.png"></p>
<p>### 静态库</p>
<p>链接静态库的算法是：</p>
<p>\1. 维护三个集合（需要链接的.o文件集，引用了但未找到定义的集合，定义集合）从左到右扫描.a和.o文件。</p>
<p>\2. 解析每一个文件，更新上述三个集合。（这里还会涉及一个多重定义问题。）</p>
<p>\3. 最后如果引用集合非空则报错。</p>
<p>### 共享库</p>
<p>前面讲了静态库，将程序要用的标准库里的文件复制到整个程序文件目录里，但是这样又有一个问题。比如一些常用的标准输入输出函数，每一个程序都会有，那么在一台电脑上运行多个程序时，就会有多个备份。这显然也是一种浪费。</p>
<p>于是思路变成了在操作系统层面讲标准库加载一份，其余都重定位到这一份标准库的内存空间上。也就是可以被所有进程共享。</p>
<p>#### 加载时链接</p>
<p>在linux下的方式就是有一个动态链接器（ld-linux.so），在加载的时候自动进行动态链接。标准库libc.so就经常被动态链接上。注意是先加载再用动态链接器链接。相当于链接了两次。</p>
<p><img src="evernotecid://CAFA12C3-2596-44D8-8611-FC6C695ECC22/appyinxiangcom/17083332/ENResource/p12" alt="f6359d6aa1229bf7982e3e1679a7d251.png"></p>
<p>#### 运行时链接</p>
<p>在linux中就是由dlopen()接口，这个是由在代码层面写好代码来实现的。</p>
<p>### 拦截</p>
<p>## 疑问</p>
<p>\1. P468 7.5中说目标模块的符号表有三种符号，对应于非静态函数和全局变量(全局符号)，以及带static的静态函数和全局变量（局部符号）这里的全局变量也是针对非静态全局变量和static全局变量吗？我记得const全局变量类似于宏定义#define只是多了编译器的类型检查 。那么static全局变量和非static全局变量有什么区别吗？</p>
<p>\1. 是。 2. static的全局变量和非static的全局变量的区别就是<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3525576/internal-linkage-with-static-keyword-in-c">参考</a></p>
<p>\2. 在c语言文件中，任何带static的函数和变量都是私有的，而不带static的是公共的。</p>
<p>\3. 重定位符号什么时候是使用绝对地址什么时候使用pc相对地址？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/22/%E3%80%90CSAPP%E3%80%91Ch7-%E9%93%BE%E6%8E%A5/" data-id="cl0t1dcy600068slf48yobw84" data-title="【csapp】Ch7-链接" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-golang语言笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/06/golang%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-01-06T02:51:00.000Z" itemprop="datePublished">2021-01-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/06/golang%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/">golang语言笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-range关键字"><a href="#1-range关键字" class="headerlink" title="1. range关键字"></a>1. range关键字</h2><p><a target="_blank" rel="noopener" href="https://studygolang.com/articles/9701">go语言坑之for range</a> 简单来讲就是用<code>for k,v:=range data</code>的方式获取元素的话，v变量只会创建一个，地址是一样的，所以坑就在于如果对v直接做什么操作的话是不会操作到真正的data里的元素上去的。</p>
<p>参考<a target="_blank" rel="noopener" href="https://golang.org/ref/spec#RangeClause">go官方文档</a></p>
<blockquote>
<p>The iteration variables may be declared by the “range” clause using a form of <a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Short_variable_declarations">short variable declaration</a> (<code>:=</code>). In this case their types are set to the types of the respective iteration values and their <a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Declarations_and_scope">scope</a> is the block of the “for” statement; they are <strong>re-used</strong> in each iteration. If the iteration variables are declared outside the “for” statement, after execution their values will be those of the last iteration.</p>
</blockquote>
<p>因此好的习惯是，一般情况下用<code>for i,_:=range data</code>，用索引来取值防止一些错误，更重要的是防止不必要的实例创建。</p>
<h2 id="2-引用类型"><a href="#2-引用类型" class="headerlink" title="2. 引用类型"></a>2. 引用类型</h2><p>slice是golang里的引用类型，但和C++里的引用毫无关系。其底层的实现实际上是</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span>            <span class="comment">// 长度 </span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span>            <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以看出，slice就是一个含有指针的结构体。因此也会有一些结构体传输的特点，比如传递一个切片，在修改某一个值时形参和实参会同时变化，因为指向的是同一个数组。但当操作涉及到修改数组长度的时候，由于runtime会另外开辟一个空间复制整个数组，因此形参和实参指向的数组就变化了。</p>
<p>​    但是同为引用类型的map，chan就不一样了，它们的底层实现就是特定结构体的指针，因此不需要再去注意形参和实参的问题了。另外，map和chan一定要用make创建，不然其零值为nil。但是slice可以看出，不需要make创建，就算是单独声明一个也不是nil，而是一个array指针指向nil的slice对象。</p>
<p>​    因此，传递slice的时候还是尽量用指针，传递map和chan的时候就不需要了。</p>
<h2 id="3-闭包与参数传递"><a href="#3-闭包与参数传递" class="headerlink" title="3. 闭包与参数传递"></a>3. 闭包与参数传递</h2><p>​    <a target="_blank" rel="noopener" href="https://jingwei.link/2019/06/01/golang-outer-variable-in-clousure.html">Golang 闭包内的外部变量</a>，匿名闭包函数直接使用外部变量是地址传递，也就是在执行的时候是会根据变量的变化获取的数据也不一样。</p>
<p>​    但是如果加上了go或defer关键字，则情况有所不同。因为在处理go或者defer时，编译器要准备好后面函数的参数堆栈，从而就要确定参数的值。也就是说defer和go关键字会先在声明处将参数堆栈等准备好，只是说延后了函数的执行。参考<a target="_blank" rel="noopener" href="https://tonybai.com/2018/03/23/the-analysis-of-the-param-evaluation-of-defer-functions/">defer函数参数求值简要分析</a></p>
<p>​    总的来说就是外部变量如果是函数体内直接使用，实际上是获取其地址，在执行的时候才会去求值；而放在参数上的变量，在声明时就求值了，因为golang里所有参数传递都是值传递。</p>
<h2 id="5-指针接收和结构体接收"><a href="#5-指针接收和结构体接收" class="headerlink" title="5. 指针接收和结构体接收"></a>5. 指针接收和结构体接收</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> bb <span class="keyword">struct</span>&#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(b *bb)</span></span> Read()&#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Read  my name is %v\n&quot;</span>,b.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(b *bb)</span></span> Write(newName <span class="type">string</span>)&#123;</span><br><span class="line">    b.Name=newName</span><br><span class="line">    fmt.Printf(<span class="string">&quot;write my newName is %v\n&quot;</span>,b.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(b bb)</span></span> Read1()&#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Read  my name is %v\n&quot;</span>,b.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(b bb)</span></span> Write1(newName <span class="type">string</span>)&#123;</span><br><span class="line">    b.Name=newName</span><br><span class="line">    fmt.Printf(<span class="string">&quot;write my newName is %v\n&quot;</span>,b.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   b1:=&amp;bb&#123;</span><br><span class="line">      Name:<span class="string">&quot;husy&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   b2:=bb&#123;</span><br><span class="line">      Name:<span class="string">&quot;husy&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   b1.Read()</span><br><span class="line">   b1.Write(<span class="string">&quot;husyhu&quot;</span>)</span><br><span class="line">   b1.Read()  </span><br><span class="line">  </span><br><span class="line">   b2.Read1()</span><br><span class="line">   b2.Write1(<span class="string">&quot;husyhu&quot;</span>)</span><br><span class="line">   b2.Read1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Read  my name is husy</span></span><br><span class="line"><span class="comment">write my newName is husyhu</span></span><br><span class="line"><span class="comment">Read  my name is husyhu</span></span><br><span class="line"><span class="comment">Read  my name is husy</span></span><br><span class="line"><span class="comment">write my newName is husyhu</span></span><br><span class="line"><span class="comment">Read  my name is husy</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​    由上可知，如果是结构体接收者，因为在调用的时候是把整个结构体赋给一个临时的结构体对象，然后进行操作。除非该结构体内的数据都是指针类型，否则基本上就意味着这个结构体内的数据只可读，并不能改变其值。一般来讲，应该用指针接受者。可以参考一个坑来帮助理解<a target="_blank" rel="noopener" href="https://tonybai.com/2018/03/20/the-analysis-of-output-results-of-a-go-code-snippet/">对一段Go语言代码输出结果的简要分析</a></p>
<h2 id="6-interface与类型转换"><a href="#6-interface与类型转换" class="headerlink" title="6. interface与类型转换"></a>6. interface与类型转换</h2><p>​    还是以5的代码为例，若是有一个interface a声明了Read而没有声明Write，当把bb赋值给a类型的时候，但是通过a无法调用write了。这里虽然看起来像是一个动态类型转换，但其实调用reflect获取a的type和value和获取bb的一样，不会变。所以这里不是真正的动态类型转化，一旦声明了，其类型就是一个静态的不会变了。但转换的好处是，方便抽象化以及限制了不属于该接口的方法调用。</p>
<p>​    有一个常见的设计模式是工厂模式，先声明一个interface{}变量A，然后根据实际情况来更换具体实现赋值给该变量A。这在C++里是很好的设计模式，在Golang里就不行了，因为变量A一旦被赋值了一个具体实现，其类型就确定了不能更改了。如果想替换成另一个具体实现，就要重新声明变量。</p>
<h2 id="7-继承对象的初始化"><a href="#7-继承对象的初始化" class="headerlink" title="7. 继承对象的初始化"></a>7. 继承对象的初始化</h2><p>匿名对象的初始化必须遵循一层一层的初始化的逻辑，其类型名就是属性名。比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Foo struct&#123;</span><br><span class="line">    A string</span><br><span class="line">    B int</span><br><span class="line">&#125;</span><br><span class="line">type Foo2 struct&#123;</span><br><span class="line">	Foo</span><br><span class="line">	C bool</span><br><span class="line">&#125;</span><br><span class="line">//此时要初始化Foo2的话</span><br><span class="line">a:=Foo2&#123;&#125;</span><br><span class="line">a.Foo=Foo&#123;A:&quot;a&quot;,B:1&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-逃逸分析"><a href="#8-逃逸分析" class="headerlink" title="8. 逃逸分析"></a>8. 逃逸分析</h2><p>​    为什么需要了解逃逸分析是因为</p>
<blockquote>
<p> <strong>stack allocation is cheap and heap allocation is expensive</strong>.</p>
</blockquote>
<p>​    所以目标就是尽量让能分配在stack上的分配在stack上。</p>
<p>​    golang语言在编译时才会决定某个对象是分配在堆上还是栈上。按照C++的传统来说，除了用new分配的局部变量，其余的局部变量都会分配在栈上，退出函数后立即回收。但是Golang虽然也有new，但是无论是局部变量还是new的对象都会经过编译器的分析来决定放在堆上还是栈上。</p>
<p>​    当然各个版本的编译会有细微差别，具体问题具体分析，可以用<code>go build -gcflags &quot;-m&quot;</code> 来查看。总结来讲，通过下面例子可以总结几点：</p>
<p><img src="/Users/husyhu/Library/Mobile%20Documents/com~apple~CloudDocs/husy1994.github.io/source/_posts/image-20210318153230968.png" alt="image-20210318153230968"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//下面是输出结果</span><br><span class="line">go run -gcflags &quot;-m -l&quot; ex1.go</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">command-line-arguments</span></span><br><span class="line">./ex1.go:14:9: leaking param: title</span><br><span class="line">./ex1.go:15:16: do ... argument does not escape</span><br><span class="line">./ex1.go:15:16: title escapes to heap</span><br><span class="line">./ex1.go:9:8: func literal escapes to heap</span><br></pre></td></tr></table></figure>

<p>​    任何一个函数调用都伴随着参数的传递，也就是内存的分配。</p>
<ol>
<li>main函数的s逃逸到了堆上，因为闭包函数引用了外部变量。编译器无法保证goroutine里的do函数什么时候会不需要s对象了，因此不敢放在栈上。</li>
<li>do函数的参数title没有逃逸，它就在do函数的栈上。 等do函数执行完成，就会被回收。</li>
<li>fmt.Println的参数title会逃逸到堆上，而不是在fmt.Println的栈上，因为这个函数的接收参数类型是interface{}，interface类型的参数也会直接分配到堆上。因为编译器不确定其类型。</li>
<li>另外就是，如果栈内存不够了，也会分配到堆上。</li>
<li>以及被发送到channel里的对象，也会全部在堆上。</li>
<li>被slice，map和数组引用的对象。注意是每一个元素，不是slice或者map本身。</li>
</ol>
<h2 id="9-go-mod的replace"><a href="#9-go-mod的replace" class="headerlink" title="9. go.mod的replace"></a>9. go.mod的replace</h2><p>​    参考<a target="_blank" rel="noopener" href="https://seanxp.com/2019/05/go-module-note/">Go Module Notes</a>， 要理解顶层依赖和间接依赖，replace只能替换顶层依赖。也就是说自己的业务代码引用了A包，被替换成了B包，这是可以的。但是如果是引用的A包和B包，A包又引用了B包，那么A包引用的那个B包是间接依赖，go.mod的replace是不能替换的，这也是站在A包的角度考虑。</p>
<h2 id="10-断言"><a href="#10-断言" class="headerlink" title="10. 断言"></a>10. 断言</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> foo1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> foo2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	B <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = &amp;foo1&#123;A: <span class="number">1</span>&#125;</span><br><span class="line">	aa := a.(*foo2)</span><br><span class="line">	<span class="comment">// aa, ok := a.(*foo2)</span></span><br><span class="line">	<span class="comment">// if ok &#123;</span></span><br><span class="line">	<span class="comment">// 	fmt.Print(aa)</span></span><br><span class="line">	<span class="comment">// 	return</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	fmt.Print(aa)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有返回ok的判定，那么就不会引起panic，因此断言最好是加上ok的处理。</p>
<h2 id="11-map"><a href="#11-map" class="headerlink" title="11. map"></a>11. map</h2><p>下面的代码是不会崩溃的，尽管map的默认初始化是nil。但是如果对<code>b[&quot;test&quot;]</code>赋值才会panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">	fmt.Println(b[<span class="string">&quot;test&quot;</span>] )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/06/golang%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/" data-id="cl0t1dd10004l8slfehwh03nl" data-title="golang语言笔记" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-mit6-824-lab2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/02/mit6-824-lab2/" class="article-date">
  <time class="dt-published" datetime="2020-12-02T05:07:50.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mit6-824/">mit6.824</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/02/mit6-824-lab2/">mit6.824-lab2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>任何一个goroutine都需要有return的逻辑，也就是先保存好这个goroutine开启时的raft term和state，一旦检测到raft的即时term和state不符合开启时保存的term和state，立即结束该goroutine的逻辑操作，return。这样一来可以防止不符合条件的raft执行过期的操作，二来也防止goroutine泄漏，一直在执行。</li>
<li>对于锁来讲，最方便的方式是对一个逻辑从头锁到尾。但是要注意不要锁住耗时操作，比如rpc请求就需要放入goroutine里等等。被锁分开的上下的临界区，应该要立即检查状态是否变更。</li>
<li>在unreliable network背景下，不能假设rpc 请求的先后顺序，以及reply抵达的先后顺序。考虑一个情况：<br> A. Leader A在接收到LogEntry1时发送复制请求1，然后又接收到LogEntry2，再次发送复制请求2。<br> B. 复制请求2先于1到达，由于请求1还没有成功返回，所以复制请求2会带上1的logEntry。follower也会复制所有的logEntry，请求2完成后follower的log已经是最新的了，但是此时，请求1到达了，如果只是简单地比较term等复制的话，log反而会回退。<br> C. 上述引起的后果是<br> a. Leader的commitIndex可能会偏高，因为它已经收到了大部分日志复制请求成功的reply，但实际上有一些follower回退了。<br> b. 此时如果有人竞选，一定情况下可能会导致日志不是那么新的peer成功竞选，从而覆盖掉了已经被commit的logEntry。<br> D. 为了避免这个问题：不能让老的日志请求更新log<br> a. Follower处理日志复制请求的时候，直接一个个地比对，遇上不匹配的（下标一致，term不一致等），就截断，开始复制替换，否则不会替换截断。</li>
<li>如果reply可以知道该请求复制完成后有多少个log（XLen），是否可以直接更新NextIndex？<br> A. 如果我们复制日志的时候确定就是Follower多的log都截掉。<br> B. 遇上heartbeat请求，没有带LogEntry，但是又匹配上了prevLogIndex和prevLogTerm，此时会直接截断掉prevLogIndex后面的log吗？应该要分开来处理吗？</li>
<li>为什么raft的nextIndex需要用args.PrevLogIndex+len(args.LogEntries)？ note上说如果state变化了，就会有问题，但是变化了state，就不会再用到nextIndex了。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/mit6-824-lab2/" data-id="cl0t1ddcb005h8slf2id92f3x" data-title="mit6.824-lab2" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/distributed/" rel="tag">distributed</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/raft/" rel="tag">raft</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-mit6-824-guide" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/10/mit6-824-guide/" class="article-date">
  <time class="dt-published" datetime="2020-11-10T07:26:26.000Z" itemprop="datePublished">2020-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mit6-824/">mit6.824</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/10/mit6-824-guide/">mit6.824-guide</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文主要是对<a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/instructors-guide-to-raft/">Instructors’ Guide to Raft</a>的总结。</p>
<ol>
<li><p>heartbeat RPCs不是一个特殊的RPC，它也是AppendEntry，只是携带的Log为空。也就是说，对AppendEntry请求的一些检查，对heartbeat也要有。比如term的比较，比如prevLogIndex等等，甚至也需要更新自身和leader的commitIndex。</p>
</li>
<li><p>AppendEntry不应该是简单的比对完prevLogIndex后发现没有冲突，就把Log append到prevLogIndex后面，而是要仔细比对，直到出现有冲突的log，才进行数据的修改。删掉该index及往后的log。这样做的原因是AppendEntry可能有旧的RPC晚到，直接append会导致LOG反而变短了，那么就可能导致commit后的Log并没有出现在大部分的服务器中。</p>
</li>
<li><p>出现LiveLocks的常见情况是，集群不停地在选举，但是没有leader选出来，或者刚选出来又有新的candidate要竞选。有一个常见原因是reset election timer的时机不对，只有三个情况要reset</p>
<ol>
<li>从当前的leader收到了AppendEntry请求，也就是args.term要等于自己的currentTerm。</li>
<li>自身开始了竞选，也就是在竞选函数最开始就可以reset了。</li>
<li>给别的peer投了一票，也就是在检查了日志是否是最新的，检查了term等等，可以给该candidate投票的时候才reset，而不是一收到RPC就reset。</li>
</ol>
<p>reset election timer的时机越多，选举成功的概率就越小，因为发起竞选的概率变小。所以思路一定是让日志更多更“新”的peer快速发起竞选成为leader。</p>
</li>
<li><p>选举过程中election timeout了，应该自增一个term，开启另一个新的竞选，尽量赶紧结束当前term的竞选。因为有可能有一些丢弃的rpc返回，或者网络延时，不能让raft服务器一直卡在一个流程里。</p>
</li>
<li><p>一旦遇到term比自身currentTerm大的request或者response，立马回滚为follower，更新currentTerm，然后再做别的操作。比如收到一个term大于自己的voteRequest，那么应该是将自己立即回滚为follower然后再继续处理这个request，看是否需要投票。</p>
</li>
<li><p>如果有一个操作足以能够确定reply false，那么就立即返回，不要再往下走了，一来可以尽早释放抢占的锁；二来可以防止多余的操作会修改一些共享变量。</p>
</li>
<li><p>如果你收到了一个prevLogIndex比自身的日志最大下标还要大的AppendEntry RPC，和term不匹配一样的处理，也是返回false。当然还可以再增加一些字段让log的回溯更加快速。</p>
</li>
<li><p>commitIndex&#x3D;min（leaderCommitIndex，log当前的最大下标）。</p>
</li>
<li><p>比较日志的新旧标准：先比log的长度，更长的更新；一样长的比较最后一个logEntyr的term，更大的更新。</p>
</li>
<li><p>任何时候都要保证commitIndex要大于lastApplied</p>
</li>
<li><p>当leader的appendEntry收到的rpc回复是false，而不是因为log不匹配的时候（一般是因为term已经过期了）回退为follower但是最好不要再更改nextIndex了，因为很有可能你立马开始重新选举，就会造成竞争。</p>
</li>
</ol>
<h2 id="debug的建议"><a href="#debug的建议" class="headerlink" title="debug的建议"></a>debug的建议</h2><ol>
<li>使用awk过滤日志</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;/.*(kv\[2\]|raft\[2\]).+/&#123;print&#125;&#x27; log.txt &gt;log_2.txt</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ctrl+\打印goroutine堆栈查看死锁</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/10/mit6-824-guide/" data-id="cl0t1ddca005d8slf9buy7uex" data-title="mit6.824-guide" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/raft/" rel="tag">raft</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-mit6-824-lab3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/10/mit6-824-lab3/" class="article-date">
  <time class="dt-published" datetime="2020-11-10T02:59:32.000Z" itemprop="datePublished">2020-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mit6-824/">mit6.824</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/10/mit6-824-lab3/">mit6.824-lab3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-实验概述"><a href="#1-实验概述" class="headerlink" title="1. 实验概述"></a>1. 实验概述</h2><p>lab3开始了raft的应用部分，主要是写一个简单的分布式存储数据库，其数据主要是存储在各个kvserver的内存map中。lab3A要完成的是Put，Append和Get功能，lab3B要完成的是数据快照及日志压缩的逻辑。</p>
<h2 id="2-lab3A"><a href="#2-lab3A" class="headerlink" title="2. lab3A"></a>2. lab3A</h2><h2 id="2-1-从client一次请求全流程"><a href="#2-1-从client一次请求全流程" class="headerlink" title="2.1 从client一次请求全流程"></a>2.1 从client一次请求全流程</h2><ol>
<li>client向server发起请求；</li>
<li>如果该server对应的raft状态机不是leader，就直接返回WrongLeader错误给client；</li>
<li>如果该server对应的raft状态机是leader状态，就接收这个请求，将其写入自己的logs里，然后进行同步，等该raft commit；</li>
<li>等到raft把该logEntry送入applyCh的时候，server会收到该logEntry一一执行（也就是给本地map做一些增删改查的操作），然后再把结果返回给client。</li>
</ol>
<h2 id="2-2-几个核心问题"><a href="#2-2-几个核心问题" class="headerlink" title="2.2 几个核心问题"></a>2.2 几个核心问题</h2><ol>
<li>client对server的请求是直接从0开始轮循，如果请求返回WrongLeader，则直接+1下一个；</li>
<li>所有的请求都需要被commit，然后从applyCh里获取到执行了，才能返回给client；</li>
<li>要考虑网络的不可靠性。比如rpc请求发送了也执行了，但是返回时失败了。那么client一定时间内没收到response的策略肯定是重试，那么此时server要保证一次请求的幂等性。不能让命令重复操作。策略是：因为我们保证client是单线程的，那么一个请求没有完成是不会再请求另一个的。所以可以给每一个client的每一个不同的request指定一个自增id，在kvserver端去检查是否已经执行了。</li>
<li>因为从接收到请求到获取到结果实际上是异步操作，那么要如何通知到接收请求的函数该请求已经执行完毕可以返回结果了呢？策略是：比较容易想到的是对于每一个从applyCh里接收到的logEntry，它在raft集群里的log index是确定且唯一的，那么可以对每一个log index创建一个channel用于server内部response的接收和发送。但有一个风险点：logA请求从start函数获取到了index，创建了channel，但是最后这个log commit失败了，该index被别的logB请求覆盖掉了，那么此时可能有两个地方在读取这个channel，但只有一个地方写，并且只会写一个。这种方法不好保证写入channel的数据会被正确的logB请求读取到，那么就会产生错误的返回。一个解决办法是，从channel中读取到response的时候，检查一下是否是自己的请求回应，如果不是，重新写回channel以供别的channel去读。</li>
<li>对于一个请求，如何确定它？ 用clientID+seq</li>
<li>TestBasic3A和TestConcurrent3A比较好解决，就是按照说明来，也不需要给去重；记得给本地存储data的map的读写加锁就好</li>
<li>TestUnreliable3A这个实验引入了网络的不稳定，raft的不稳定可以不管，lab2已经解决了，这里的不稳定有两个地方：a.底层raft随时有可能重新选举，更改了leader，那么发送给了old term leader的logEntry要怎么处理？b.上层client的调用会出现超时错误，这里有处理逻辑吗？<br>A. 看一下labrpc.go代码就知道，unreliable的影响有两个，一个是request没有发出去，一个是发出去了，对raft等有作用了，但没有收到状态为ok的reply的。<br>B. 这里就需要我们注意不要重复apply 相同的logEntry。这个检测是在commit阶段做呢还是在apply LogEntry阶段去做呢？ 如果不做重复检验，直接start，最后在apply的时候检验重复，会造成Log的冗余，但如果在commit阶段就做，可能有一个request没有commit成功，但是因为已经被提交过了，所以不会再次被提交。</li>
<li>有一个要注意的是，不能在LogEntry apply了以后，才去申请锁，然后去读data map，这样是不符合线性逻辑的。因为get如果比put早提交，就应该只读到put操作以前的数据，但是这里申请锁去读data map很有可能已经执行了别的put操作了。</li>
<li>如何维护一份数据，记录已经执行过的seq的client命令？<br>A. 最暴力的是保存一份map，记录下每一个seq命令是否执行。<br>B. 只记录当前最大的seq，这是建立在同一个clerk只会被串行执行命令的假设下。（论文里是这样假设的）</li>
<li>Linearizable的含义：并发的请求与获得response之间的时间差内，能够观察到的数据结果都是ok的。所以尽管一个Get先执行，但是获取到的是后执行的put命令执行完的结果，这也是ok的。</li>
<li>关于超时错误，一般来讲是因为发送的leader过期了迟迟没有commit，因此最好也是继续轮询，而不是重试。</li>
<li>关于snapshot，需要存储raft的state防止宕机重启后可以恢复，另一方面也要存储kvserver的data数据，从而可以压缩log，防止占用的内存无限扩大。</li>
</ol>
<h2 id="3-lab3B"><a href="#3-lab3B" class="headerlink" title="3. lab3B"></a>3. lab3B</h2><p>快照功能是为了解决log太长的问题。有两个线索，第一个是对于每一个raft来讲，他要独立地进行快照，裁剪log。第二个是当leader发现某个followe的log落后太多（nextIndex比lastIncludeIndex还要小），那么先不发AppendEntry RPC，而是发送InstallSnapshot RPC。</p>
<h2 id="3-1-几个核心问题"><a href="#3-1-几个核心问题" class="headerlink" title="3.1 几个核心问题"></a>3.1 几个核心问题</h2><ol>
<li>什么时候检测log的大小？</li>
<li>appendEntry时如果prevLog对不上要快速回退，这里就会有一个问题，如果follower的LastIncludeIndex比较小，那么leader去取的时候是会取不到的，这个时候的策略应该是不要管follower的reply传过来的，因为说明此时follower的log已经过期很久了，lastIncludeIndex追不上了。</li>
<li>有一个错误是applyChan要做成缓冲的，否则只要kv去压缩快照就会要获取rf的锁，但是rf再applyLog处会抢到锁然后卡住，最后会形成死锁。一个宗旨还是，不要用锁去锁耗时阻塞操作。</li>
<li>InstallSanpshot的RPC调用也需要一系列的判断，比如term比如是否是最新的（通过比较LastInclude和LastApplied等等）</li>
<li>raft存储当前状态的时候也要存储LastIncludIndex和LastIncludeTerm。</li>
<li>如何去提醒server提交的log已经被apply了，有几种方式<br>A. Server的请求不断去轮训raft的lastappliedIndex，等到比自己的收到的index大的时候，比较一下该log与自己提交的是不是一致，然后就可以判断了。缺点是需要系统对lastAppliedIndex会多了很多读写，而这个读写是加锁的，这就会造成系统效率不高。<br>B. 整个server维护一个map[index]chan，对于每一个提交的log的index都有一个chan去写协作，applyLog以后就往对应的index里发送一条消息，而server端会阻塞在读这条消息。但有一个问题是，如果我有两个client发送消息，A提交log获取到的index是10，但是这条消息没有被commit，紧接着Client-B也提交了一个log，获得的index也是10，此时该server的raft执行下标为10的log，给chan发送消息，A先收到，会导致A去检查发现不符合，B一直收不到请求，但是其实已经成功了。有一种解决办法是，引入超时机制，然后呢，再加入重复检测，在apply阶段遇到了已经执行过的seq就不再执行，直接返回，给chan写通知。<br>C. 如果直接在command里加一份chan，作为apply结果的返回channel，有一个问题是，其实每一个index理论上只有一个读，但是apply会有很多个写，因为follower也需要apply log，但只有leader需要读chan。</li>
<li>各司其职：由于请求是kvserver传向raft，因此只能在kvserver里检测log是否太大；logSize超过了以后，将kvserver的data结果序列化发送给raft，再由raft去持久化.</li>
<li>活锁问题：</li>
</ol>
<ul>
<li>现象：TestSnapshotRecover3B的测试有时候会出现两个raft轮流竞选leader，没有其余raft的log打印。这个问题的根源应该在于另外3个raft被锁住了没有进展也接收不了投票请求，从而导致没锁的两个开始疯狂竞选。仔细观察日志，发现另外三个在最后的Get操作前有一次snapshot操作。首先，我们调用start，然后appendLogEntry会拿到一个raft的锁，然后在释放前要执行完applyMsg的逻辑。而applyMsg的逻辑里有和kvserver交互的，如果此时kvserver检查发现需要snapshot后，就会让raft执行snapshot，而这个snapshot也需要raft的锁。此时就锁住了。<br>• 所以还是一个原则，有任何耗时操作都要注意，是否应该放入锁中。无论是rpc调用还是对外部系统的请求；<br>• 其二是对于并发请求的变量，要时刻注意锁带来的原子性。比如getAgreeCh哪里。</li>
<li>因此，这个applyMsg需要开协程完成。但又要注意apply如果开协程，那么执行时的状态和当时调用applyMsg的状态不一致了，很有可能导致重复执行。因此要把当时的状态传进去，然后里面再加一个锁来看。</li>
<li>如果对snapshot开启goroutine，很容易造成一种现象就是，</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/10/mit6-824-lab3/" data-id="cl0t1ddce00688slf6u3t4v9h" data-title="mit6.824-lab3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/distributed/" rel="tag">distributed</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/raft/" rel="tag">raft</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-经典算法-快慢指针" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/07/31/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" class="article-date">
  <time class="dt-published" datetime="2019-07-31T12:16:48.000Z" itemprop="datePublished">2019-07-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E5%AE%9D%E5%85%B8/">面试算法宝典</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/07/31/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/">经典算法-快慢指针</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>原题1:<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a><br>原题2:<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">42. 环形链表 II</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li><p>首先这里介绍一个快慢指针的奇淫巧计，专门用来检测链表是否有环。对于一个有序序列，设置两个指针，慢指针一次走1步，快指针一次走2步，那么如果快指针每次都多走一步，如果存在环的话就一定会追上慢指针。原题1就完全可以用这个解出来。</p>
</li>
<li><p>原题2的难度增加在，你除了要知道有没有环，还要知道是在第几个节点上形成的环。仔细思考一下，上面的算法在快慢指针相遇的时候可以得出什么结论？</p>
<ul>
<li>如果慢针走了n步，那么快针就走了2*n步；</li>
<li>快针会比慢针整整多走t圈环形链表。</li>
<li>因此2n-n就是环形链表的节点数；</li>
</ul>
</li>
</ul>
<h2 id="练练手"><a href="#练练手" class="headerlink" title="练练手"></a>练练手</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a> </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/byrhuangqiang/p/4708608.html">Leetcode解题思想总结篇：双指针</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/07/31/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" data-id="cl0t1dd0p003v8slf64tdfurz" data-title="经典算法-快慢指针" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algroithm/" rel="tag">Algroithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mit6-824/">mit6.824</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/quant%E9%9D%A2%E8%AF%95%E7%BA%A2%E5%AE%9D%E4%B9%A6/">quant面试红宝书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">数据结构笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E5%AE%9D%E5%85%B8/">面试算法宝典</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APUE/" rel="tag">APUE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algroithm/" rel="tag">Algroithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/I-O/" rel="tag">I&#x2F;O</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pprof/" rel="tag">Pprof</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test/" rel="tag">Test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/" rel="tag">code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/distributed/" rel="tag">distributed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gc/" rel="tag">gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lock-free/" rel="tag">lock-free</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quant-interview/" rel="tag">quant interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raft/" rel="tag">raft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ucore/" rel="tag">ucore</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/APUE/" style="font-size: 10px;">APUE</a> <a href="/tags/Algroithm/" style="font-size: 18.57px;">Algroithm</a> <a href="/tags/CSAPP/" style="font-size: 20px;">CSAPP</a> <a href="/tags/Golang/" style="font-size: 15.71px;">Golang</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/I-O/" style="font-size: 10px;">I/O</a> <a href="/tags/Leetcode/" style="font-size: 18.57px;">Leetcode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a> <a href="/tags/OS/" style="font-size: 15.71px;">OS</a> <a href="/tags/Pprof/" style="font-size: 10px;">Pprof</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/code/" style="font-size: 10px;">code</a> <a href="/tags/distributed/" style="font-size: 11.43px;">distributed</a> <a href="/tags/gc/" style="font-size: 10px;">gc</a> <a href="/tags/golang/" style="font-size: 12.86px;">golang</a> <a href="/tags/k8s/" style="font-size: 10px;">k8s</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/lock-free/" style="font-size: 10px;">lock-free</a> <a href="/tags/quant-interview/" style="font-size: 14.29px;">quant interview</a> <a href="/tags/raft/" style="font-size: 12.86px;">raft</a> <a href="/tags/ucore/" style="font-size: 17.14px;">ucore</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 12.86px;">双指针</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18.57px;">算法</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 11.43px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/12/csapp-ch3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/05/%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/02/08/%E7%AC%94%E8%AE%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/26/Prometheus-Histograms-Observation%E7%9A%84%E6%97%A0%E9%94%81%E5%AE%9E%E7%8E%B0/">Prometheus Histograms Observation的无锁实现</a>
          </li>
        
          <li>
            <a href="/2021/08/09/k8s%E5%AE%9E%E6%93%8D%E7%AC%94%E8%AE%B0/">k8s实操笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Husy<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>