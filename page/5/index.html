<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://husy-dev.github.io/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Husy">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://husy-dev.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-【CSAPP】Ch11-网络编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/24/%E3%80%90CSAPP%E3%80%91Ch11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2018-03-24T03:26:43.000Z" itemprop="datePublished">2018-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/24/%E3%80%90CSAPP%E3%80%91Ch11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">【CSAPP】Ch11-网络编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>网络服务的提供模型有一个最典型的就是服务器-客户端编程模型。这个不多说，然后是一系列的网络知识，局域网，IP地址这些。具体到我们的操作系统，我们其实主要是要了解：</p>
<ol>
<li>概念：MIME、HTTP&#x2F;1.0 GET requests（请求行，请求报头，请求方法等），HTTP&#x2F;1.0 Response（响应行、响应报头、响应主体、状态码等），CGI。</li>
<li>数据结构：记录IP地址的数据结构，以及其对应的域名数据结构。</li>
<li>网络连接的机制就是通过套接字（更底层的暂时别去管）记住下面的框架：<br><img src="http://static.zybuluo.com/Husy/1gffhb86su7dt9gwxazrbu94/Screenshot%20from%202018-07-25%2012-35-56.png" alt="unix套接字框架"></li>
</ol>
<p>所以其实最朴素的编程内容无非就是：</p>
<ol>
<li>建立链接</li>
<li>解析请求</li>
</ol>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol>
<li>unix系统最简单的signal函数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signo, <span class="type">void</span> (*func)(<span class="type">int</span>))) (<span class="type">int</span>);</span><br><span class="line"><span class="comment">//备注</span></span><br><span class="line">using F = <span class="type">int</span>(<span class="type">int</span>*, <span class="type">int</span>);<span class="comment">//这是一个函数类型</span></span><br><span class="line">using PF = <span class="type">int</span>(\*)(<span class="type">int</span>\*, <span class="type">int</span>);<span class="comment">//这是一个函数指针的类型。</span></span><br><span class="line"><span class="comment">//于是signal其实可以这么看</span></span><br><span class="line">using A = <span class="type">void</span>(*func)(<span class="type">int</span>)</span><br><span class="line">using B = <span class="type">void</span> (*signal) (<span class="type">int</span> signo,A)</span><br><span class="line">using C = B (<span class="type">int</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>所以首先，C是一个函数，返回值是一个函数指针，参数是一个int类型。而返回的函数指针的参数又是一个函数指针。而我们要写一个信号处理函数就可以是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后在在接受信号比如SIGCHLD的函数里写下这个,</span></span><br><span class="line">signal(SIGCHLD, handler);</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>##家庭作业<br>11.6 A：Rio_readlineb里解析了请求行，read_requesthdrs里解析请求报头。在这两处的读操作后，立马跟一个<code>Rio_writen(rp-&gt;rio_fd, buf, strlen(buf));</code><br>B：由于A的关系，输出就是请求头。当在浏览器里输入：localhost:1234时，输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Accepted connection from (localhost, 40620)</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: localhost:1234</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-HK;q=0.7,ja-JP;q=0.6,ja;q=0.5</span><br></pre></td></tr></table></figure>
<p>因为此时并没有默认的网页返回，因此没有Response headers。<br>当在浏览器里输入：localhost:1234&#x2F;index.html时，输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Accepted connection from (localhost, 40632)</span><br><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: localhost:1234</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-HK;q=0.7,ja-JP;q=0.6,ja;q=0.5</span><br><span class="line"></span><br><span class="line">Response headers:</span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Server: Tiny Web Server</span><br><span class="line">Connection: close</span><br><span class="line">Content-length: 36</span><br><span class="line">Content-type: text/html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先，端口号变了。虽然我浏览器一直开着，但是由于是重新连接，所以其实是一个新的端口。<br>C：浏览器版本就是user-Agent的内容<code>Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36</code><br>D：<a target="_blank" rel="noopener" href="http://www.infoq.com/cn/news/2014/06/http-11-updated">详情参考</a></p>
<p>11.7 提供视频文件. 这是一个静态的请求，那么我们从serve_static去添加。首先修改get_filetype里没有解析视频文件后缀的文件类型，比如我们这里解析视频文件的后缀为*.mp4<br>要注意的是content-type并不是严格按照文件的后缀来决定的，具体的要在官网里查，可以参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME 类型</a>，但是有问题。</p>
<p>11.8 就是写一个处理处理函数，等得到SIGCHLD的信号以后再调用wait，这样父进程就不会被阻塞。</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol>
<li>如果请求一张图片，可以直接读取写入内存，然后rio_writen写到客户端，但是如果我请求一个视频，那么视频会直接下载而不是展示在浏览器页面中，为什么会有这种区别？如果返回给浏览器的responese里的content-type告诉你如何解析返回的主体，那么将content-type设置成video&#x2F;mp4应该能够直接解析成mp4格式展示在页面里才对。</li>
</ol>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/sunyongjian/blog/issues/34">从浏览器输入一个 url 到页面渲染，涉及的知识点及优化点</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/03/24/%E3%80%90CSAPP%E3%80%91Ch11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-id="cl0t1dcyj00128slf8sesce3g" data-title="【CSAPP】Ch11-网络编程" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【CSAPP】Ch10-系统IO" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/24/%E3%80%90CSAPP%E3%80%91Ch10-%E7%B3%BB%E7%BB%9FIO/" class="article-date">
  <time class="dt-published" datetime="2018-03-24T03:26:08.000Z" itemprop="datePublished">2018-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/24/%E3%80%90CSAPP%E3%80%91Ch10-%E7%B3%BB%E7%BB%9FIO/">【CSAPP】Ch10-系统IO</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>系统I&#x2F;O是指主存和外部设备之间复制数据的机制，它的重点就在于一个缓冲机制和描述符机制。</p>
<ol>
<li>描述符机制参考下面的图，这就是整个逻辑，包括共享文件，重定向I&#x2F;O都是由此展开。<br><img src="http://static.zybuluo.com/Husy/fcg1ynb3a67zm9vd9cvsyxps/Screenshot%20from%202018-07-23%2011-43-35.png" alt="文件I/O"></li>
</ol>
<ul>
<li>要注意的是，linux里一切皆文件。因此这里不仅仅指从磁盘读取传统的文件，也包括从网络接口读取数据等</li>
</ul>
<ol start="2">
<li>缓冲机制：考虑到从外存读取数据开销大，且速度慢。因此考虑使用缓存使得读取效率高一点。</li>
</ol>
<ul>
<li>unix提供的系统调用是没有缓存的，C标准库的有缓存。</li>
<li>缓冲机制有：全缓冲（磁盘I&#x2F;O）、行缓冲（收到一个换行符就输出）、无缓冲（错误输出）</li>
</ul>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol>
<li>RIO I&#x2F;O比Unix I&#x2F;O多做了一些什么？<br> 当直接用Unix I&#x2F;O的时候，如果读写被中断，读写就中断了，会返回一个错误EINTR,也不管有没有读完。这就很尴尬，因为我们程序并没有问题，中断完了以后我们其实可以继续读写。于是就有了RIO I&#x2F;O.它引入一个rio_t的结构，帮我们检测是否有读完，没有读完就算遇上了EINTR错误也继续读。 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/wzzkaifa/p/7281005.html">参考</a></li>
<li>RIO包里就包含6个函数：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无缓冲</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有缓冲</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">//有缓冲内部实现函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_read</span><span class="params">(<span class="type">rio_t</span> *rp,<span class="type">void</span>* userbuf,<span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>
为什么有缓冲里没有write相关的函数呢？因为write不需要缓冲。<a target="_blank" rel="noopener" href="http://www.cnblogs.com/wzzkaifa/p/7281005.html">同样参考</a></li>
</ol>
<ul>
<li>我们讲Unix I&#x2F;O没有缓存，这个是针对应用层面来讲的。它和标准库的区别是，标准库每次调用读写不一定会产生系统调用，而Unix I&#x2F;O则一定会产生系统调用。参考<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-directio/">Linux 中直接 I&#x2F;O 机制的介绍</a>和 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23349599">知乎问答</a></li>
</ul>
<ol start="3">
<li><p>子进程会复制父进程的缓冲区。可以思考一下这个实验<a target="_blank" rel="noopener" href="https://blog.csdn.net/damotiansheng/article/details/51992231">缓冲区问题：子进程会复制父进程的缓冲区</a></p>
</li>
<li><p>标准I&#x2F;O的限制：输入函数之后不能紧跟输出函数，输出函数之后也不能紧跟输入函数</p>
<ul>
<li>因为标准I&#x2F;O的缓冲区是共用的，比如当前fread操作把缓冲区填满了，文件位置的指针也会偏移一个缓冲区。 然后再立即使用fwrite操作，而此时的缓冲区还有读操作的内容，那么很有可能写操作会把缓冲区读操作的内容写入文件夹。</li>
<li>但是我们可以在中间穿插rewind，fseek，fflush等更新缓冲或者重定义文件位置来处理这种矛盾。但是对于套接字文件，由于我们不能使用lseek，从而就做不到这些了。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/03/24/%E3%80%90CSAPP%E3%80%91Ch10-%E7%B3%BB%E7%BB%9FIO/" data-id="cl0t1dcyi00118slfgxt3bz6g" data-title="【CSAPP】Ch10-系统IO" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/I-O/" rel="tag">I&#x2F;O</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【CSAPP】Ch9-虚拟内存" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/24/%E3%80%90CSAPP%E3%80%91Ch9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" class="article-date">
  <time class="dt-published" datetime="2018-03-24T03:25:24.000Z" itemprop="datePublished">2018-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/24/%E3%80%90CSAPP%E3%80%91Ch9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">【CSAPP】Ch9-虚拟内存</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ol>
<li><strong>MMU</strong>（Memory Management Unit）内存管理单元，在CPU芯片上，由硬件和OS一起合作处理，用于转换虚拟地址和物理地址。</li>
<li><strong>地址空间</strong>：通俗来讲就是给内存的每一个字节命名，从0开始，1，2，3，4······M。一般来说这个M是2的幂。如果M&#x3D;2<sup>n</sup>，则这是一个n位的地址空间。</li>
<li><strong>虚拟内存</strong>：套用缓存的思想，内存的上一级是L1，L2，那么下一级就是磁盘。虚拟内存就是磁盘上一组连续的字节。当内存没有命中时，就往虚拟内存也就是磁盘上找，并且进行<strong>交换（swapping）</strong>，也就是磁盘和内存之间的传送页的活动。</li>
<li>考虑到磁盘的局部性以及读取特征（读一个扇区的一个字节和读一个完整的扇区开销要大非常多），因此一般不用字节来作为分配单位，而是用页。虚拟内存（也就是磁盘）上的分割为2<sup>p</sup>字节的<strong>虚拟页</strong>（virtual page），物理内存被分割为若干个<strong>物理页</strong>（physical page），大小也为2<sup>p</sup>字节。</li>
<li><strong>DRAM</strong>：为了以示区分，SRAM用来表示CPU和L1，L2还有内存之间的高速缓存。DRAM则用来表示内存和磁盘之间的低速缓存。既然是低速，不命中的惩罚是非常大的，因此其设计要比SRAM精妙复杂。</li>
<li><strong>页表（page table）</strong>： 辅助MMU来记录当前DRAM缓存情况的常驻内存的数据结构（PTE的数组）。OS来维护这个页表供MMU来读取。</li>
<li><strong>PTE（page table entry</strong>是由一个valid bit（用于当前虚拟地址是否已经缓存），后面跟着物理页号或者磁盘地址，还有一些许可位（用于进程间内存保护）。负责告诉MMU当前虚拟地址的权限（只读只写等等）和上哪去获取（物理内存还是磁盘）。</li>
<li><strong>分配页面</strong>的具体含义是，当我们的程序使用malloc等指令申请内存时，OS会给该程序分配一个虚拟内存，然后更新PT，然后会根据<strong>局部性（locality）</strong>将其同时缓存进物理内存中。</li>
<li><strong>内存映射（memory mapping）</strong>：内核将虚拟内存和一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的过程。</li>
<li><strong>抖动（thrashing）</strong>时间局部性不好时，DRAM会发生频繁地页面交换的现象。因为虚拟内存的页面调度方式的核心思想就是时间局限性，在一段时间内，OS一般会集中运行一个或几个固定的程序，因此程序可以在一个较小的活动页面（active page）集合上工作。</li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    有了OS后，进程之间会共享CPU和内存资源。如果直接用物理内存地址（也就是真实的地址），那么每一个进程的处理都需要小心设计，因为很容易内存溢出，彼此影响。为了更好地管理进程和简化进程对内存的使用，提出了一个虚拟内存（VM）的概念：</p>
<ol>
<li>为每一个进程提供一致的地址空间，简化内存管理；</li>
<li>保护进程地址空间不会被其它进程破坏；</li>
<li>在内存中只保留当前活跃的数据，其余的换入磁盘中，增加内存的使用效率。</li>
</ol>
<p>针对上面三点，下面会分别详细说明。</p>
<h3 id="作为缓存机制"><a href="#作为缓存机制" class="headerlink" title="作为缓存机制"></a>作为缓存机制</h3><p>​    出发点是内存很贵，但是我们要运行的程序又大又多，全加载进内存呢，肯定不够，因此引入缓存机制，尽量让加载进内存的都是活动页面，也就是程序经常要读写的内存数据。</p>
<p>​    缓存的设计思路无非就是如何判断是否命中以及未命中如何替换。MMU在转化虚拟地址到物理地址时，会去读取页表中对应的PTE，其valid bit为等于1时就说明该地址命中了缓存，可以直接去读取物理内存。若等于0则未命中（也叫缺页），需要将缓存里的虚拟页面的数据替换磁盘里的物理页的数据，同时修改对应的PTE。</p>
<p>​    另一个内容是分配内存，程序使用malloc向OS申请内存时，就会先去虚拟地址空间里（也就是磁盘里）开辟一个页面，然后将对应的PTE的内容修改为已分配（也就是valid bit依旧为0，但是后面保存的地址数据为磁盘地址，而不是Null）。</p>
<p>​    至此，这就是缓存的全部逻辑，具体的实现细节，比如如何选择需要交换出去的物理内存？会根据操作系统和硬件的不同而有细微不同。    </p>
<h3 id="作为内存管理工具"><a href="#作为内存管理工具" class="headerlink" title="作为内存管理工具"></a>作为内存管理工具</h3><p>​    其核心设计就是OS为每一个<strong>进程</strong>（重点！这就是为什么说进程的内存空间是独立的原因！）提供了一个独立的页表，因为也是一个独立的虚拟地址空间，于是每一个进程的虚拟地址可以相同，但通过页表转换成不同的物理地址。当然，不同的进程的虚拟地址也可以最终映射为同一个物理地址（也就是共享内存）。</p>
<p>​    上述设计的好处自然不乏多说：</p>
<ol>
<li>它使得每一个进程有自己独立和统一格式的内存空间，不用管具体的最终的真实内存地址，简化了程序编译时链接和程序加载的逻辑。</li>
<li>另一方面，增加一层虚拟地址到物理地址的转换，在申请连续的虚拟地址的时候并不需要真实连续的物理地址，这就简化了内存分配的逻辑。</li>
<li>而顺带的，这个设计还可以很好地支持共享内存机制，通过页表转化，将不同进程的虚拟地址转化为相同的物理地址，使得一些底层动态库和内核代码可以被多个进程调用而只需要加载一份在物理内存中。</li>
</ol>
<h3 id="作为内存保护工具"><a href="#作为内存保护工具" class="headerlink" title="作为内存保护工具"></a>作为内存保护工具</h3><p>​    页表中的PTE除了告诉MMU如何去获取对应物理地址的数据以外，还可以扩展一些许可位来控制每一个物理页面的访问权限。比如SUP权限位代表是否要运行在内核模式下才能访问，READ和WRITE显而易见，表示可读或可写。当有进程违反了这些许可条件，CPU就会触发异常处理程序，一般是直接退出进程并报告为“段错误（segementation fault）”。</p>
<p>​    上述的保护的意义在于保护内核代码不受应用进程的修改，而进程与进程之间的内存溢出保护，则依赖于上述内存管理机制，每个进程是独立的虚拟地址空间，自然无法访问别的进程的数据。</p>
<h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>​    <em>注：这一部分可以跳过，只是为了说明各个<strong>硬件</strong>在缓存机制中的角色稍稍深入了一些地址翻译的细节，表明虚拟内存的实现是依赖硬件和软件的紧密协作，但对于真实的实现依旧是很粗陋的。</em></p>
<p>​    上面三个从整体上说明了虚拟内存的功能和机制，但是对于虚拟地址转化为物理地址这一个部分还是一个黑盒，这一部分说明一下虚拟地址是如何转化成物理地址的，和高速缓存SRAM结合的逻辑和一些优化的方式，比如TLB（translation Lookaside Buffer）。</p>
<h2 id="linux的虚拟内存系统"><a href="#linux的虚拟内存系统" class="headerlink" title="linux的虚拟内存系统"></a>linux的虚拟内存系统</h2><p>![一个linux进程的虚拟内存](&#x2F;Users&#x2F;husyhu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20201227180601015.png)</p>
<p>​    如图所示，一个linux进程分为内核虚拟内存和进程虚拟内存，程序加载到执行的各个段的意义可以参考<a href="">ch7-链接7.9加载可执行目标文件</a>。</p>
<p>![Linux是如何组织虚拟内存的](&#x2F;Users&#x2F;husyhu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20201227182404627.png)</p>
<p>​    这里的task_struct就是内核为一个进程维护的任务结构，其中包含了内核运行该进程所需要的信息（比如PID，程序计数器等等）。其中mm_struct用来描述虚拟内存的当前状态，pgd指向第一级页表基址；mmap是一个指向vm_area_structs的链表。</p>
<h3 id="缺页异常处理"><a href="#缺页异常处理" class="headerlink" title="缺页异常处理"></a>缺页异常处理</h3><p>缺页异常处理程序：1. 判断是否是是在可以访问的虚拟地址空间范围，否则报段错误；2. 是否符合对应页表项的访问限制（也就是上述vm_prot里的要求），否则报保护异常；3. 最后才能判断这次缺页异常是正常缺页，内核选择一个牺牲的虚拟页，交换出去。</p>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>​    <em>注：这里是以linux下的设计作为对象来说明</em>。</p>
<p>​    内存映射就是将虚拟地址空间和磁盘对象关联起来的过程，一般是内核来操作，linux进程也可以通过mmap函数来进行用户级内存映射。</p>
<p>​    其中，磁盘对象也分为两种类型：</p>
<ol>
<li><p>linux文件系统中的普通文件（<em>注意：包括文件和目录</em>），它是真实存在在磁盘上的连续部分，例如一个可执行文件，一个txt文件等等。一开始虚拟页面没有实际交换进物理内存，因为按照按需调度规则，要等到CPU第一次引用该页面时，才会交换进入。</p>
</li>
<li><p>另一种是匿名文件，它不是真实存在在磁盘上的，而是由内核创建的，包含的全是二进制0。这个映射过程并没有磁盘和内存之间的数据传送，因此也会快很多。比如程序的堆和栈都是匿名文件，在磁盘上是没有对应数据的。</p>
<p>另一个概念就是内存映射的backing store，linux下叫做swap file。它的大小非常重要，它决定了当前运行进程最多可以分配的虚拟内存地址。[<em>注：csapp书这里把所有的虚拟内存交换出来的数据都写入swap file里，但笔者认为应该只是匿名文件才会写入swap file，普通文件直接写回linux文件系统里。</em>]。如果一台机器物理内存用完了，还不会发生oom，但是连swap file都用完了，则程序肯定启动不起来或者直接oom panic。</p>
<p>还有一个知识点是虚拟内存到底是什么？一开始根据前面的描述，我总觉得虚拟内存就是指磁盘上的某一段连续的存储，是像内存一样也是一段具体的空间，上面会写满我要的数据，然后在后续使用中再懒加载到物理内存中去。实际上，在linux上虚拟内存可以理解为就是上图中的mmap代表的结构，它由内核维护，由许多区域组成，有一些区域比如说代码段，就可以直接映射文件系统里具体的文件数据，而有一些区域比如数据区域，它并没有具体在磁盘上有映射文件，所以我们叫它匿名文件，并默认它是一个全部由二进制0组成的文件。它最开始只是创建了一个vm_area_struct对象，把虚拟地址的开头结尾写上，等到CPU需要第一次引用的时候，把它传送到物理内存里，然后更新页表。</p>
<p>所以并不是有多大的虚拟空间就要多大的物理磁盘，或者有多大的swap file文件，一方面是虚拟空间不一定有被分配；二来是被分配的可能是匿名文件比如堆栈，这些在磁盘上根本没有对应的数据，也只有在分物理内存写满的情况下使用。</p>
</li>
</ol>
<h4 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h4><p>​    也就是指多个进程共享的物理内存，它在各自进程里的虚拟地址一般不一样，但是都会映射到相同的物理地址上，这一部分的虚拟地址空间就是共享对象。对应的，还有私有对象。这个由上面进程任务结构体里的vm_flags来决定。</p>
<pre><code>1. 任何进程对共享对象的写操作都对其它共享该物理地址空间的进程可见的，并且也会反映到磁盘上的原始对象中去。
2. 而一个进程对私有对象的写操作是不会反映到磁盘上的对象中去，对其它进程也是不可见的。
3. 为了性能考虑，私有对象的映射使用到了写时复制的技术。也就是另一个进程只读的情况下，也是指向一份物理地址空间。当有一个进程需要对该物理地址空间进行写操作时，就会触发一个保护异常，从而在物理内存中创建一个新副本，更新页表条目让其指向这个副本，然后恢复写权限。
</code></pre>
<ul>
<li><input disabled="" type="checkbox"> [<em>注：笔者不是非常明白这里对私有对象的写操作为什么不会反映到磁盘上的对象中去？如果是这样，任何私有对象都不能修改磁盘文件了？还是说任何需要修改磁盘对象的操作都必须将该对象设置为共享对象？另外，共享对象的写操作反映到磁盘对象中去的途径是物理地址空间换出时吗？</em>]</li>
</ul>
<h2 id="练习题难点思考"><a href="#练习题难点思考" class="headerlink" title="练习题难点思考"></a>练习题难点思考</h2><ol start="2">
<li>9.6.4的综合问题：<ul>
<li>页表条目的个数取决于虚拟地址(而不是物理地址)的长度和页表的大小，所以这里页表是2<sup>6</sup>，而虚拟地址的长度是14，所以 # PTE &#x3D; 2<sup>8</sup></li>
</ul>
</li>
</ol>
<ul>
<li>TLB是虚拟地址来寻址的，而L1等SRAM的缓存是通过物理地址来寻址的。</li>
<li>顺一下CPU访问0x03d4处字节的过程：<ol>
<li>将该地址传送到MMU</li>
<li>MMU在TLB里查找（因为虚拟地址是14位）因此，查找的是：00 0011 1101 0100</li>
<li>（因为TLB是四路组相联，一共有16个条目），那么VPN的前2个低位作为组索引。（因为页的大小是2<sup>6</sup>，因此VPO的长度是虚拟地址的前6位。那么剩下的6位就是标记位。那么我们在TLB表中找到第11（也就是3）组的标记位为000011（也就是3）的表项，获取它存的ppn——0D。</li>
<li>然后剩下低6位010100作为VPO，也就是PPO，在MMU组成物理地址00 1101 010100，也就是0x354.</li>
<li>然后因为高缓是直接映射，有16个组，那么组索引的长度就是4个位，然后因为PPO和VPO一致，那么就是低2位是缓存偏移，紧接着4位是组索引，最后6位是标记。于是我们在高缓里找到第0101（也就是0x5）组的行，先看有效位是不是1，再对比其标记是不是0xd。缓存命中，取出0x36的数据。<strong>要注意：</strong>是先返回给MMU，然后MMU再返回给CPU，而不是直接给了CPU。</li>
</ol>
</li>
</ul>
<ol start="2">
<li>内存映射<ul>
<li>这其实和加载差不多，linux提供了mmap方法。c标准库里提供了malloc等方法。</li>
</ul>
</li>
<li>动态内存分配器<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>malloc返回的指针是指向一个大小<strong>至少</strong>为n的内存块，这个内存块要对可能包含的任何数据对象类型做对齐。比如32位的编译就返回8的倍数的地址，64位编译就返回16位的倍数的地址。</li>
<li>free是不会返回任何信息的，所以释放成功与否是不确定的。</li>
</ul>
<ol start="4">
<li>分配器的要求：<ul>
<li>立即回应请求，不允许缓存或者重新排列。</li>
<li>只能使用堆，任何非标量数据结构都在堆里</li>
<li>内存对齐</li>
<li>不能修改已分配的块</li>
</ul>
</li>
<li>练习题9.6<ul>
<li>首先要知道内存对齐是指OS在分配资源时的要求，而分配器的块是包含了头部，有效载荷和有可能的填充部分的整体。</li>
<li>其次块的头部里的块大小是指整个块的大小，而不是指有效载荷（也就是用户程序需要的大小）。</li>
<li>这个例子里说内存对齐要求的是分配的块要是8的倍数。也就是其余部分和头部的4字节要组成8的倍数字节。因此最后一个malloc(13)，也就是分配13字节加上头部的4字节，那么OS一共要分配17字节，由于要是8的倍数，那就只能分配24字节了，也就是剩下7个字节作填充。</li>
</ul>
</li>
<li>练习题9.8<br>首先是一些宏需要理解，因为平时不怎么使用。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p)       (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p)  (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp)       ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE))) <span class="comment">//line:vm:mm:nextblkp</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE))) </span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>这里的GET(p)只是为了让后面void*的强制类型格式转换比较方便，并没有任何操作。</li>
<li>GET_SIZE的功能是将头部变成块大小，因为头部的后三位是用来标记是否分配的，所以我们并上0x 1111 1111 1111 1111 1111 1111 1111 1000（也就是~0x7, 至于为什么要取个反再与);</li>
<li>GET_ALLOC则是与0x1的与，是因为它是用来将检测当前的块的头部是否最后一位是否是1，也就p指向的头部是否已经分配了。</li>
<li>HDRP是获取当前块的头部，参数bp永远是指向当前分配的块的留给用户程序使用的内存的第一个字节，所以它的前面就是头部；而头部的大小都是WSIZE，因此bp往前移WSIZE步就是指向头部的地址了。</li>
<li>FTRP是获取当前块的脚部，就是将当前的bp往后移这个内存块的大小。为什么要减去DWSIZE是因为首先我们的起点不是这个内存块的起点，而是跳过了头部的起点，这里就要减去一个WSIZE；另外我们不是要指向下一个块的开头，而是要指向上一个块的结尾，由于脚部也是一个WSIZE，所以又要减去一个WSIZE。</li>
<li>NEXT_BLKP(bp)返回的是指向下一个块的指针。逻辑是先读取当前块的头部，然后得到头部里存储的当前块的大小，然后指针再往后走这个多大小，就指向了下一块的有效载荷的第一位。你会疑惑，为什么不是指向下一块的头部？首先因为我们的块的大小指的是整个实际的内存块的大小（包括头部，有效载荷和填充位），于是当前的头部和下一个块的头部抵消，自然就指向了下一个块的有效载荷的第一个位置。因为块大小是包括了头部的。</li>
<li>类似的，PREV_BLKP(bp)是往前走双字，因为想要获取上一个块的脚部，也就是获取上一块的大小。</li>
</ul>
<p>于是，find_fit的逻辑就很好懂，heap_listp指向的是整个堆内存的第一个块，然后不断地获取下一个块，只要下一个块未分配并且大小比用户程序实际需要的内存大，就返回指向这个块的指针。否则就返回NULL。那么就来看一下整个程序如何保证这几个功能的实现的：</p>
<ul>
<li>维护heap_listp： 首先一开始就定义全局变量——static char *heap_listp &#x3D; 0; 然后在mm_malloc函数里判断如果 *heap_listp &#x3D; 0就调用mm_init函数。而在mm_init就初始化了*heap_listp，另起指向第一个块。而在后续的过程里，都没有改变过这个值。</li>
<li>而这些块的头部是哪里来的呢？观察到mm_init里还调用了mem_sbrk和extend_heap两个函数，不妨来看一下。</li>
<li>mem_sbrk的作用是在预设的堆内存里申请多一点的空间，逻辑就是先检查一下申请的合法性（是否是正的，是否超过了预设堆内存的最大值），然后更新全局变量brk，返回旧的brk值。</li>
<li>extend_heap这里的逻辑就是先把要申请的size内存对齐一下，然后用mem_sbrk申请，然后把申请的这一块的头部和脚部设置好，然后又新设置一个epilogue header结尾块。<br>只要把开头</li>
</ul>
<ol start="7">
<li>练习题9.9<br> 有一个要说明的是为什么这里判断要不要分割的条件是原始内存块与申请内存块大小之差是2个DSIZE？因为我们是DSIZE对齐，并且不允许有效载荷为0，由于头部和脚部加起来要占用一个DSIZE，因此最小的内存块大小就是2*DSIZE。</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>在9.8的内存映射里说的交换文件以及交换空间都限制着当前进程能够分配的虚拟页面的总数？</li>
<li>9.8.3讲execve函数的时候说加载a.out的第一步就是删除已存在的用户区域，这是哪个区域？删除的是什么？</li>
<li>所谓的对齐具体一点，为什么32位的编译就返回8的倍数的地址，64位编译就返回16位的倍数的地址？</li>
<li>显示空闲链表里的空闲块排序顺序为什么影响释放一个块的时间？</li>
</ol>
<h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><ol>
<li><p>top里的res、swap、data、virt、shr、%mem这些数据的对应的程序的哪些部分？</p>
<ul>
<li>res是常驻内存，也就是当前该进程实际上占用了多少物理内存，包括私有对象和共享对象。凡是该进程能访问的且正缓存在物理内存里的，都作数。</li>
<li>virt就是虚拟内存，也就是概念上的已分配的内存。包括内核虚拟内存空间和用户态虚拟内存空间。</li>
<li>data就是进程栈+堆的总空间？是指物理内存还是虚拟内存？</li>
<li>shr就是共享内存，</li>
</ul>
</li>
<li><p>ps aux里的rss、vsz和%mem又分别说明了什么？</p>
</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ustc_dylan/article/details/7228356">由匿名内存看swap分区</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011547375/article/details/9851455">linux top VIRT RES SHR SWAP DATA内存参数详解</a></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/03/24/%E3%80%90CSAPP%E3%80%91Ch9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" data-id="cl0t1dcy9000b8slfe0gs2uod" data-title="【CSAPP】Ch9-虚拟内存" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【CSAPP】Ch8-异常控制流" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/24/%E3%80%90CSAPP%E3%80%91Ch8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" class="article-date">
  <time class="dt-published" datetime="2018-03-24T03:24:40.000Z" itemprop="datePublished">2018-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/24/%E3%80%90CSAPP%E3%80%91Ch8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/">【CSAPP】Ch8-异常控制流</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>我们的程序不可能不出错，一旦出错了就应当有处理措施。比如除零错误。</li>
<li>很多行为是异步的无法预测的，比如我们什么时候会敲击键盘，什么时候网络数据到达。而我们的程序或者操作系统不可能一直等在那。因此我们还需要一个机制可以有效地处理这种异步信息。</li>
</ol>
<p>这两个问题引出了这一章的重点：异常处理<a href="CSAPP%E9%87%8C%E6%8A%8A%E6%89%80%E6%9C%89%E9%83%BD%E5%8F%AB%E5%81%9A%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%BD%86%E6%88%91%E8%AE%A4%E4%B8%BA%E8%BF%99%E6%A0%B7%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%B8%80%E4%B8%AA%E9%94%AE%E7%9B%98%E7%9A%84%E6%95%B2%E5%87%BB%E5%AF%B9OS%E8%BF%98%E6%98%AF%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9C%A8%E7%9B%B4%E8%A7%82%E4%B8%8E%E5%AD%97%E9%9D%A2%E6%84%8F%E4%B9%89%E4%B8%8A%E9%83%BD%E4%B8%8D%E8%83%BD%E5%BC%82%E5%B8%B8%EF%BC%8C%E6%88%91%E8%AE%A4%E4%B8%BA%E6%8A%8A%E4%B8%AD%E6%96%AD%E5%8D%95%E7%8B%AC%E6%8B%BF%E5%87%BA%E6%9D%A5%E3%80%82%E4%BD%86%E6%98%AF%E5%A6%82%E6%9E%9C%E7%AB%99%E5%9C%A8%E6%9B%B4%E4%B8%BA%E6%8A%BD%E8%B1%A1%E7%9A%84%E5%B1%82%E9%9D%A2%E4%B8%8A%E6%9D%A5%E8%AE%B2%EF%BC%8C%E4%B8%AD%E6%96%AD%E4%B9%9F%E5%A5%BD%EF%BC%8C%E5%BC%82%E5%B8%B8%E4%B9%9F%E5%A5%BD%EF%BC%8C%E5%85%B6%E5%AE%9E%E9%83%BD%E6%98%AF%E5%AF%B9%E5%BD%93%E5%89%8D%E7%A8%8B%E5%BA%8F%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%80%E7%A7%8D%E7%A0%B4%E5%9D%8F%EF%BC%8C%E4%BD%BF%E5%BE%97%E5%AE%83%E4%BB%AC%E8%A6%81%E5%81%9C%E4%B8%8B%E6%9D%A5%E5%8E%BB%E5%81%9A%E4%B8%80%E4%BA%9B%E5%88%AB%E7%9A%84%E4%BA%8B%E6%83%85%E3%80%82%E6%88%96%E8%80%85%E5%A4%84%E7%90%86%E5%A5%BD%E8%BF%99%E4%B8%AA%E5%BC%82%E5%B8%B8%EF%BC%8C%E6%88%96%E8%80%85%E5%B0%B1%E7%9B%B4%E6%8E%A5%E9%80%80%E5%87%BA%E4%BA%86%E8%AF%A5%E7%A8%8B%E5%BA%8F%E3%80%82%E5%9B%A0%E6%AD%A4%E9%83%BD%E5%BD%92%E5%81%9A%E5%BC%82%E5%B8%B8%E4%B9%9F%E6%97%A0%E5%8F%AF%E5%8E%9A%E9%9D%9E%E3%80%82">^footnote</a>。</p>
<p>对于所有的异常，我们的机制是硬件负责改变处理器的状态码，软件负责告诉处理器应该怎么做。一般就是查表，硬件告诉软件出现的是哪一种异常，软件维护一个异常表，然后通过异常处理程序来处理这个异常。这个在unix系统里直接就叫做了中断向量表，而不是异常表<a href="%E4%BC%BC%E4%B9%8E%E5%9C%A8%E5%AD%A6%E4%B9%A0OS%E7%90%86%E8%AE%BA%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%AA%E7%9F%A5%E9%81%93%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E5%BC%82%E5%B8%B8%E8%A1%A8%E3%80%82%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E4%B8%80%E8%88%AC%E9%83%BD%E6%98%AF%E4%BB%A5x86%E7%9A%84%E6%9E%B6%E6%9E%84%E6%9D%A5%E5%AD%A6%E4%B9%A0%E7%9A%84%E3%80%82%E8%80%8Cx86%E9%87%8C%E6%B2%A1%E6%9C%89%E5%8C%BA%E5%88%86%E8%BF%99%E4%B8%A4%E8%80%85%EF%BC%8C%E9%83%BD%E6%94%BE%E5%9C%A8%E4%BA%86%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E9%87%8C%E3%80%82%E5%8F%82%E8%80%83%5B%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F%E8%A1%A8%E5%92%8C%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB%5D(https://blog.csdn.net/selous/article/details/64983718)%E3%80%82%E5%8F%A6%E5%A4%96%E8%A6%81%E6%B3%A8%E6%84%8F%EF%BC%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%9C%A8%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E9%87%8C%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E4%BB%A3%E5%8F%B7%E3%80%82">^footnote2</a>。</p>
<p>而上面的这种机制还非常底层，因为其实它需要利用硬件去响应，软件处理这种模式。还有一种更为高级的机制——信号。事实上，信号不是什么新产生的信息。而是底层的中断往上层应用程序的反馈。比如我们对进程的控制就是内核给进程发送一些信号，但在底层上实际上还是一些异常。只不过这些异常可能操作系统给了一些接口让应用程序去处理。</p>
<p>知识点其实就是两个，异常与信号。</p>
<ol>
<li>异常<ul>
<li>中断： 中断向量表，中断服务例程</li>
<li>故障与终止</li>
<li>系统调用：<ul>
<li>用户态与内核态的切换</li>
<li>使得进程的概念成为可能： 控制进程（创建fork，加载，睡眠，结束exit），上下文切换，回收子进程（wait，waitpid)。</li>
</ul>
</li>
</ul>
</li>
<li>信号<ul>
<li>发送信号：进程或者进程组</li>
<li>接收信号：OS有自己的默认逻辑，可以通过signal函数自定义。</li>
<li>阻塞与接触堵塞信号：显示和隐式</li>
<li>信号处理程序： 异步安全，因为信号与主程序并发执行，共享全局变量；信号不排队特性。</li>
</ul>
</li>
</ol>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol>
<li><p>内核为每个进程都维护了pending向量和blocked向量，分别对应于待处理信号和被阻塞信号</p>
<blockquote>
<p>信号的“未决”是一种状态，指的是从信号的产生到信号被处理前的这一段时间；<br>信号的“阻塞”是一个开关动作，指的是阻止信号被处理，但不是阻止信 号产生。<br>信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了 防止信号打断敏感的操作。<br>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012349696/article/details/50936585">linux 信号阻塞和信号未决</a></p>
</blockquote>
</li>
<li><p>异常与过程调用（也就是函数调用）的区别：</p>
<ul>
<li>过程调用在跳转之前会把返回地址压入栈中；而异常的返回地址则根据异常号的不同返回当前指令或者下一条指令的地址。</li>
<li>异常还会额外地压入一些信息入栈</li>
<li>异常的处理在一直在内核态，而过程调用在用户态。</li>
</ul>
</li>
<li><p>异常的类别<br> <img src="http://static.zybuluo.com/Husy/gmztm0r8yfaletfemdspissv/image.png" alt="异常类别"></p>
<ul>
<li>注意这里的I&#x2F;O设备不仅仅指输出的屏幕或者输入的键盘，包括网卡，时钟都算。</li>
<li>然后中断是异步的原因是因为中断并不是由当前执行的某条指令产生的。也就是你无法获悉它在什么时候会发生。而同步的话都因为当前执行的某条指令产生的，是可与侧的。也就是再执行一遍，也会是在同样的地方产生异常。</li>
</ul>
</li>
<li><p>Linux&#x2F;X86-64异常的一些常识：</p>
<ul>
<li>有256种异常，前32种是Intel架构师定义的异常。因此堆任何x86-64的系统都是一样的。</li>
<li>32～255都是系统定义的中断和陷阱。</li>
<li>系统调用对应与一个异常里的一个号，它额外还有一个系统调用的表的偏移量。然后系统调用靠寄存器传递参数，而不是像函数调用一样用栈传递。规定是%rax存放系统调用号，比如60号是终止进程的系统调用，然后%rdi，%rsi等寄存器保存系统调用需要的参数。而返回值errono也在%rax中，而如果返回值是负数，就表明出错了。</li>
</ul>
</li>
<li><p>并行与并发</p>
</li>
</ol>
<ul>
<li>并行更为严格。要求两个程序真正地同时运行在两个CPU上或者计算机上。而并发只需要时间上的重叠，就是X结束之前，Y开始运行了，我们就说X和Y是并发的。但是很有可能X和Y的指令是轮流在一个CPU上执行的。</li>
</ul>
<ol start="4">
<li>fork<ul>
<li>子进程得到父进程用户级的虚拟地址空间的一份副本，包括代码，数据，堆和共享库以及用户栈。还获得与父进程一致的文件描述符。</li>
<li>子进程的fork返回0</li>
<li>注意，是数据独立，但是文件共享(描述符是独立的，但是描述符指向的打开文件表的表项是一样的，也就共享文件位置等。）</li>
<li>waitpid2.c这个程序里有一段： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define N 3 </span><br><span class="line">/* Parent creates N children */</span><br><span class="line">    for (i = 0; i &lt; N; i++) </span><br><span class="line">	if ((pid[i] = Fork()) == 0)  /* Child */          //line:ecf:waitpid2:fork</span><br><span class="line">	    exit(100+i);</span><br></pre></td></tr></table></figure>
 一开始觉得当N&#x3D;3时，难道不应该有8个线程吗？（见下图），如果这里在fork返回子进程时执行的是别的操作，那么就是8个进程。但其实，因为子进程直接exit了，也就是不再执行循环操作了。这是一个很好的方法，防止进程的子子孙孙作用。另外就是要记住这种控制子进程顺序的方式。<br><img src="http://static.zybuluo.com/Husy/k59tjr4jjbpisfh9v2k3mu9s/Screenshot%20from%202018-07-12%2010-03-36.png" alt="fork流程图"></li>
</ul>
</li>
<li>练习题8.4的答案有一个地方是错的，最后的Bye前面的数字应该是2，而不是1.因为这里输出的是子进程的退出状态。由exit(2)可知，应该是2.<br><img src="http://static.zybuluo.com/Husy/uczqjotimg6b918z1dnp01jo/Screenshot%20from%202018-07-12%2010-40-01.png" alt="Screenshot from 2018-07-12 10-40-01.png-67.8kB"></li>
<li>练习题8.7 ，sleep被信号打断是会立即返回的，但是由于SIGINT的默认行为是终止进程，于是我们其实只需要让SIGINT的默认行为是什么都不做就行了。答案的写法是直接return（这里就涉及到<a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/496700945433053244.html">return和exit(0)的区别</a>。).还有要注意的是这里不能直接用SIG_IGN,因为这样一来就是让sleep程序直接忽略了这个信号。</li>
<li>信号的特征:<ul>
<li>信号如果被阻塞，就不能被接收。而阻塞又分隐式和显式，隐式指正在处理的类型K信号会阻塞接下来的类型K信号，而显示是应用程序用sigprocmask函数等去直接处理。</li>
<li>一个进程里发送了却没有接收的信号（待处理信号）同一类型永远只有一个（因为一个进程的pending位向量）对于每一个类型的待处理信号只会有一个bit的标记，也就是有或者没有。如果一个进程有了一个信号类型为k的待处理信号，那么任何接下来接收到的信号类型为k的信号都会被直接丢弃，而不是排队等候处理。</li>
<li>信号的处理是可以被其它信号打断的，处理s信号的时候来了t信号，那么就中断当前s处理程序去处理t信号，返回的时候就继续执行s处理程序的下一条指令。</li>
</ul>
</li>
<li>信号的安全处理：<ul>
<li>在处理程序中只调用异步信号安全的函数（可重入或者不能被信号处理程序中断）</li>
<li>保存和恢复errno</li>
<li>阻止所有信号，保护对共享全局变量的访问。</li>
<li>用volatile声明全局变量,告诉编译器不要缓存这个值使得这个值的更新能被及时知道。</li>
<li>sig_atomic_t来处理全局变量</li>
</ul>
</li>
<li>非本地跳转的两个用法是：允许一个深度嵌套的函数中立即返回到一个错误处理程序中去而不用说一个个的把调用栈解开。比如C++里的try catch机制；另一个用法就是控制信号处理程序的返回位置。一般来讲信号处理程序返回后程序就接着上次执行的下一条执行，但是用非本地跳转就可以让程序从任意别的地方开始执行。</li>
<li>家庭作业8.19值得记住，通过for(int i&#x3D;0;i&lt;n;++i) fork();得到的线程数一共是2<sup>n</sup>个。</li>
<li>另一个要注意的是做8.13和8.16都忘记了父子进程全局变量是复制的，不是共享的。只有打开的文件是共享的。但是主程序和信号处理程序是共享全局变量的。</li>
<li>csapp里有一个例子图8-36与图8-37，似乎就是把waitpid从if改为while，为什么就可以解决信号不排队导致的僵尸进程问题呢？<blockquote>
<p>开始同第一个程序运行的一样，创建3个子进程，第一个子进程最先终止，发出一个SIGCHLD信号，父进程第一次调用信号处理程序。信号处理程序执行到whlie语句条件中的waitpid时，会一直停止在这个while循环中直到父进程没有子进程为止。处理完第一个终止的子进程后，此时很有可能第二个子进程也早已经终止了(即使此时第二个子进程没有终止也没有关系，waitpid会挂起调用进程，阻塞于此，一直等待有子进程终止)，导致内核发送了第二个SIGCHLD信号给父进程，然后这个信号会成为待处理信号。虽然这个信号成为待处理信号，没有立即马上调用相应的信号处理程序来处理，但是第一个SIGCHLD调用的信号处理程序中的waitpid语句仍然会回收终止的第二个子进程。第三个子进程发出的SIGCHLD信号虽然会被抛弃，但是同样会被第一个SIGCHLD信号调用的信号处理程序中的waitpid回收。至此，三个子进程都被回收完了，于是当第一个SIGCHLD信号调用的信号处理程序中的waitpid语句检查到没有父进程后，返回-1，while循环终止，睡眠2秒钟后，第一个信号调用的信号处理程序结束。当控制从第一个信号调用的信号处理程序返回后，内核检测到待处理信号集合中还有一个SIGCHLD信号，也就是第二个子进程终止发出的信号。虽然第二个子进程早已经被回收了，但是父进程还是会调用信号处理程序，while语句中的条件测试显然会失败，于是第二个SIGCHLD调用的信号处理程序什么都没有做，只是睡眠了2秒种就返回了。而第三个SIGCHLD信号虽然连信号处理程序都没有调用，但是第三个子进程同样按照我们所希望的也被回收了。可以看到，子进程虽然都被正确回收了，但是都是通过第一个子进程调用的信号处理程序中的waitpid语句回收的。<br>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32400847/article/details/52101983">csapp读书笔记-signal处理(阻塞、排队、中断)</a></p>
</blockquote>
</li>
</ol>
<p>那么这个处理方式就有一点点特殊性，但是大部分时候我们要处理的就是回收进程的信号不排队的问题。</p>
<h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><ol>
<li>家庭作业8.24\～8.26没有做。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/03/24/%E3%80%90CSAPP%E3%80%91Ch8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" data-id="cl0t1dcy8000a8slfh54qhj4s" data-title="【CSAPP】Ch8-异常控制流" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【CSAPP】实验cache-lab" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/24/%E3%80%90CSAPP%E3%80%91%E5%AE%9E%E9%AA%8Ccache-lab/" class="article-date">
  <time class="dt-published" datetime="2018-03-24T03:12:52.000Z" itemprop="datePublished">2018-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/24/%E3%80%90CSAPP%E3%80%91%E5%AE%9E%E9%AA%8Ccache-lab/">实验cache_lab</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>两个实验：</p>
<ol>
<li>Part A: implementing a cache simulator</li>
<li>Part B: writing a matrix transpose function that is optimized for cache performance</li>
</ol>
<h3 id="Part-A-implementing-a-cache-simulator"><a href="#Part-A-implementing-a-cache-simulator" class="headerlink" title="Part A: implementing a cache simulator"></a>Part A: implementing a cache simulator</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先有通过valgrind生成内存的访问情况记录（放在trace文件目录下），然后通过我们的程序去解析，统计它的命中与换出。要注意：</p>
<ol>
<li>这里并不是要你真的去实现一个缓存，不需要把具体内容放到你申请的内存里。你只是需要统计内存的使用。</li>
<li>我们的前提是假设读取一个trace文件的时候，缓存里没有任何东西。也就是第一个内存访问是不命中的。然后我们自己要维护一个表，来记录缓存里的情况（再次强调，这里是记录情况，而不是把数据写在缓存里，因此我们并不需要blcok的部分）。</li>
<li>algrind的输出文件的一些规则：<ul>
<li>L：读，从内存中读取</li>
<li>S：写，向内存中写</li>
<li>M：修改，这涉及一次读，一次写。这个写由于已经读了，所以写一定是命中的</li>
</ul>
</li>
<li>还有一个要注意的是set的位数s就决定了缓存里一定有2<sup>s</sup>。但是我们在设置line的个数时却不是根据一个地址里有几个bit作为line的标记来计算的。所以我们在计算需要多少个cache line的时候，要注意这一点。并且，对于任何一个组索引，缓存表里总能找到这样一个组来对应。只是tag不相同。</li>
<li>还有就是要熟悉取一个二进制任何哪几位的方法。</li>
</ol>
<p>于是我们的代码的步骤就是：</p>
<ol>
<li>首先解析命令行</li>
<li>根据命令行的设定维护一个cache的表。</li>
<li>读取trace下的文件，解析每一行</li>
<li>根据缓存命中规则和最近最少使用换出算法统计命中与换出。</li>
</ol>
<p>对于1，可以通过getopt<br>对于2，通过malloc申请内存，并且设置一个结构体cache line的数组。<br>对于3，可以用fscanf()<br>对于4，缓存命中就是判断tage和组号等，但是我们的cache_line可以只有tag成员变量，而不需要组序号这个变量。我们可以直接通过组序号算出来是哪一个位置。另外就是在置换的时候虽然是要比较最近最少使用的，但是如果我们用一个数组来表示的话，我们就可以直接用数组的下表来暗含这种先后关系。下标大的比下标小的使用时间更短更新。我们每次置换就置换每一组的第一个line。</p>
<h4 id="debug的一些笔记"><a href="#debug的一些笔记" class="headerlink" title="debug的一些笔记"></a>debug的一些笔记</h4><ol>
<li>如果一个指针变量用引用传递参数会怎样？</li>
<li>C语言里常数指针与指向常数的指针</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29350001/article/details/53096908">return和exit的区别</a></li>
<li>结构体作为参数传递是值传递，而不是像数组一样是指针传递。</li>
<li>memcpy(&amp;(cur+1), &amp;cur, sizeof(cache_line));&amp;(cur+1)错误，因为cur+1是一个临时的变量，不能用&amp;求地址。</li>
<li>while(fscanf(fp, “ %c %u,%d”,&amp;operation, &amp;addr, &amp;dataSize)&gt;0),这里如果没有&gt;0,则会一直读取最后一行。估计是因为fscanf会返回-1,而这个会当作true</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rosesmall/archive/2012/04/10/2440514.html">gdb设置参数</a>可以直接set args把后面的参数行写进去。</li>
<li>fscanf(fp, “ %c %x,%d”,&amp;operation, &amp;addr, &amp;dataSize)&gt;0这里一开始%x我用的是%u,于是这样就是十进制的数，对地址转换就有问题。</li>
<li>还有就是除了在命中的时候要更新位置，在写入一个新的，或者置换了一个新的cache_line以后也要更新位置。</li>
</ol>
<h4 id="改进空间"><a href="#改进空间" class="headerlink" title="改进空间"></a>改进空间</h4><ol>
<li>LRU的算法，cache可以用一个链表表示，而不是用数组。</li>
</ol>
<h3 id="Part-B-writing-a-matrix-transpose-function-that-is-optimized-for-cache-performance"><a href="#Part-B-writing-a-matrix-transpose-function-that-is-optimized-for-cache-performance" class="headerlink" title="Part B: writing a matrix transpose function that is optimized for cache performance"></a>Part B: writing a matrix transpose function that is optimized for cache performance</h3><p>前提是评分里规定</p>
<ol>
<li>缓存器是2<sup>5</sup>个set，每个set一个line，然后每个line存2<sup>5</sup>bytes数据。也就是8个int。</li>
<li>局部变量不能超过12个。</li>
<li>这个部分大都是硬编码，拿到大部分的分就ok，这个优化可能是无止尽的，性价比不高。重点是理解这种优化的逻辑，就是利用局部性，一次尽量处理内存上连续的数据，或者已经放在缓存里的数据。</li>
</ol>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ol>
<li>32*32<br>这个很多博客里都有些，就是普通的分块，8*8。但是要考虑到A和B中对应的元素都是映射到同一行[^footnote]，对于对角线的操作B[i][i]&#x3D;A[i][i]，这样就会引发缓存不命中，并且会把A数组的缓存替换成。后面再继续B[i][j]&#x3D;A[j][i]时，又会把A数组替换回去。解决方法是用8个局部变量一次把A的8个数都保存好，然后去修改B数组时就直接替换一次就好了。<br>于是最低是4*4*16 &#x3D; 256次。再加上每转置一行A中的8个数，就要替换一行给对应的B。因此287也算是合理。<br>为什么不能是8*16呢？缓存16行A，16行B，简直完美啊？ 你可以推导一下就知道A的第8行和第0行是在一个缓存行里的，不可能同时缓存。</li>
<li>64*64<br>如果按照32*32的来，那么理论上完美的miss数是8*8*(8*2)&#x3D;1024次。但是又别忘了，此时A的第0行和第4行就开始重叠缓存行了，因此我们分块也定多是分成4*8一块。用这个分法试一下结果是miss 4611次。</li>
</ol>
<ul>
<li>为什么呢？思路不都一样吗？因为每次缓存A的4*8这么4个缓存行，转置过去以后B依旧要缓存8行而却只能修改每一行的4个数。所以B的缓存我们只利用了一半。而且局部变量也只需要4个。</li>
<li>64*64的这个矩阵结构注定了无论是A还是B，我们每次都最多能缓存4行数据（是数组里的数据，而不是缓存行）。因此瓶颈就在于我们每一次缓存了整个4*8的数却只能完成4*4的转置。如果我们把A中缓存了的数据在转置中无法用到的部分暂时存在B中转置无法用到的部分，然后等到B缓存到某个块时，我们可以直接从B的某个位置独到这个块的信息。思路就是这个思路，可以自己去推导一下。</li>
</ul>
<ol start="3">
<li>61*67<br>因为这个的要求放的比较低，不超过2000。并且由于67行，数据行之间无法想上面一样有非常规整的关系。比如第0行的数据就是会和第3行的数据在缓存上的地址一一对应。可以试几个分法，比如8*8，16*16。</li>
</ol>
<h4 id="debug的一些注意点"><a href="#debug的一些注意点" class="headerlink" title="debug的一些注意点"></a>debug的一些注意点</h4><ol>
<li>关于中间变量，直接用B[j][i]&#x3D;A[i][j]也可以，为什么要引入一个temp？这里引入temp没有什么意义，最后的hits是一样的，但是后面transpose_submit则需要中间变量，原因是这个矩阵恰好是8*32int的倍数，也就是说A[i][j]的缓存一定会被B[i][j]替换，因为A和B是相邻的数组。因此我们用中间变量一次性读完。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33846811">参考</a></li>
</ol>
<p>[^footnote]: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33846811">&lt;深入理解计算机系统》配套实验：Cache Lab</a>里的评论里说了两个数组是一个静态链接，也就是地址是固定的。所以我们的这些分析都是非常具有针对性的。下次遇到同样的数组转置还是要具体问题具体分析，再次强调大家不要太去追求极致。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/03/24/%E3%80%90CSAPP%E3%80%91%E5%AE%9E%E9%AA%8Ccache-lab/" data-id="cl0t1dcy500048slfc6rg5gxn" data-title="实验cache_lab" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【CSAPP】实验Shell lab" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/20/%E3%80%90CSAPP%E3%80%91%E5%AE%9E%E9%AA%8CShell%20lab/" class="article-date">
  <time class="dt-published" datetime="2018-03-20T03:11:54.000Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/20/%E3%80%90CSAPP%E3%80%91%E5%AE%9E%E9%AA%8CShell%20lab/">实验一shell_lab</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>就是完成tsh.c里的函数：</p>
<ol>
<li>eval: Main routine that parses and interprets the command line. [70 lines]</li>
<li>builtin_cmd: Recognizes and interprets the built-in commands: quit, fg, bg, and jobs. [25 lines]</li>
<li>do bgfg: Implements the bg and fg built-in commands. [50 lines]</li>
<li>waitfg: Waits for a foreground job to complete. [20 lines]</li>
<li>sigchld handler: Catches SIGCHILD signals. 80 lines]</li>
<li>sigint handler: Catches SIGINT (ctrl-c) signals. [15 lines]</li>
<li>sigtstp handler: Catches SIGTSTP (ctrl-z) signals. [15 lines]</li>
</ol>
<p>具体来讲，我们的shell需要提供有三种命令：</p>
<ul>
<li>一种是bulit-in型，这个就直接在当前线程执行；</li>
<li>一种是执行某个可执行文件，这样就另开一个新线程执行</li>
<li>还有一种是处理信号，比如ctrl-c就让当前进程停止等。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一开始有些不知从何下手的感觉，其实我们可以make后用下面两条命令，然后比对输出结果。就可以一步一步的完善我们的shell。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./sdriver.pl -t trace01.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line">./sdriver.pl -t trace01.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br></pre></td></tr></table></figure>
<p>从trace01到trace16的输出都一致后，我们的shell就完成了。</p>
<h3 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h3><p>这一块其实书上都有，builtin_command扩展一下等等</p>
<h3 id="程序执行原理"><a href="#程序执行原理" class="headerlink" title="程序执行原理"></a>程序执行原理</h3><p>就是fork一个子进程，然后父进程获取返回值。子进程执行的时候，父进程是堵塞的。而且要注意fork新进程的过程中要阻塞SIGCHLD信号，原因如下 </p>
<blockquote>
<p>在fork()新进程前后要阻塞SIGCHLD信号，防止出现竞争（race）这种经典的同步错误，如果不阻塞可能会出现子进程先结束从jobs中删除，然后再执行到主进程addjob的竞争问题。相关解释和方法见CSAPP P519页。</p>
</blockquote>
<h3 id="后台执行原理"><a href="#后台执行原理" class="headerlink" title="后台执行原理"></a>后台执行原理</h3><p>我们一般在命令行执行命令都是前台执行，也就是会堵塞当前进程的。如果想后台执行（也就是不堵塞当前进程）的话，只需要父进程不再wait子进程的消息。</p>
<h3 id="对于builtin-command"><a href="#对于builtin-command" class="headerlink" title="对于builtin_command"></a>对于builtin_command</h3><ul>
<li>fg是把某个在后台的停止的程序放到前台执行。怎么做到呢？无非就是发送一个SIGCONT信号，然后wait堵塞住shell进程。SIGCONT的默认处理模式就可以，所以我们不用自己写信号处理程序。</li>
<li>bg是把某个后台停止的程序重新在后台执行，也就是发送一个SIGCONT给相关进程。</li>
</ul>
<h3 id="几个细节"><a href="#几个细节" class="headerlink" title="几个细节"></a>几个细节</h3><ol>
<li>当我们使用bulitin_command里的kill 一个job时，最先想到的思路就是调用unix的kill函数，给这个进程发送一个信号，而信号的默认操作就是结束进程。这样固然没有错，但是，考虑下面的情况：</li>
</ol>
<blockquote>
<p>In this case, the shell forks a child process, then loads and runs the program in the context of the<br>child. The child processes created as a result of interpreting a single command line are known  collectively as a job. In general, a job can consist of multiple child processes connected by Unix pipes.</p>
</blockquote>
<p>要注意一个job不一定只有一个进程，可能也有多个进程。那么kill一个进程就不管用了。最好的方法是为每一个job创建一个进程组，然后直接给kill传递负的进程号，意思是结束该进程号的进程组里的所有进程。<br>2. 如果我们发送SIGCONT给某个子进程，然后这个进程在wait开始执行之前就执行完了，会怎样？这里就应该听从writeup文件里的建议，waitfg只做sleep处理，不做回收子进程处理。这样的好处就是，waitfg里会少出现一次系统调用错误。<br>3. fork以后子进程重新设置了进程组PID，但是这种子进程与父进程的关系还在。也就是说，子进程结束以后我们的父进程shell依旧会受到SIGCHLD。<br>4. 信号处理程序中的函数要是异步信号安全的要么不能被别的信号处理程序中断，要么可重入。产生输出的唯一安全的方法就是使用write。要们就在printf之前把所有信号都屏蔽。<br>5. 根据安全信号处理的G3，当主程序与信号处理程序同时维护一个全局变量的时候，信号处理程序应该要阻塞所有的信号。那么我们的信号处理程序里删除jobs list里的一项时都需屏蔽所有信号。<br>6. sigchld_handler函数里，我们对子进程的回收用的函数是waitpid(-1,&amp;status,WNOHANG|WUNTRACED)。而且要用while的原因可以参考<a target="_blank" rel="noopener" href="https://husy1994.github.io/2018/03/17/chap8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/">chap8-异常控制流笔记</a> </p>
<h2 id="待改进-amp-问题"><a href="#待改进-amp-问题" class="headerlink" title="待改进&amp;问题"></a>待改进&amp;问题</h2><ol>
<li>信号处理程序没有做到信号安全，比如用了printf这种函数。虽然考虑到整个测试会比较简单，不太容易出现printf被打断的情况，但是理论上来说需要屏蔽所有信号或者使用一些信号安全的函数。</li>
<li>还有很多细节可以推敲，但是这一阶段求一个整体理解。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yongfengnice/p/6796356.html">Linux下回收子进程wait函数和waitpid函数的基本使用</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012336567/article/details/51926577">CSAPP: Shell Lab</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/03/20/%E3%80%90CSAPP%E3%80%91%E5%AE%9E%E9%AA%8CShell%20lab/" data-id="cl0t1dcyb000f8slf7vqr0wj1" data-title="实验一shell_lab" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mit6-824/">mit6.824</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/quant%E9%9D%A2%E8%AF%95%E7%BA%A2%E5%AE%9D%E4%B9%A6/">quant面试红宝书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">数据结构笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E5%AE%9D%E5%85%B8/">面试算法宝典</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APUE/" rel="tag">APUE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algroithm/" rel="tag">Algroithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/I-O/" rel="tag">I&#x2F;O</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pprof/" rel="tag">Pprof</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test/" rel="tag">Test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/" rel="tag">code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/distributed/" rel="tag">distributed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gc/" rel="tag">gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lock-free/" rel="tag">lock-free</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quant-interview/" rel="tag">quant interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raft/" rel="tag">raft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ucore/" rel="tag">ucore</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/APUE/" style="font-size: 10px;">APUE</a> <a href="/tags/Algroithm/" style="font-size: 18.57px;">Algroithm</a> <a href="/tags/CSAPP/" style="font-size: 20px;">CSAPP</a> <a href="/tags/Golang/" style="font-size: 17.14px;">Golang</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/I-O/" style="font-size: 10px;">I/O</a> <a href="/tags/Leetcode/" style="font-size: 18.57px;">Leetcode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a> <a href="/tags/OS/" style="font-size: 15.71px;">OS</a> <a href="/tags/Pprof/" style="font-size: 10px;">Pprof</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/code/" style="font-size: 10px;">code</a> <a href="/tags/distributed/" style="font-size: 11.43px;">distributed</a> <a href="/tags/gc/" style="font-size: 10px;">gc</a> <a href="/tags/golang/" style="font-size: 12.86px;">golang</a> <a href="/tags/k8s/" style="font-size: 10px;">k8s</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/lock-free/" style="font-size: 10px;">lock-free</a> <a href="/tags/quant-interview/" style="font-size: 14.29px;">quant interview</a> <a href="/tags/raft/" style="font-size: 12.86px;">raft</a> <a href="/tags/ucore/" style="font-size: 17.14px;">ucore</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 12.86px;">双指针</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18.57px;">算法</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 11.43px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/26/Prometheus-Histograms-Observation%E7%9A%84%E6%97%A0%E9%94%81%E5%AE%9E%E7%8E%B0/">Prometheus笔记</a>
          </li>
        
          <li>
            <a href="/2021/08/09/k8s%E5%AE%9E%E6%93%8D%E7%AC%94%E8%AE%B0/">k8s实操笔记</a>
          </li>
        
          <li>
            <a href="/2021/07/16/golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">golang垃圾回收</a>
          </li>
        
          <li>
            <a href="/2021/06/03/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%A4%87%E5%BF%98%E5%BD%95/">golang测试备忘录</a>
          </li>
        
          <li>
            <a href="/2021/05/02/defer%E8%AF%A6%E8%A7%A3/">defer详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Husy<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>