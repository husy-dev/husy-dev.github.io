<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://husy-dev.github.io/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Husy">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://husy-dev.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-1-投硬币问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/07/02/1-%E6%8A%95%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2018-07-02T14:40:11.000Z" itemprop="datePublished">2018-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/quant%E9%9D%A2%E8%AF%95%E7%BA%A2%E5%AE%9D%E4%B9%A6/">quant面试红宝书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/07/02/1-%E6%8A%95%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98/">1-投硬币问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p> A有n+1枚硬币，B有n枚硬币，两人分别依次投掷自己的硬币，问A的硬币中出现正面次数大于B的概率是多少？</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>不要急于用公式去算。首先我们先考虑一下A投完n枚硬币后，B也投完n枚硬币后，是不是有三种情况：<br>C1： A的正面次数&gt;B<br>C2:  A的正面次数&#x3D;B<br>C3： A的正面次数&lt;B<br>由于这些硬币都是均匀分布的，因此P(C1)&#x3D;P(C3)&#x3D;x，P(C2)&#x3D;y。 那么2x+y&#x3D;1.<br>然后我们再单独考虑A投最后一个硬币，如果是C1情况，最后一个硬币不影响结果，依旧是A的次数大于B，此时C1的概率并不会随着最后一个硬币增加。如果是C3情况，最后一个硬币也不会让A的次数大于B。如果是C2，则最后一个硬币是正面，那么A的次数就大于B，那么C1出现的概率就会增加。于是<br>x+0.5<em>y&#x3D;0.5</em>（2x+y）&#x3D;0.5.</p>
<p>这里的思考就是，先构造出一个对称的情形来，比如这里让A和B的情况一样。然后考虑其差异。这个其实和后面的题2相似，但后者是用一种迭代的方式找出对称的情形来，比如它的子问题可以是抛了3次以后再抛多少次能得到连续n次出现正面的情况。</p>
<h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p>投掷一枚均匀分布的硬币，知道出现连续2次正面所需投掷的期望次数是多少？</p>
<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><p>首先我们假设期望次数是x，我们把2次看作一次完整的操作。那么正正的概率是1&#x2F;4，正反的概率是1&#x2F;4，反反的概率是1&#x2F;4，反正的概率是1&#x2F;4.<br>正正的话，期望为1&#x2F;4*2<br>正反&#x2F;反反的话，浪费两次机会，接下来的投掷过程和没有之前的这两次投掷是一样的。所以有1&#x2F;2*（x+2）；<br>反正的话，由于第三次不知道，所以只是浪费一次机会，投掷完第一次后再投和没有投这第一次的过程是一样的，于是又1&#x2F;4*（x+1）.<br>根据E（E（x）） &#x3D; E（x），那么x&#x3D; 0.5*（x+2）+0.25*(x+1)+0.25,解方程得x&#x3D;8。</p>
<p>将情况推广到n次连续正面，我们可以作此分析：</p>
<ol>
<li>n次都连续向上的概率是0.5^n</li>
<li>浪费n-1次机会的情况是只要第n次是反面，前面都是无论是什么都被浪费了，概率是0.5</li>
<li>浪费n-2 次机会的情况是第n次是正面，第n-1次是反面，概率是0.5^2.<br> ……</li>
<li>以此类推，浪费n-i次的概率是0.5^i.<br>于是相加得到X &#x3D; 0.5^n+求和i&#x3D;1到n（n-i+X）*0.5^i。但是这样依旧不好求。</li>
</ol>
<p>还有一个巧妙的思路是利用迭代。首先，我们假设F(n)代表投掷一枚硬币连续出现n次正面的期望次数，于是F(n+1) 的值我们可以这么来构造：我们已经投掷了F(n)次并连续出现了n次正面，再接着投一次，有0.5的概率是正面，那么F(n+1)的值<strong>此时</strong>就等于F(n)+1。而0.5的概率出现反面，则前功尽弃，在这个条件下，我们只能继续再投F(n+1) 次。于是我们就有了迭代公式：F(n+1) &#x3D; 0.5*(F(n)+1)+0.5*F(n+1)。</p>
<ul>
<li>这里看似和上面的推理很相似，但其实是完全不同的思想。前面一种我们设定的是一个值，然后构造出一些关系直接求解，我们并不需要初始值。而后面这种我们构造的是一种迭代关系，我们需要初始值才能求出解。</li>
<li>F(n+1) &#x3D; 0.5*(F(n)+1)+0.5<em>F(n+1)的推导很简单： 首先把式子变一下，让B(n) &#x3D;F(n)+2,于是B(n+1) &#x3D; 2</em>B(n),于是根据等比数列的公式知B(n) &#x3D; 2^(n-1)B(1). 然后B(1) &#x3D;F(1)+2 &#x3D;4，后面的不再赘述。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://www.matrix67.com/blog/archives/3638">用数学解赌博问题不稀奇，用赌博解数学问题才牛B</a><br>另外还有一些扩展题：<a target="_blank" rel="noopener" href="http://www.raychase.net/3144">几道抛硬币问题</a></p>
<h2 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h2><p>有一枚硬币，投掷它正面的概率是51%，如何通过这枚硬币构造出1&#x2F;32.</p>
<h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><p>1&#x2F;32不难联想到1&#x2F;2的5次方。但是如何构造1&#x2F;2呢？<br>我们可以通过连续投掷两次硬币，记录下正反，反正出现的次数，而遇到正正，反反则不做处理继续投掷。那么正反和反正出现的概率是一样的，都是51%*（1-51%），如果把这两种情况看作一个随机变量的全集的话，P（正反)&#x3D;P(反正)&#x3D;1&#x2F;2.<br>于是，要构造出一个概率为1&#x2F;32的事件也就可以是正反连续出现5次，或者反正连续出现五次，或者正反，反正，正反…..总之只需要这5次里出现的事件是固定的。</p>
<h2 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h2><p>用一枚均匀的硬币随机生成 1 到 6 之间的整数。</p>
<h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><p>答案也很类似，就是连续投掷3次，那么就有8中结果（2的3次方），这八种结果出现的概率是一样的。如果我们要生成的是1到8之间的数，那么我们就可以直接让出现正正正为1，正反正为2等等。但是这里只需要6中怎么办？直接舍弃掉其中的两种，比如我们遇到正正正，或者反反反就重来。那么不就生成了1到6么？</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>所以思路其实是对随机事件空间的修改，于是我们便可以根据事件发生概率的比例来重新构造概率。这里的其实每一个事件发生的概率都是一样的，所以我们去掉一些后，概率就变成了1&#x2F;n+k-&gt;1&#x2F;n。但是如果一开始这些随机事件的概率序列就不是相等的，比如是{a,b,c,d,e}对应的概率是{1&#x2F;15，2&#x2F;15，3&#x2F;15，4&#x2F;15，5&#x2F;15}，那么我们要构造比如说2&#x2F;3的概率就可以是去掉c,d,e,然后只剩下a和b的概率比是1：2，那么出现事件b的概率就是2&#x2F;3 。</p>
<h3 id="扩展题"><a href="#扩展题" class="headerlink" title="扩展题"></a>扩展题</h3><p>用两枚硬币随机生成 1 到 n 之间的整数，要求在有限次数内得到。如何设计这两个硬币？<br>我们先假设生成1~6之间的整数，再从具体到抽象。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如果你有一枚公正的、正反概率相同的硬币，以及一枚不公正的、正反概率之比为 1 : 2 的硬币，那么你也能概率均等地生成一个 1 到 6 之间的整数。首先抛掷那枚不公正的硬币，那么结果有 1&#x2F;3 的概率是正面朝上，有 2&#x2F;3 的概率是反面朝上。如果出现了正面朝上的情况，那么令 i &#x3D; 1 ；如果出现了反面朝上的情况，那么就再抛掷那枚公正的硬币，掷出正面则令 i &#x3D; 2 ，掷出反面则令 i &#x3D; 3 。最后，再抛掷一次公正的硬币，如果正面朝上则令 j &#x3D; 0 ，如果反面朝上则令 j &#x3D; 3 。容易看出， i + j 的值有 1, 2, 3, 4, 5, 6 这六种可能，它们出现的概率是均等的，都是 1&#x2F;6 。</p>
<p>具体推导过程见下文：<br><a target="_blank" rel="noopener" href="http://www.matrix67.com/blog/archives/6151">趣题：用两枚硬币随机生成 1 到 n 之间的整数</a></p>
<p>其实背后的思想就是，通过条件概率的形式来获取不同概率的乘积，从而达到不同的概率。比如我们可以把硬币看作是一个生成器，生成两个概率（其和为一）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/07/02/1-%E6%8A%95%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98/" data-id="cl0t1dcys001u8slf5bcu051z" data-title="1-投硬币问题" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/quant-interview/" rel="tag">quant interview</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【ucore】lab1-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/13/%E3%80%90ucore%E3%80%91lab1-2/" class="article-date">
  <time class="dt-published" datetime="2018-06-13T03:21:03.000Z" itemprop="datePublished">2018-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/13/%E3%80%90ucore%E3%80%91lab1-2/">【ucore】lab1-2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>为了熟悉使用qemu和gdb进行的调试工作，我们进行如下的小练习：</p>
<ol>
<li><p>从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。</p>
</li>
<li><p>在初始化位置0x7c00设置实地址断点,测试断点正常。</p>
</li>
<li><p>从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。</p>
</li>
<li><p>自己找一个bootloader或内核中的代码位置，设置断点并进行测试。</p>
</li>
</ol>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p> 首先我们注意到makefile的这些规则:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># files for grade script</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: qemu qemu-nox debug debug-nox</span></span><br><span class="line"><span class="section">qemu-mon: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(QEMU)</span>  -no-reboot -monitor stdio -hda <span class="variable">$&lt;</span> -serial null</span><br><span class="line"><span class="section">qemu: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(QEMU)</span> -no-reboot -parallel stdio -hda <span class="variable">$&lt;</span> -serial null</span><br><span class="line"><span class="section">log: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(QEMU)</span> -no-reboot -d int,cpu_reset  -D q.log -parallel stdio -hda <span class="variable">$&lt;</span> -serial null</span><br><span class="line"><span class="section">qemu-nox: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(QEMU)</span>   -no-reboot -serial mon:stdio -hda <span class="variable">$&lt;</span> -nographic</span><br><span class="line">TERMINAL        :=gnome-terminal</span><br><span class="line"><span class="section">debug: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(QEMU)</span> -S -s -parallel stdio -hda <span class="variable">$&lt;</span> -serial null &amp;</span><br><span class="line">	<span class="variable">$(V)</span>sleep 2</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(TERMINAL)</span> -e <span class="string">&quot;gdb -q -tui -x tools/gdbinit&quot;</span></span><br><span class="line">	</span><br><span class="line"><span class="section">debug-nox: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(QEMU)</span> -S -s -serial mon:stdio -hda <span class="variable">$&lt;</span> -nographic &amp;</span><br><span class="line">	<span class="variable">$(V)</span>sleep 2</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(TERMINAL)</span> -e <span class="string">&quot;gdb -q -x tools/gdbinit&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到有各种各样的伪指令,也就是没有目标文件生成的指令.我们使用<code>make debug</code>这条指令模拟开机的同时进入debug模式.输出如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x000f0090 <span class="keyword">in</span> ?? ()</span><br><span class="line">Breakpoint 1 at 0x100006: file kern/init/init.c, line 19.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, kern_init () at kern/init/init.c:19</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>

<p>发现这里已经有一个断点了,为什么?仔细看debug这条伪指令, 下面是来自<a target="_blank" rel="noopener" href="https://sourceware.org/gdb/current/onlinedocs/gdb/Mode-Options.html#index-_002d_002dquiet">GDB</a>的参考</p>
<blockquote>
<ol>
<li><code>-q</code><br>“Quiet”. Do not print the introductory and copyright messages. These messages are also suppressed in batch mode.</li>
<li><code>-tui</code><br>Activate the <em>Text User Interface</em> when starting. The Text User Interface manages several text windows on the terminal, showing source, assembly, registers and GDB command outputs </li>
<li><code>-x file</code><br>Execute commands from file file.</li>
</ol>
</blockquote>
<p>所以gdb的开启命令表示,</p>
<pre><code> 1. 不打印任何介绍或者版权信息,
    2. 开启Text User Interface,也就是在文本窗口里展示多个输出,比如源代码,汇编代码,寄存器等的信息.这样帮助我们更好地调试.
    3. 从当前目录下的tools/gdbinit文件读取命令,一行一行依次执行.
</code></pre>
<p>然后我们看tools&#x2F;gdbinit文件里的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file bin/kernel</span><br><span class="line">target remote :1234</span><br><span class="line">break kern_init</span><br><span class="line">continue</span><br></pre></td></tr></table></figure>

<p>参考:</p>
<blockquote>
<p><code>file filename</code></p>
<p>Use filename as the program to be debugged.</p>
</blockquote>
<p>因此我们大概知道make gdb后gdb把bin&#x2F;kernel当作debug的程序,并且在kern_init处设置了断点.但是我们是要从BIOS处开始debug,所以我们可以修改一下gdbinit来达到我们的目的.当然也可以使用make qemu</p>
<p><a target="_blank" rel="noopener" href="https://qemu.weilnetz.de/doc/qemu-doc.html#pcsys_005fmonitor">qemu</a>,也就可以参考<a target="_blank" rel="noopener" href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_2_4_2_1_qemu_runtime_arguments.html">ucore的说明</a></p>
<blockquote>
<ol>
<li><p>-no-reboot: Exit instead of rebooting.</p>
</li>
<li><p>-hda file</p>
<p>-hdb file</p>
<p>-hdc file</p>
<p>-hdd file</p>
<p>Use file as hard disk 0, 1, 2 or 3 image</p>
</li>
<li><p>-serial dev</p>
</li>
</ol>
<p>   Redirect the virtual serial port to host character device dev. The default device is <code>vc</code> in graphical mode and <code>stdio</code> in non graphical mode.</p>
<p>   -serial null: void device</p>
</blockquote>
<p>OK, 那么我们要单步追踪BIOS的话,因为这个BIOS并不在我们写的文件里.但是我们知道BIOS的执行位置其实是约定俗成的,具体参考<a target="_blank" rel="noopener" href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_1_bios_booting.html">BIOS启动过程</a>. PC通电后会自动把CS&#x3D;0xf000, IP&#x3D;0xfff0.因此我们可以在内存0xffff0处设置一个断点.</p>
<h2 id="从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行"><a href="#从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行" class="headerlink" title="从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行"></a>从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行</h2><p>由于现在我们假设的架构是i8086,也就是16位模式实模式.我们知道PC加点后的CS:IP&#x3D;0xF000:0XFFF0. 那么我们可以给这个地址加一个断点看看.将tools&#x2F;gdbinit设置成如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set architecture i8086</span><br><span class="line">target remote localhost:1234</span><br><span class="line">break *0xfff0</span><br><span class="line">continue</span><br><span class="line">x /2i $pc</span><br></pre></td></tr></table></figure>

<ul>
<li><input disabled="" type="checkbox"> 然而输出很奇怪</li>
</ul>
<h2 id="在初始化位置0x7c00设置实地址断点-测试断点正常"><a href="#在初始化位置0x7c00设置实地址断点-测试断点正常" class="headerlink" title="在初始化位置0x7c00设置实地址断点,测试断点正常"></a>在初始化位置0x7c00设置实地址断点,测试断点正常</h2><p>比如将tools&#x2F;gdbinit改成下面:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set architecture i8086</span><br><span class="line">target remote localhost:1234</span><br><span class="line">break *0x7c00</span><br><span class="line">continue</span><br><span class="line">x /2i $pc</span><br></pre></td></tr></table></figure>

<p>于是输出便是:</p>
<figure class="highlight plaintext"><figcaption><span>target architecture is assumed to be i8086</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">Breakpoint 1 at 0x7c00</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">=&gt; 0x7c00:      cli</span><br><span class="line">   0x7c01:      cld</span><br></pre></td></tr></table></figure>

<p>接下来的不再赘述.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/06/13/%E3%80%90ucore%E3%80%91lab1-2/" data-id="cl0t1dcyp001j8slf281rbgb6" data-title="【ucore】lab1-2" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ucore/" rel="tag">ucore</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【ucore】lab1-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/12/%E3%80%90ucore%E3%80%91lab1-1/" class="article-date">
  <time class="dt-published" datetime="2018-06-12T03:19:31.000Z" itemprop="datePublished">2018-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/12/%E3%80%90ucore%E3%80%91lab1-1/">【ucore】lab1-1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ol>
<li><a target="_blank" rel="noopener" href="https://seisman.github.io/how-to-write-makefile/overview.html">跟我一起写Makefile</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/index.html#SEC_Contents">GUN make</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/u013484370/article/details/50638353">ucore中Makefile 内核文件组织全解析，学习软件的组织方式</a></li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>命令部分的语法主要是来自于UNIX下的标准shell语法</li>
<li>变量的取值是简单的文本替换</li>
</ol>
<h2 id="操作系统镜像文件ucore-img是如何一步一步生成的？"><a href="#操作系统镜像文件ucore-img是如何一步一步生成的？" class="headerlink" title="操作系统镜像文件ucore.img是如何一步一步生成的？"></a>操作系统镜像文件ucore.img是如何一步一步生成的？</h2><ul>
<li>程序静态分析（Program Static Analysis）是指在不运行代码的方式下，通过词法分析、语法分析、控制流、数据流分析等技术对程序代码进行扫描，验证代码是否满足规范性、安全性、可靠性、可维护性等指标的一种代码分析技术。</li>
<li>首先我们要知道这个make过程,大部分是通过变量定义来实现编译的.而不是最普通的目标:前置文件;生成命令这种形式. 因为初始化参数实在分析规则前.<ul>
<li>makefile的步骤是首先定义了一些参数, 然后include tools&#x2F;function.mk.</li>
<li>这个文件里虽然没有目标文件,但其实通过define cc_template这个变量,定义了很多生成,o文件的命令.</li>
<li>在makefile里通过传入bootblock和kernel的源文件,使用function.mk生成.o文件.</li>
</ul>
</li>
<li>所以其实我们的第一条正式的target,是$(kernel): tools&#x2F;kernel.ld.但是它是一个目标文件多规则,所以最终会执行kernel的第二个规则:$(kernel): $(KOBJS)……<ul>
<li>这个规则主要是给编译后的kernel中间文件做链接.</li>
<li>然后生成一些asm文件,也就是汇编代码和c语言对应的文件</li>
</ul>
</li>
<li>然后是生成bootblock,和kernel类似,只不过多了一步启动区的启动扇区签名的步骤，即有效启动扇区，最后字节为0x55aa。而这一步是由sign来做的.<ul>
<li>但是这一步为什么会执行呢?变量会自动生成,但是这是一个生成规则,我们的第一个target也就是kernel并没有把bootblock作为前置文件,那么make就不会执行这一条规则才对?</li>
</ul>
</li>
<li>最后ucore.img的操作是模拟一个硬盘,通过dd把kernel和bootblock都写进去.<h2 id="ucore-img"><a href="#ucore-img" class="headerlink" title="ucore.img"></a>ucore.img</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create ucore.img</span></span><br><span class="line">UCOREIMG:= <span class="variable">$(<span class="built_in">call</span> totarget,ucore.img)</span></span><br><span class="line"><span class="variable">$(UCOREIMG)</span>: <span class="variable">$(kernel)</span> <span class="variable">$(bootblock)</span></span><br><span class="line">	<span class="variable">$(V)</span>dd if=/dev/zero of=<span class="variable">$@</span> count=10000</span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(bootblock)</span> of=<span class="variable">$@</span> conv=notrunc</span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(kernel)</span> of=<span class="variable">$@</span> seek=1 conv=notrunc</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,ucore.img)</span></span><br></pre></td></tr></table></figure>
这个是生成ucore.img的代码,这里可以看到ucore.img是以kernel和bootblock为前置条件,然后通过dd命令写入10000byte的0到目标文件,然后把bootblock和kernel都写进去.至于totarget是在function.mk里定义的,其中BINDIR在makefile里定义的,等于bin<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">totarget = <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(BINDIR)</span><span class="variable">$(SLASH)</span>,$(1)</span>)</span><br></pre></td></tr></table></figure>
所以,这句话的作用就是给$(1)加一个前缀bin&#x2F;,所以UCOREIMG:&#x3D; $(call totarget,ucore.img)整句话的意思就是给ucore.img加个前缀.让UCOREIMG&#x3D;bin&#x2F;ucore.img,那么我生成的ucore.img就会存放在bin目录下.</li>
</ul>
<h3 id="输出内容检查"><a href="#输出内容检查" class="headerlink" title="输出内容检查"></a>输出内容检查</h3><blockquote>
<p>dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;bin&#x2F;ucore.img count&#x3D;10000<br>dd if&#x3D;bin&#x2F;bootblock of&#x3D;bin&#x2F;ucore.img conv&#x3D;notrunc<br>dd if&#x3D;bin&#x2F;kernel of&#x3D;bin&#x2F;ucore.img seek&#x3D;1 conv&#x3D;notrunc</p>
</blockquote>
<h2 id="bootblock"><a href="#bootblock" class="headerlink" title="bootblock"></a>bootblock</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create bootblock</span></span><br><span class="line">bootfiles = <span class="variable">$(<span class="built_in">call</span> listf_cc,boot)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(bootfiles)</span>,$(<span class="built_in">call</span> cc_compile,<span class="variable">$(f)</span>,<span class="variable">$(CC)</span>,<span class="variable">$(CFLAGS)</span> -Os -nostdinc)</span>)</span><br><span class="line">bootblock = <span class="variable">$(<span class="built_in">call</span> totarget,bootblock)</span></span><br><span class="line"><span class="variable">$(bootblock)</span>: <span class="variable">$(<span class="built_in">call</span> toobj,<span class="variable">$(bootfiles)</span>)</span> | <span class="variable">$(<span class="built_in">call</span> totarget,sign)</span></span><br><span class="line">	@echo + ld <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 <span class="variable">$^</span> -o <span class="variable">$(<span class="built_in">call</span> toobj,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJCOPY)</span> -S -O binary <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(<span class="built_in">call</span> totarget,sign)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span> <span class="variable">$(bootblock)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,bootblock)</span></span><br></pre></td></tr></table></figure>
<p>一句句看:</p>
<h4 id="找到编译bootblock的源文件"><a href="#找到编译bootblock的源文件" class="headerlink" title="找到编译bootblock的源文件"></a>找到编译bootblock的源文件</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bootfiles = <span class="variable">$(<span class="built_in">call</span> listf_cc,boot)</span></span><br><span class="line"><span class="comment">#与此有关的是:</span></span><br><span class="line">listf_cc = <span class="variable">$(<span class="built_in">call</span> listf,$(1)</span>,<span class="variable">$(CTYPE)</span>)</span><br><span class="line">listf = <span class="variable">$(<span class="built_in">filter</span> $(<span class="built_in">if</span> $(2)</span>,<span class="variable">$(<span class="built_in">addprefix</span> %.,$(2)</span>),%),\<span class="variable">$(<span class="built_in">wildcard</span> $(<span class="built_in">addsuffix</span> <span class="variable">$(SLASH)</span>*,$(1)</span>)))</span><br><span class="line">CTYPE	:= c S</span><br></pre></td></tr></table></figure>
<p>listf的作用是做一个fliter, 把$(1)目录下的所有文件(因为这里是一个*的通配符,)留下类似于%.$(2)形式的.也就是挑选$(1)下后缀是在$(2)中的文件. CTYPE中给出了c和S,也就是把所有boot下.S和.c文件都返回给bootfiles</p>
<h4 id="编译成-o文件"><a href="#编译成-o文件" class="headerlink" title="编译成.o文件"></a>编译成.o文件</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(bootfiles)</span>,$(<span class="built_in">call</span> cc_compile,<span class="variable">$(f)</span>,<span class="variable">$(CC)</span>,<span class="variable">$(CFLAGS)</span> -Os -nostdinc)</span>)</span><br><span class="line"><span class="comment">#与此有关的代码有:</span></span><br><span class="line"><span class="keyword">define</span> do_cc_compile</span><br><span class="line">$<span class="variable">$(<span class="built_in">foreach</span> f,$(1)</span>,cc_template,$<span class="variable">$(f)</span>,$(2),$(3),$(4))))</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line">cc_compile = <span class="variable">$(<span class="built_in">eval</span> $(<span class="built_in">call</span> do_cc_compile,$(1)</span>,$(2),$(3),$(4)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> cc_template</span><br><span class="line">$<span class="variable">$(<span class="built_in">call</span> todep,$(1)</span>,$(4)): $(1) | $$$<span class="variable">$(<span class="built_in">dir</span> $$$<span class="variable">$@</span>)</span></span><br><span class="line">	@$(2) -I$<span class="variable">$(<span class="built_in">dir</span> $(1)</span>) $(3) -MM $<span class="variable">$&lt;</span> -MT <span class="string">&quot;$$(patsubst %.d,%.o,$<span class="variable">$@</span>) $<span class="variable">$@</span>&quot;</span>&gt; $<span class="variable">$@</span></span><br><span class="line">$<span class="variable">$(<span class="built_in">call</span> toobj,$(1)</span>,$(4)): $(1) | $$$<span class="variable">$(<span class="built_in">dir</span> $$$<span class="variable">$@</span>)</span></span><br><span class="line">	@echo + cc $<span class="variable">$&lt;</span></span><br><span class="line">	<span class="variable">$(V)</span>$(2) -I$<span class="variable">$(<span class="built_in">dir</span> $(1)</span>) $(3) -c $<span class="variable">$&lt;</span> -o $<span class="variable">$@</span></span><br><span class="line">ALLOBJS += $<span class="variable">$(<span class="built_in">call</span> toobj,$(1)</span>,$(4))</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>$(eval text)的作用是把text作为makefile的一部分通过make解析.因为一般来讲,makefile里的函数都是通过参数动态生成命令传递给shell执行,也就是gcc之类的. 但是eval是一个可以通过参数动态生成makefile自身代码的函数.所以要注意的是, 如果在text中有参数,要考虑到eval函数的两次展开.因为text中的一个$var通过eval后呈现给make的makefile指令是var,所以如果我们是要给makefile呈现出一个$var则var应该写成$$var.</p>
</li>
<li><p>于是我们知道其实最终的代码主要是写在do_cc_template里,而网上的包含关系是:do_cc_template-&gt;cc_template-&gt;do_cc_compile-&gt;cc_compile-&gt;$(bootblock)下的命令 ,而没脱去一次父调用,eval函数就要做一次对变量的取值操作,相当于去掉一个$.但是对于临时变量$(1)等不要变.最后一层层解析上去后的代码是:</p>
<ul>
<li><p>cc_compile最终会呈现的语法是:<code>$(foreach f,$(1),$(eval $(call cc_template,$(f),$(2),$(3),$(4))))</code></p>
</li>
<li><p>于是第一行对cc_compile有调用, 代码变成对于每一个在$(1)的f执行</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> todep,$(1)</span>,$(4)): $(1) | $<span class="variable">$(<span class="built_in">dir</span> $<span class="variable">$@</span>)</span></span><br><span class="line">	@$(2) -I<span class="variable">$(<span class="built_in">dir</span> $(1)</span>) $(3) -MM <span class="variable">$&lt;</span> -MT <span class="string">&quot;$(patsubst %.d,%.o,<span class="variable">$@</span>) <span class="variable">$@</span>&quot;</span>&gt; <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> toobj,$(1)</span>,$(4)): $(1) | $<span class="variable">$(<span class="built_in">dir</span> $<span class="variable">$@</span>)</span></span><br><span class="line">	@echo + cc <span class="variable">$&lt;</span></span><br><span class="line">	@$(2) -I<span class="variable">$(<span class="built_in">dir</span> $(1)</span>) $(3) -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span>  <span class="comment">#注意前面的$(V)已经被解析成@</span></span><br><span class="line">ALLOBJS += <span class="variable">$(<span class="built_in">call</span> toobj,$(1)</span>,$(4))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>于是我们看参数<code>CC:= $(GCCPREFIX)gcc</code>, 细节太多,可以慢慢去代入,一步步推敲,总的来说这一句话就把boot&#x2F;目录下所有的.c和.S都编译成了.o文件.</p>
<ul>
<li>编辑目标文件的位置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 开始第二条bootblock规则</span><br><span class="line"></span><br><span class="line">```@echo + ld $@```打印&quot;+ ld &lt;所有当前目录下的文件名&gt;,然后第二条就是ld命令,也就是对生成的.o文件进行链接.</span><br><span class="line"></span><br><span class="line">最后两个OBJDUMP和OBJCOPY的命令主要是gcc里的命令,用来输出汇编文件与C语言对应输出的.asm文件.</span><br><span class="line"></span><br><span class="line">#### 查找对应的输出语句</span><br><span class="line"></span><br><span class="line">+ 对于```$(V)$(2) -I$$(dir $(1)) $(3) -c $$&lt; -o $$@```这一句,由于我们使用的make V:=因此这里的输出没有被屏蔽, 可以从输出里看到</span><br><span class="line"></span><br><span class="line">+ &gt; gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o</span><br><span class="line"></span><br><span class="line">+ 注意到call toobj处下面有一行命令```+ cc $$&lt;```这里可以对应make输出文件里一系列+ cc 前置文件名</span><br><span class="line">  &gt; \+ cc boot/bootasm.S</span><br><span class="line">  &gt; \+ cc boot/bootmain.c</span><br><span class="line">  &gt; \+ cc tools/sign.c</span><br><span class="line"></span><br><span class="line">+ 而@echo + ld $@也可以找到其输出为:\+ ld bin/bootblock </span><br><span class="line"></span><br><span class="line">还有一些都是可以一一对应的.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## kernel</span><br><span class="line"></span><br><span class="line">然后我们可以看看前置条件之一的kernel的规则:</span><br><span class="line">```makefile</span><br><span class="line"># create kernel target</span><br><span class="line">kernel = $(call totarget,kernel)</span><br><span class="line"></span><br><span class="line">$(kernel): tools/kernel.ld</span><br><span class="line"></span><br><span class="line">$(kernel): $(KOBJS)</span><br><span class="line">	@echo + ld $@</span><br><span class="line">	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)</span><br><span class="line">	@$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel)</span><br><span class="line">	@$(OBJDUMP) -t $@ | $(SED) &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; $(call symfile,kernel)</span><br><span class="line">$(call create_target,kernel)</span><br></pre></td></tr></table></figure>
<p>这里的$(kernel)同理可得是bin&#x2F;kernel,然后kernel规则有两个一个的前置条件是tools&#x2F;kernel.ld,一个是$(KOBJS). $(KOBJS)的定义如下:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KOBJS	= <span class="variable">$(<span class="built_in">call</span> read_packet,kernel libs)</span></span><br><span class="line"><span class="comment">#有关的代码</span></span><br><span class="line">read_packet = <span class="variable">$(<span class="built_in">foreach</span> p,$(<span class="built_in">call</span> packetname,$(1)</span>),$(<span class="variable">$(p)</span>))</span><br><span class="line"><span class="comment"># change $(name) to $(OBJPREFIX)$(name): (#names)</span></span><br><span class="line">packetname = <span class="variable">$(<span class="built_in">if</span> $(1)</span>,<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(OBJPREFIX)</span>,$(1)</span>),<span class="variable">$(OBJPREFIX)</span>)</span><br><span class="line">OBJPREFIX	:= __objs_</span><br></pre></td></tr></table></figure>

<p>所以这里$(1)就是kernel libs,依次对__objs_&#x2F;kernel和__objs_&#x2F;libs做$($(p))操作.不太懂这里要做什么</p>
<p>然后就是输出 + ld bin&#x2F;kernel,然后就是开始链接操作,需要注意的是, 这里-o后面有两个参数,一个$@可以理解,生成当前的目标文件bin&#x2F;kernel, 然而还要生成KOBJ, 那么可以猜到KOBJ是我们文件里多出来的obj&#x2F;目录下的kern文件夹和libs文件夹.</p>
<p>##一个被系统认为是符合规范的硬盘主引导扇区的特征是什么<br>###makefile部分</p>
<p>我们知道给引导扇区签名的逻辑是写在sign.c里的.那么我们先来看看相关代码:<br>首先是makefile里的:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create &#x27;sign&#x27; tools</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> add_files_host,tools/sign.c,sign,sign)</span><span class="comment">#1</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target_host,sign,sign)</span><span class="comment">#2</span></span><br><span class="line"><span class="comment"># 相关代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for hostcc</span></span><br><span class="line">add_files_host = <span class="variable">$(<span class="built_in">call</span> add_files,$(1)</span>,<span class="variable">$(HOSTCC)</span>,<span class="variable">$(HOSTCFLAGS)</span>,$(2),$(3))</span><br><span class="line">create_target_host = <span class="variable">$(<span class="built_in">call</span> create_target,$(1)</span>,$(2),$(3),<span class="variable">$(HOSTCC)</span>,<span class="variable">$(HOSTCFLAGS)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add files to packet: (#files, cc[, flags, packet, dir])</span></span><br><span class="line">add_files = <span class="variable">$(<span class="built_in">eval</span> $(<span class="built_in">call</span> do_add_files_to_packet,$(1)</span>,$(2),$(3),$(4),$(5)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># add files to packet: (#files, cc[, flags, packet, dir])</span></span><br><span class="line"><span class="keyword">define</span> do_add_files_to_packet</span><br><span class="line">__temp_packet__ := <span class="variable">$(<span class="built_in">call</span> packetname,$(4)</span>) <span class="comment">#__objs_sign_</span></span><br><span class="line"><span class="keyword">ifeq</span> ($<span class="variable">$(<span class="built_in">origin</span> $<span class="variable">$(__temp_packet__)</span>)</span>,undefined)</span><br><span class="line">$<span class="variable">$(__temp_packet__)</span> :=</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">__temp_objs__ := <span class="variable">$(<span class="built_in">call</span> toobj,$(1)</span>,$(5))<span class="comment">#obj/sign/tools/sign.o</span></span><br><span class="line">$<span class="variable">$(<span class="built_in">foreach</span> f,$(1)</span>,$<span class="variable">$(<span class="built_in">eval</span> $$(<span class="built_in">call</span> cc_template,$<span class="variable">$(f)</span>,$(2)</span>,$(3),$(5))))</span><br><span class="line">$<span class="variable">$(__temp_packet__)</span> += $<span class="variable">$(__temp_objs__)</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add packets and objs to target (target, #packes, #objs[, cc, flags])</span></span><br><span class="line"><span class="keyword">define</span> do_create_target</span><br><span class="line">__temp_target__ = <span class="variable">$(<span class="built_in">call</span> totarget,$(1)</span>) <span class="comment">#bin/sign</span></span><br><span class="line">__temp_objs__ = $<span class="variable">$(<span class="built_in">foreach</span> p,$(<span class="built_in">call</span> packetname,$(2)</span>),$$($<span class="variable">$(p)</span>)) $(3)<span class="comment">#__objs_sign_</span></span><br><span class="line">TARGETS += $<span class="variable">$(__temp_target__)</span></span><br><span class="line"><span class="keyword">ifneq</span> ($(4),)<span class="comment">#clang不为空,进入逻辑 </span></span><br><span class="line"><span class="section">$$(__temp_target__): $<span class="variable">$(__temp_objs__)</span> | $$$$(dir $$$<span class="variable">$@</span>)</span></span><br><span class="line">	<span class="variable">$(V)</span>$(4) $(5) $<span class="variable">$^</span> -o $<span class="variable">$@</span><span class="comment">#执行clang -g -Wall -O2 所有依赖文件 -o bin/sign</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="section">$$(__temp_target__): $<span class="variable">$(__temp_objs__)</span> | $$$$(dir $$$<span class="variable">$@</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># change $(name) to $(OBJPREFIX)$(name): (#names)</span></span><br><span class="line">packetname = <span class="variable">$(<span class="built_in">if</span> $(1)</span>,<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(OBJPREFIX)</span>,$(1)</span>),<span class="variable">$(OBJPREFIX)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get .o obj files: (#files[, packet])</span></span><br><span class="line">toobj = <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(OBJDIR)</span><span class="variable">$(SLASH)</span>$(<span class="built_in">if</span> $(2)</span>,$(2)<span class="variable">$(SLASH)</span>),\</span><br><span class="line">		<span class="variable">$(<span class="built_in">addsuffix</span> .o,$(<span class="built_in">basename</span> $(1)</span>)))</span><br><span class="line"></span><br><span class="line">OBJDIR	:= obj</span><br><span class="line">OBJPREFIX	:= __objs_</span><br><span class="line">HOSTCC		:= clang</span><br><span class="line">HOSTCFLAGS	:= -g -Wall -O2</span><br></pre></td></tr></table></figure>
<p>上面的注释写得很清楚,第一条指令是通过cc_compile生成对应的sign.d和sign.o文件.第二条指令是通过clang指令生成bin&#x2F;sign执行文件. 然后在bootblock的生成规则的命令里最后一行有执行bin&#x2F;sign这个执行文件.这样就达到了给bootblock签名的目的.为了下面一步的分析: 把执行命令写在这:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="variable">$(<span class="built_in">call</span> totarget,sign)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span> <span class="variable">$(bootblock)</span></span><br><span class="line">一个一个转化,也就是bin/sign obj/bootblock.out bin/bootblcok.</span><br></pre></td></tr></table></figure>

<p>###sign.c部分</p>
<p>于是, 对于sign.c里的main函数来讲,其argc&#x3D;3, argv[1]&#x3D;obj&#x2F;bootblock.argv[2]&#x3D;out bin&#x2F;bootblcok.一句句往下执行.</p>
<p>首先是一个<a target="_blank" rel="noopener" href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/sysstat.h.html">stat</a>的结构st,然后是函数<a target="_blank" rel="noopener" href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/stat.html">stat</a>,<code>int stat(const char *path, struct stat *buf);</code>于是<code>stat(argv[1], &amp;st)</code>的作用是把obj&#x2F;bootblock.out的stat信息存到st里去,返回0表示读取成功. stat信息包括很多,比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dev_t     st_dev     ID of device containing file</span><br><span class="line">ino_t     st_ino     file serial number</span><br><span class="line">mode_t    st_mode    mode of file (see below)</span><br><span class="line">nlink_t   st_nlink   number of links to the file</span><br><span class="line">uid_t     st_uid     user ID of file</span><br><span class="line">gid_t     st_gid     group ID of file</span><br><span class="line">dev_t     st_rdev    device ID (if file is character or block special)</span><br><span class="line">off_t     st_size    file size in bytes (if file is a regular file)</span><br><span class="line">time_t    st_atime   time of last access</span><br><span class="line">time_t    st_mtime   time of last data modification</span><br><span class="line">time_t    st_ctime   time of last status change</span><br><span class="line">blksize_t st_blksize a filesystem-specific preferred I/O block size for</span><br><span class="line">                     this object.  In some filesystem types, this may</span><br><span class="line">                     vary from file to file</span><br><span class="line">blkcnt_t  st_blocks  number of blocks allocated for this object</span><br></pre></td></tr></table></figure>

<p>读取完后,就会有一个输出,从make的输出文件可以知道输出的是:’obj&#x2F;bootblock.out’ size: 488 bytes.</p>
<p>然后判断bootblock是不是小于510bytes,因此一个扇区是512,启动扇区只能占用一个扇区也就是512bytes.由于我们还要签名2bytes,所以代码部分最多是510bytes.</p>
<p>然后申请512bytes的内存,把obj&#x2F;bootblock写进去</p>
<p>然后在第510byte里写0x55,第511byte里写0xAA.</p>
<p>最后把这段内存写进argv[2],也就是文件bin&#x2F;bootblcok.</p>
<p>打印信息: build 512 bytes boot sector: ‘bin&#x2F;bootblock’ success!</p>
<p>至此,一个启动扇区就做好了.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一个合格的启动扇区是最后两byte的内容为0xAA55,然后不能实际内容不能超过510bytes.</p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><ol>
<li><p>第一个target是生成kernel,那么bootblock和ucore.img不应该会执行,因为kernel生成规则里没有说kernel的生成依赖于bootblock和ucore.img.那么bootblock和ucore.img是怎样生成的呢?</p>
</li>
<li><pre><code class="bootfiles">  \$(foreach f,\$(bootfiles),\$(call cc_compile,\$(f),\$(CC),\$(CFLAGS) -Os -nostdinc))```这里的foreach会执行么?这里既不是在规则的命令内,也不是变量.
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>KOBJS是什么,也就是对一个文件夹目录做$($(p))有什么用?</p>
</li>
<li><p>__objs_是什么</p>
</li>
<li><p>tools&#x2F;kernel.ld 这个是最后的生成的可执行文件的header信息么?</p>
</li>
<li><p>sign.c里使用了memst这个内存分配函数,这个内存分配在这个阶段是有谁分配的?我们自己电脑的操作系统?</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/06/12/%E3%80%90ucore%E3%80%91lab1-1/" data-id="cl0t1dcyo001h8slfdbjt4jnu" data-title="【ucore】lab1-1" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ucore/" rel="tag">ucore</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【ucore】保护模式的内存地址机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/01/%E3%80%90ucore%E3%80%91%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2018-06-01T07:03:14.000Z" itemprop="datePublished">2018-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/01/%E3%80%90ucore%E3%80%91%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E6%9C%BA%E5%88%B6/">保护模式的内存地址机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学汇编的时候我们知道通过引入段地址和偏移地址,可以计算出物理地址.在8086CPU下就能访问到2^20byte内存.但是x86时代的计算机内存更大,而且对安全性要求也高.于是产生了这种机制(举个32位下的例子)–保护模式:</p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol>
<li>虚拟地址-&gt;线性地址<br>我们在所有应用程序里用的是虚拟地址,在实模式下,段寄存器里存储的就是段地址,但是在保护模式下,段寄存器或者叫段选择器里保存的是段选择子.</li>
</ol>
<p>全局描述符表(GDT)的线性基地址在GDTR中.<br>首先读取段选择器里的段选择子的一部分作为索引号在GDT查找,获得这个段的段描述符.当然还有一部分用来做一些权限控制.<br>从段描述符里找到段基址,与指令中的偏移值组合.得到线性地址.<br>值得注意的几个点:<br>GDT的线性基地址在GDTR中,而不是GDT存在GDTR中,GDT是存在内存中的.因此GDT的大小其实可变,不像下面的页表读取完硬件后就设定好了,也不用局限于GDTR的大小.<br>段描述符是8字节,除了段基址外,还有很多控制位.比如段界限,这个就用来与你的段偏移值进行比较,如果超过了这个界限,那么就是不被允许访问的.</p>
<ol start="2">
<li>线性地址-&gt;物理地址<br>如果我们没有开启页表,那么线性地址就是物理地址.<br>那么开启以后,其转换规则则如下:<ol>
<li>首先page directory的物理地址存在CR3这个寄存器里.</li>
<li>拿线性地址的前10位当序号,在page directory里找该线性地址对应的page table的PPN(physical page number),通过这个PPN找到page table的物理地址.至于如何找,我还不清楚.</li>
<li>再拿线性地址的第二个10位当序号,在这个对应的page table里找到对应的page table entry(PTE).</li>
<li>最后把找到的这个PTE的前20位替代掉线性地址的前20位(也就是我们刚才用来找page table entry的那20位),与后面的12位形成真正的物理地址(PA).</li>
</ol>
</li>
</ol>
<p>也就是类似于我们在8086的段地址不能直接从地址总线里得到,而是要通过一些查表的方式得到.在x86模式下,page directory的大小是2^32 bytes,也就是2^10 个条(entries),也就是有2^10次方个page table.而每一个page table也是2^10个条目.每一个条目决定了物理地址的前20位,也就是还有后12位作为偏移,也就是每一个page table条目指向的是一个2^12bytes的物理内存范围.</p>
<h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><ol>
<li>为什么是页表? 为什么不是简单的把地址总线加到31根,或者多设几个段地址,然后加上偏移地址也可以找到相应的PA?<ul>
<li><p>有效控制<br> 因为引入page table的方式,我们可以对内存进行更有力的控制,从而达到安全性的目的.上面的PTE和page table我们只用到了前面的20位形成PV,而每一个PTE和PD里的条目都是32位的,也就是说还有12位我们可以用来存储一些标志位,比如某一位的值为1则表示应用程序可以访问,又设置某一位的值可以限制该物理地址是可读还是可写,等等.</p>
</li>
<li><p>防止碎片化<br> 在分段模型下，内存的分配是不定长的，时间长了，内存空间就会碎片化，就有可能出现一种情况：内存空间是有的，但都是小块，无法分配给某个任务。为了解决这个问题，在支持分页功能后，分页功能将物理内存空间划分成逻辑上的页。页的大小是固定的，一般为 4KB，通过使用页，可以简化内存管理。</p>
</li>
</ul>
</li>
</ol>
<p>但是又不能只能有页机制,因为段基址带来的保护模式比较好.</p>
<ol>
<li>为什么是4kb?<br>那或者为什么把一个页表大小设置为4KB而不是4MB?为什么要分成两级,而不是简单的把让线性地址的前20位去当作index取找page table?而是前10位找page directory里的page table序号,然后再用中间的10位在某一个page table里找PPN?<br>页表分成4MB也可以,但是考虑到早期的计算机软件,4MB的内存对许多软件来说都非常的大,但是一个页表顶多能被一个应用程序占有,因此会造成内存浪费.<br>至于为什么分成两极,对于一个2^20大小的表,要随机查找是非常的耗时的.但是分成两次查找会有效率得多.至于为什么不分成3次,4次查找,当然是时间复杂度和空间复杂度的trade off,4个表要占用的物理内存太大了.</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/06/01/%E3%80%90ucore%E3%80%91%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E6%9C%BA%E5%88%B6/" data-id="cl0t1dcym001c8slf945v6equ" data-title="保护模式的内存地址机制" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-经典算法-动态规划" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/05/24/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="article-date">
  <time class="dt-published" datetime="2018-05-24T03:43:18.000Z" itemprop="datePublished">2018-05-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E5%AE%9D%E5%85%B8/">面试算法宝典</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/05/24/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">经典算法-动态规划</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol>
<li>确定这个问题用贪心算法解不出来；比如后面的决策可能会影响前面的判断。</li>
<li>固定住一些动态的部分，使得：</li>
</ol>
<ul>
<li>随着问题规模的扩大，有一个简单的表示方法来达到状态转移。</li>
<li>初始状态能够被确定并且有限。最直接的方法就是思考当n&#x3D;0到n&#x3D;1时的状态转移，然后再套用到转移方程中去。</li>
</ul>
<p>并不能像教科书一样文绉绉地下定义什么是状态，什么动态的部分。但是你把下面的题目和我的思路看一下就会懂。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/counting-bits/description/">338. Counting Bits</a><br>首先很容易想到的是，后一个状态是可以根据前一个状态得到的。从偶数+1变成奇数后的#（1）一定会加1，而奇数+1变成偶数就有一点麻烦。它会把第一个不是1的位的后面的1都变成0，而这个第一个不是1的位变成1.前面的1我们不会变，那么我们的任务其实就是数这个奇数第一个不为1的位后面有几个1以及前面有几个1.<br>但是这依然很麻烦，不如先写几个看一下规则，假设dp(n)表示数字n的二进制包含的1的个数。那么<br>$$<br>dp(0) &#x3D; 0;<br>dp(1) &#x3D; 1;<br>dp(2) &#x3D; 1; &#x3D; dp(2-0)+1<br>dp(3) &#x3D; 2; &#x3D; dp(3-2)+1<br>dp(4) &#x3D; 1;<br>dp(5) &#x3D; 2; &#x3D; dp(5-4)+1<br>dp(6) &#x3D; 2; &#x3D; dp(6-4)+1<br>dp(7) &#x3D; 3; &#x3D; dp(7-4)+1<br>dp(8) &#x3D; 1;<br>dp(9) &#x3D; 2; &#x3D; dp(9-8)+1<br>……<br>$$</p>
<p>那么规则就出现了。为什么是这样呢? 首先那个+1其实是对应的dp(2<sup>i</sup>)的值，因为它总是1，所以我们直接+1了。所以规律其实是$dp(n) &#x3D; dp(n-2<sup>i</sup>)+dp(2<sup>i</sup>)$.把2<sup>i</sup>作为起始点，因为它总是以一个1后面跟若干个0结尾。那么往上加1的话，它的1的个数就很好推断。仔细体会。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/min-cost-climbing-stairs/description/">746. Min Cost Climbing Stairs</a></p>
<ol>
<li>按照我们上面的思路，这个可以用贪心算法吗？<br> 显然不能。贪心算法是选择走一步还是两步时，选择cost小的那一个。但是看到第二个例子就知道不对。因为我当前选了小的很有可能导致我接下来不得不选大的那一个。如果这两者直接的cost之差不能彼此cover，那么就不是最小的cost之和。</li>
<li>固定住一些动态的部分。</li>
</ol>
<ul>
<li>首先我们先看看这里的动态部分是什么？在现在的位置上是走1步还是走2步。如果我们假设dp(l)表示到了l层所需的最小cost之和。那么如何决定是走两步还是一步呢？DP(l+2)&#x3D;min((DP(l+1)+cost(l+2)),(DP(l)+cost(l+1)))。那么状态转移方程式就出来了。</li>
<li><strong>要注意这里的结束不是停在第l层而是越过了第l层，因此不是DP(l)的意思是此时我们站在了第l+1层</strong></li>
<li>再考虑一下如何定义初始化状态呢？显然L是从0开始的。那么$DP(0) &#x3D; 0,DP(1)&#x3D;min(cost[0],cost[1]);DP(2) &#x3D; min(cost(0),cost(1))$.这里我们最好假设第-1层的cost永远是0.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/05/24/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" data-id="cl0t1dcz5003h8slf0wrk7nu1" data-title="经典算法-动态规划" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algroithm/" rel="tag">Algroithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【CSAPP】实验malloc-lab" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/29/%E3%80%90CSAPP%E3%80%91%E5%AE%9E%E9%AA%8Cmalloc-lab/" class="article-date">
  <time class="dt-published" datetime="2018-04-29T03:13:35.000Z" itemprop="datePublished">2018-04-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/29/%E3%80%90CSAPP%E3%80%91%E5%AE%9E%E9%AA%8Cmalloc-lab/">实验malloc_lab</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>这个实验就是要求我们实现自己的malloc和free函数，而不是用c标准库的。但是又不需要你太过于底层和细节，主要是堆内存的管理。至于真正对物理内存的处理，还有地址转换什么的都交给memlib.c里的函数去做。<br>要完成的函数有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h2><ol>
<li>memlib.c的作用：不是说要自己实现malloc吗？为什么还要使用mem_lib的函数？而且mem_lib里使用了malloc。其实这里我们的实验是要求我们对内存管理有一个实现，重点在于管理。如果完完全全不用malloc的话，我们的mm.c函数还要实现找到合适的物理内存页面，并且做一个维护。而如果我们使用mem_lib的话，就可以模拟OS的物理页面管理。</li>
<li>具体的实现可以先参考一下课本的mm.c里对空闲块的数据结构</li>
<li>需要注意c&#x2F;C++不对数组的下表边界做检测的。具体参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/ljx_5489464/article/details/50314677">数组的下标越界与内存溢出</a>,<a target="_blank" rel="noopener" href="https://www.xuebuyuan.com/967089.html">C语言为什么不执行数组边界的有效性检查</a></li>
<li>这里有一个我的误解。我以为不能用结构体。但其实如果直接声明定义结构体，其成员变量是放在栈上的。如果用new的话就是在堆上。所以我们在后面有更复杂的组织方法后可以采用结构体。</li>
<li>隐式空闲链表为什么要引入序言和结尾块？书上说是消除合并时边界条件的技巧。看其在find_fit里的for循环就知道这是为了让这个for循环有一个跳出的条件，以及一个循环开始的初始化条件。</li>
<li>对于实验源代码里的mm.c文件里的几个内存补齐代码，如下</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT 8 <span class="comment">//1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7) <span class="comment">//2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t))) <span class="comment">//3</span></span></span><br><span class="line">…… </span><br><span class="line"><span class="type">int</span> newsize = ALIGN(size + SIZE_T_SIZE); <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>先参考这个<a target="_blank" rel="noopener" href="https://blog.csdn.net/jsn_ze/article/details/74011396">内存补齐算法</a>能明白1,2。对于3就是一面size_t的大小不是8的倍数，对于4其实就是把头部的大小算进去以后的对齐。为什么要这样是因为我们在书里看到的32bit长的头部是因为size_t的内部就是一个int，因此块大小就是一个int能表示的大小。这里让这种关系更加抽象，如果我们内部size_t的实现不是一个int，而是一个别的长度的数据类型。我们就需要对这个头部进行内存对齐; 为什么需要单独的先对齐，因为我们规定返回的指针是内存对齐的，而返回的指针不是指向头部，而是指向有效载荷的。<br>8. 有一个虽然不重要但是特别要注意的是：team的信息一定要全部填好，不然会出错。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li><p>因为不能题目要求不能新建结构体等复杂的数据结构，于是对这个内存的管理全靠地址去推。我觉得直接用隐式空闲链表，也许会不错，先来试一下：<br><img src="http://static.zybuluo.com/Husy/m3z21teg443nvmplvlihmvbp/Screenshot%20from%202018-07-22%2015-15-00.png" alt="堆块的结构"></p>
<blockquote>
<p>Since the libc malloc always returns payload pointers that are aligned to 8 bytes, your malloc implementation should do likewise and always return 8-byte aligned pointers.<br>注意，书上是边界对齐。也就是块头部的地址是8的倍数就好。但是这里要求的是指向有效载荷起始地址的指针地址是8的倍数（虽然其实是一样的）。</p>
</blockquote>
</li>
<li><p>然后考虑mm_malloc的实现，获取到的size首先要对齐，把它变成最小的8的倍数。然后加上头部计算出最后需要的内存大小newSize，然后mem_sbrk申请； 然后把头部写进去。头部地址+4就是有效载荷起始地址。</p>
</li>
</ul>
<h2 id="注意的细节"><a href="#注意的细节" class="headerlink" title="注意的细节"></a>注意的细节</h2><ol>
<li>获取到有效载荷的指针p，p-4就该块的头部，将其视作一个int，然后修改最低位的分配1为0.</li>
<li>为了空间利用率高，我们肯定还需要合并空闲块。这里就需要看前后的块。但是显然这一种只有头部的结构看当前块的后一块是很方便的，看前一块就不方便了。因此按照书上的引入边界标记，引入脚部。只有头部可以类比于单链表，有了脚部就可以算作是双链表。</li>
</ol>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ol>
<li>线程安全的动态分配</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/github_35681219/article/details/52743048">什么是计算机的大小端规则？</a></li>
<li><a target="_blank" rel="noopener" href="https://wdxtub.com/2016/04/16/thick-csapp-lab-6/">【不周山之读厚 CSAPP】VI Malloc Lab</a></li>
<li><a target="_blank" rel="noopener" href="https://husy1994.github.io/2018/05/01/chap9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">chap9-虚拟内存</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/04/29/%E3%80%90CSAPP%E3%80%91%E5%AE%9E%E9%AA%8Cmalloc-lab/" data-id="cl0t1dcy600058slfhbhkd6o5" data-title="实验malloc_lab" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【CSAPP】Ch12-并发编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/27/%E3%80%90CSAPP%E3%80%91Ch12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2018-03-27T15:16:11.000Z" itemprop="datePublished">2018-03-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/27/%E3%80%90CSAPP%E3%80%91Ch12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">【CSAPP】Ch12-并发编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    本章节主要描述了三种不同维度的并发模型—进程、I&#x2F;O多路复用和线程。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ol>
<li>它是在一个进程内的逻辑流，共享该进程的全部虚拟空间。但是呢，彼此又有自己的栈和线程上下文，并且依旧是由内核来调度。</li>
<li>同一个进程里，线程与线程之间的关系是对等的，不会像进程一样有父子层级关系。</li>
<li>线程的分离状态决定了它以什么样的方式来结束自己。如果该线程是可结合的（默认）说明它可以被其它线程收回和杀死，再被其它线程杀死之前他的内存资源是不释放的。而分离状态的线程在执行完现在的程序后被系统自动回收。</li>
<li>线程的内存模型</li>
</ol>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol>
<li>IPC机制（进程间的通信）</li>
</ol>
<ul>
<li>信号是基本的IPC机制</li>
<li>套接字接口是另一种形式</li>
<li>管道</li>
<li>先进先出</li>
<li>系统V共享内存</li>
<li>系统V信号量</li>
</ul>
<ol start="2">
<li>I&#x2F;O多路复用技术</li>
</ol>
<ul>
<li>基本内容就是select函数。这个的思想就是，如果我们同时有多个端口要监听呢？比如我一个服务器同时要等待客户端的连接，又要等待来自自己标准输入的数据。那么我们就可以将accept替换成select。select维护一个读的数据集，从而可以同时管理多个文件描述符的读。写也一样。</li>
<li>有一个缺点就是，select没有使用fork来创建进程，那么一个拿上面的例子来说，一旦它连接到某个客户端就会连续会送输入行，那么这个时间里你在服务器的标准输入端输入数据你是得不到响应的。解决的方式可以是用更细粒度的多重复用，比如连接后服务器只处理一次输入行的回送。</li>
<li>事件驱动，将逻辑流模型转化位状态机。</li>
</ul>
<ol start="3">
<li>线程</li>
</ol>
<ul>
<li>每个进程有自己上下文，包括TID，栈，栈指针，程序计数器，通用寄存器和条件码。但是同一个进程里的线程共享整个进程的虚拟空间（包括只读文本，也就是代码，数据，读&#x2F;写数据，堆和所有共享代码库，也共享打开的文件集合）</li>
<li>与进程不同的是：它不遵循进程的父子层次关系来组织的，它们彼此是对等的关系。而所谓的主线程不过是第一个执行的而已。我们之前看到子进程是很难操纵父进程的，但是这里对等进程是可以彼此控制的。</li>
<li>Posix线程(Pthreads)是在C程序中处理线程的一个标准接口。可以看到线程的代码和数据都被封装在一个线程例程(thread routine)里</li>
<li>对于示例代码里的echoservert.c里存在的问题，由于创建了线程以后是并发执行的，所以我们并不知道它和主线程谁接着执行。那么由于创建的线程里有一个是指针赋值，而这个指针只有一个，很有可能这个指针已经指向了下一个连接了，创建的线程才完成赋值。那么有一个连接就丢失了。所以我们这里要把这个accept返回的指针要独立开来。</li>
</ul>
<ol start="4">
<li><p>变量,<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/ics3/code/conc/sharing.c">示例代码</a><br><img src="http://static.zybuluo.com/Husy/zoyj1tu2jopi91h4mjhookhp/Screenshot%20from%202018-07-13%2020-42-16.png" alt="变量"></p>
</li>
<li><p>并发错误</p>
</li>
</ol>
<ul>
<li>进度图<br><img src="http://static.zybuluo.com/Husy/qyw4lwnfa6ou5leftjga69mj/Screenshot%20from%202018-07-13%2020-49-21.png" alt="同步错误-进度图"></li>
</ul>
<ol start="6">
<li>信号量-&gt;互斥访问</li>
</ol>
<ul>
<li>P(s)检测s是非零的就减一，然后立即返回；如果s是0，就挂起当前的进程。这个检测和减一是院子的，不能被打断的。 V(s)将s加一，然后重启被P操作阻塞的进程。但是这个重启的顺序不确定。</li>
<li>基本思想就是把共享变量和这个s联系起来。一些名词是：<br><img src="http://static.zybuluo.com/Husy/f07kn5rl9q7yjp569aqbth6f/Screenshot%20from%202018-07-13%2021-22-20.png" alt="名词解释"></li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>多线程服务器里传递Accpet返回的描述符，然后再将这个描述符给线程创建的函数。这里是通过指针来传递的，但是描述符不过是一个int，为什么也要用指针呢？我想是因为它虽然类型是一个int，但是它的存储位置等还是很有关系的，不然为什么会是一个描述符而不是一个简单的数据呢？</p>
</li>
<li><p>c语言里的static，全局变量，extern这些关键字还是没有搞清楚。static的变量究竟是放在哪里的？栈里吗？</p>
</li>
</ol>
<h2 id="家庭作业"><a href="#家庭作业" class="headerlink" title="家庭作业"></a>家庭作业</h2><p>待补充</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/03/27/%E3%80%90CSAPP%E3%80%91Ch12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" data-id="cl0t1dcyk00148slf14ih1851" data-title="【CSAPP】Ch12-并发编程" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【APUE】Ch8-进程标识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/24/%E3%80%90APUE%E3%80%91Ch8-%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2018-03-24T03:38:58.000Z" itemprop="datePublished">2018-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/24/%E3%80%90APUE%E3%80%91Ch8-%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86/">【APUE】Ch8-进程标识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol>
<li><p>关于如何使用#include “apue.h”</p>
<ul>
<li>先下载apue.3e的<a target="_blank" rel="noopener" href="http://www.apuebook.com/code3e.html">源代码</a>,然后解压后进入根目录，make.</li>
<li>然后直接自己的代码直接#include “apue.h”，在编译的时候用命令行<code>gcc -o [你的目标可执行文件名] [需编译的文件] -I [apue.3e的目录]/include/ -L [apue.3e的目录]/lib/ -lapue</code></li>
<li>参考自<a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/105483/compiling-code-from-apue">Compiling code from apue</a></li>
</ul>
</li>
<li><p>关于fork</p>
<ul>
<li>图8-1有一个实例，讲的是fork。但是这里要注意的是关于父进程与子进程缓冲区的理解。<a target="_blank" rel="noopener" href="https://github.com/husy1994/apue-3e/tree/master/chap8">代码</a>见fork_ex.c。如果直接运行.&#x2F;fork_ex，输出为：<blockquote>
<p>a write to stdout<br>before fork<br>pid&#x3D;12322,glob&#x3D;7,var &#x3D; 89<br>pid&#x3D;12323,glob&#x3D;7,var &#x3D; 89</p>
</blockquote>
</li>
<li>但是如果讲输出重定向到一个文本文件的时候，比如.&#x2F;fork_ex &gt;fork_ex.txt，文本的内容变成了：<blockquote>
<p>a write to stdout<br>before fork<br>pid&#x3D;12764,glob&#x3D;7,var &#x3D; 89<br>before fork  &#x2F;&#x2F;多了一行输出<br>pid&#x3D;12765,glob&#x3D;7,var &#x3D; 89</p>
</blockquote>
</li>
<li>这是因为linux的设定是标准输出连接到终端设备是行缓冲，否则它是全缓冲。因此虽然“before fork”是在fork之前输出的，由于此时全缓冲并没有满，所以没有flush，在fork以后该行数据仍在缓存中，于是便跟随后面的输出一起输出来了。</li>
<li>这里的理论是通过fork创建的子进程会复制父进程所有的文件描述符，从而达到共享文件表表表项的结果。所以父子进程是共享每一个打开的文件的文件偏移量的。看到上面的标准输出的例子，如果不共享文件偏移量，那么很有可能父进程输出以后，对于控制台的文件偏移没有更新，子进程接着输出会覆盖掉父进程的输出。</li>
</ul>
</li>
<li><p>子进程和父进程的关系：</p>
<ul>
<li>如果父进程先于子进程结束，那么其子进程就会被init进程收养。具体的操作过程是：每当有进程A要终止时，内核就逐一检查一下当前的活动进程是不是这个终止进程A的子进程，是就把它的父进程ID改为0(init进程的ID)。</li>
<li>如果子进程先于父进程结束，内核会保存终止进程的一些信息，当父进程调用wait或者waitpid可以得到这些信息。如果父进程没有对终止的子进程做一些处理（比如用wait获取子进程的信息），这个子进程就会变成僵尸进程。当然我们的init进程会对其每一个子进程都调用wait来避免出现僵尸进程。</li>
</ul>
</li>
<li><p>wait和waitpid</p>
<ul>
<li>父进程调用时，子进程没有结束，父进程就阻塞；结束了，就返回子进程ID，并且子进程的终止状态返回给它们的参数；如果父进程没有子进程，那么就出错返回。</li>
<li>最好的做法是由于进程终止会产生一个SIGCHLD信号，我们可以在父进程里捕捉着个信号，然后再执行wait。这样父进程就不会阻塞。</li>
</ul>
</li>
</ol>
<h2 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h2><ul>
<li>P193 8.3我们声明了一个全局变量char buf[] &#x3D; “a write to stdout\n”,后面在使用sizeof(buf)的时候，文中有这样一句话，因为缓冲区已用已知字符进行的初始化其长度是固定的所以sizeof是编译时计算缓冲区的</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/03/24/%E3%80%90APUE%E3%80%91Ch8-%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86/" data-id="cl0t1dcy200018slff0pz8ib1" data-title="【APUE】Ch8-进程标识" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APUE/" rel="tag">APUE</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【ucore】lab1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/24/%E3%80%90ucore%E3%80%91lab1/" class="article-date">
  <time class="dt-published" datetime="2018-03-24T03:32:06.000Z" itemprop="datePublished">2018-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/24/%E3%80%90ucore%E3%80%91lab1/">【ucore】lab1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>这里主要是一些计算机系统的一些知识，大部分还和操作系统没什么关系。如果你有些艰难的话，还是先去看看前置课程，比如汇编语言（王爽），大名鼎鼎的CSAPP以及它的网课等等。但是话说回来，这一章有很多细节你如果搞不清楚也不太影响后面对操作系统的实验完成。</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="练习1：理解通过make生成执行文件的过程。"><a href="#练习1：理解通过make生成执行文件的过程。" class="headerlink" title="练习1：理解通过make生成执行文件的过程。"></a>练习1：理解通过make生成执行文件的过程。</h3><p>这个主要是要熟悉makefile的语法，其实质就是一种简单的文本替换。这里的只需要了解到ucore.img是由kernel和bootblock组成的就行。bootblock负责启动与加载kernel，kernel就是真正的操作系统内核</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UCOREIMG	:= $(call totarget,ucore.img)</span><br><span class="line">$(UCOREIMG): $(kernel) $(bootblock)</span><br><span class="line">	$(V)dd if=/dev/zero of=$@ count=10000</span><br><span class="line">	$(V)dd if=$(bootblock) of=$@ conv=notrun</span><br><span class="line">	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc</span><br><span class="line">$(call create_target,ucore.img)</span><br></pre></td></tr></table></figure>
<h3 id="练习2：使用qemu执行并调试lab1中的软件。"><a href="#练习2：使用qemu执行并调试lab1中的软件。" class="headerlink" title="练习2：使用qemu执行并调试lab1中的软件。"></a>练习2：使用qemu执行并调试lab1中的软件。</h3><p>这里是为了熟悉qemu与gdb的搭配使用。如果有认真看[ucore实验环境准备]就会知道，而gdb的操作语法可以<a target="_blank" rel="noopener" href="https://www.gnu.org/software/gdb/documentation/">参考</a></p>
<h3 id="练习3：分析bootloader进入保护模式的过程。"><a href="#练习3：分析bootloader进入保护模式的过程。" class="headerlink" title="练习3：分析bootloader进入保护模式的过程。"></a>练习3：分析bootloader进入保护模式的过程。</h3><p>为什么要进入保护模式的原因不多说，随意一本教程都有。主要的[知识点]就是保护模式下的CPU的编址与寻址。</p>
<ol>
<li>初始化GDT表无非是创建了一个的gdtdesc数据结构，然后用lgdt这个汇编命令将GDT的内存地址放入lgdt寄存器里。这里要注意GDT并没有直接放入寄存器，它和后面讲的TLB（Translation lookasid table）不一样，这个本质上就是一个RAM，因此它就是整个表都放在CPU里。</li>
<li>另一个任务是进入将实模式切换为保护模式，通过将cr0寄存器PE位置1便开启了保护模式。至于后面的跳转只是为了更新cs:ip里的值，因为毕竟此时我们打开了段页式的内存访问机制。因此cs:ip的值要更新一下。</li>
</ol>
<h3 id="练习4：分析bootloader加载ELF格式的OS的过程。"><a href="#练习4：分析bootloader加载ELF格式的OS的过程。" class="headerlink" title="练习4：分析bootloader加载ELF格式的OS的过程。"></a>练习4：分析bootloader加载ELF格式的OS的过程。</h3><ol>
<li><p>bootloader如何读取硬盘扇区的<br>我总觉得读一次磁盘只需要一次等待，实际上需要两次。一次等待它能够接收读取命令，发送了要读取的命令以后，再等待一次，开始读取数。</p>
</li>
<li><p>bootloader是如何加载ELF格式的OS？<br>这里涉及到了[链接]的一部分知识。我们至少要知道一个ELF是由一些段（section）组成的，而其ELF存放了很多如何读取这个文件的信息。比如每一个段的相对偏移啊，段的性质。<br>另一个要注意的kernel.ld文件里的这个，0x100000是作为kernel的绝对加载起始地址，因此ELF加载时重定位都是在这个基础上做偏移。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	<span class="comment">/* Load the kernel at this address: &quot;.&quot; means the current address */</span></span><br><span class="line">	. = <span class="number">0x100000</span>;</span><br></pre></td></tr></table></figure>
<h3 id="练习5：实现函数调用堆栈跟踪函数-（需要编程）"><a href="#练习5：实现函数调用堆栈跟踪函数-（需要编程）" class="headerlink" title="练习5：实现函数调用堆栈跟踪函数 （需要编程）"></a>练习5：实现函数调用堆栈跟踪函数 （需要编程）</h3></li>
<li><p>这里的知识点就是考察函数调用栈[^footnote]：</p>
</li>
</ol>
<ul>
<li><p>ESP：栈指针寄存器(extended stack pointer)，永远指向系统栈最上面一个栈帧的栈顶。<strong>注意如果用push操作，esp指向的是栈里有值的第一个，而不是指向下一个存放点。</strong></p>
</li>
<li><p>EBP：永远指向系统栈最上面一个栈帧的底部。</p>
</li>
<li><p>函数栈帧：ESP和EBP之间的内存空间为当前栈帧，EBP标识了当前栈帧的底部，ESP标识了当前栈帧的顶部。</p>
</li>
<li><p>EIP：指向下一条待执行的指令地址。</p>
</li>
<li><p>函数调用大致包括以下几个步骤：</p>
</li>
</ul>
<ol>
<li>参数入栈：将参数从右向左依次压入系统栈中。</li>
<li>返回地址入栈：也就是call指令执行的，将当前代码区调用指令的下一条指令地址(返回地址)压入栈中，然后把eip指向调用函数的第一条指令。</li>
<li>栈帧调整：包括保存当前栈帧状态值，已备后面恢复本栈帧时使用（EBP入栈）；将当前栈帧切换到新栈帧（将ESP值装入EBP，更新栈帧底部）；给新栈帧分配空间。（把ESP减去所需空间的大小，抬高栈顶）<br>![函数调用栈][1]<br>  [1]: <a target="_blank" rel="noopener" href="http://static.zybuluo.com/Husy/xz35inr8bylhthl5mbofadow/1314ce0c49d0a1e2800e23ca3d5cdd75_r.jpg">http://static.zybuluo.com/Husy/xz35inr8bylhthl5mbofadow/1314ce0c49d0a1e2800e23ca3d5cdd75_r.jpg</a></li>
</ol>
<p>这里有几个地方是我之前有误解的：</p>
<ol>
<li><p>调用函数参数不是一个个push进去的，而是直接让esp-参数大小，使其指向栈的最顶端，然后用movl 参数把栈填满。而使用函数参数也不是我想的那样一个个按顺序pop出来，而是通过ebp寄存器再加上偏移去找，比如ebp+8就是第一个参数（从左往右数，因为入栈的时候是从右往左）。反过来想pop出来只能是放在寄存器，万一参数数量太多，寄存器不够呢？这个限制太致命了，所以不能这么做。</p>
</li>
<li><p>另外说到保存当前函数的栈第一直觉是保存esp，但其实我们保存的是ebp。并没有保存esp。因为我们每次都让esp赋值给ebp，实际上也是保存的esp了。</p>
</li>
<li><p>而着一个地方最最关键的思路就是ebp是循环指向的。如果ebp代表当前寄存器ebp的值，那么*ebp指向的是前一个帧的ebp，于是**ebp指向的就是前前个帧的ebp……这就是一种调用顺序了。</p>
</li>
</ol>
<h3 id="练习6：完善中断初始化和处理-（需要编程）"><a href="#练习6：完善中断初始化和处理-（需要编程）" class="headerlink" title="练习6：完善中断初始化和处理 （需要编程）"></a>练习6：完善中断初始化和处理 （需要编程）</h3><p>我不太理解ucore为什么要在lab1里就把中断这些细节都过一遍。这样对自学非常不友好。如果你也是自学，我觉得在现阶段你只需要知道整个中断机制的处理逻辑就好，代码细节后面讲了内存管理与进程以后再慢慢来：</p>
<ol>
<li>中断发生时，硬件和软件互相配合。</li>
<li>获取一个中断码在中断向量表里去找中断服务例程的入口地址。</li>
<li>处理完以后，结果是要么结束当前进程，要么处理好了中断，接着回来执行。<br>但是，看起来好像这就是一个函数调用，其实其底层并不是。因为这两个处理程序并不是一个进程内的，不像函数调用一样有共享的堆栈。甚至可能是用户态，处理中断时需要进入内核态。因此这里更细节的东西涉及到了进程切换，系统调用等等细节。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[^footnote]: 更详细的讲解请参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22444939">https://www.zhihu.com/question/22444939</a>  和 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/594357dff57e">https://www.jianshu.com/p/594357dff57e</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/03/24/%E3%80%90ucore%E3%80%91lab1/" data-id="cl0t1dcyq001l8slf076uggv9" data-title="【ucore】lab1" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ucore/" rel="tag">ucore</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【ucore】序" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/24/%E3%80%90ucore%E3%80%91%E5%BA%8F/" class="article-date">
  <time class="dt-published" datetime="2018-03-24T03:31:06.000Z" itemprop="datePublished">2018-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/24/%E3%80%90ucore%E3%80%91%E5%BA%8F/">【ucore】序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>这是一个关于清华大学ucore的实验博客。鉴于ucore提供了完整的答案，因此这里并不会提供具体的答案。更多的是理论与逻辑上的讨论思考，以及做实验时的一些感悟。</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>第一次自学ucore这个课程，陷入了太多的细节，导致花了很多不必要的时间。事实上，这些细节相对于真正的操作系统来讲是很粗陋的，我们的目的是通过实验获取对理论的更深认识，而不是真的实现一个OS。因此，我希望能借这一系列的博客，第二次再来上这个课，有一些提纲挈领的感悟。</p>
<h2 id="实验环境准备"><a href="#实验环境准备" class="headerlink" title="实验环境准备"></a>实验环境准备</h2><ol>
<li>OS： ubuntu18.04 LST</li>
<li><a target="_blank" rel="noopener" href="https://www.qemu.org/download/">qemu安装</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/chyyuu/ucore_os_lab">实验代码</a></li>
</ol>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ol>
<li>qemu</li>
</ol>
<ul>
<li>首先是进入代码目录，make生成.&#x2F;bin&#x2F;ucore.img</li>
<li>这里makefile里提供了一个命令make qemu等。但下面这种更灵活。</li>
<li>然后打开qemu-system-i386 ucore.img就能打开模拟控制台界面。</li>
<li>这个里有很多参数可以调整，具体参考<a target="_blank" rel="noopener" href="https://qemu.weilnetz.de/doc/qemu-doc.html">qemu documents</a></li>
</ul>
<ol start="2">
<li>gdb的远程调试。</li>
</ol>
<ul>
<li>首先<code>qemu-system-i386 -S -s -hda &lt;ucore.img的路经&gt; -monitor stdio</code>主要是参数-S -s要加上。</li>
<li>然后打开一个新的终端，打开gdb，开始监听target remote 127.0.0.1:1234</li>
<li>在gdb命令行下输入file &lt;kernel的路径&gt;，这样就能获取符号表，从而达到源码级别的调试。</li>
<li>接下来设置断点，运行输出这些就是正常操作了。</li>
<li>更为方便的方法是创建一个gdbinit文件，输入<blockquote>
<p>  target remote 127.0.0.1:1234<br>  file .bin&#x2F;kernel<br>然后就可以直接输入命令 <code>gdb -x &lt;gdbinit的路径&gt;</code>了。这里源代码在tools里已经帮我们创好了。</p>
</blockquote>
</li>
</ul>
<ol start="3">
<li>说了这么多只是为了说明下面几个源代码的makefile里已经给我们写好的命令。</li>
</ol>
<ul>
<li>直接编译加执行qemu  <code>$make qemu</code></li>
<li>检查实验得分 <code>$make grade</code></li>
<li>调试（使用gdb) <code>$make debug</code></li>
<li>提交代码 <code>$make handin</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2018/03/24/%E3%80%90ucore%E3%80%91%E5%BA%8F/" data-id="cl0t1dcyn001f8slfhgllejlu" data-title="【ucore】序" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ucore/" rel="tag">ucore</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mit6-824/">mit6.824</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/quant%E9%9D%A2%E8%AF%95%E7%BA%A2%E5%AE%9D%E4%B9%A6/">quant面试红宝书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">数据结构笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E5%AE%9D%E5%85%B8/">面试算法宝典</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APUE/" rel="tag">APUE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algroithm/" rel="tag">Algroithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/I-O/" rel="tag">I&#x2F;O</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pprof/" rel="tag">Pprof</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test/" rel="tag">Test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/" rel="tag">code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/distributed/" rel="tag">distributed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gc/" rel="tag">gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lock-free/" rel="tag">lock-free</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quant-interview/" rel="tag">quant interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raft/" rel="tag">raft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ucore/" rel="tag">ucore</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/APUE/" style="font-size: 10px;">APUE</a> <a href="/tags/Algroithm/" style="font-size: 18.57px;">Algroithm</a> <a href="/tags/CSAPP/" style="font-size: 20px;">CSAPP</a> <a href="/tags/Golang/" style="font-size: 17.14px;">Golang</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/I-O/" style="font-size: 10px;">I/O</a> <a href="/tags/Leetcode/" style="font-size: 18.57px;">Leetcode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a> <a href="/tags/OS/" style="font-size: 15.71px;">OS</a> <a href="/tags/Pprof/" style="font-size: 10px;">Pprof</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/code/" style="font-size: 10px;">code</a> <a href="/tags/distributed/" style="font-size: 11.43px;">distributed</a> <a href="/tags/gc/" style="font-size: 10px;">gc</a> <a href="/tags/golang/" style="font-size: 12.86px;">golang</a> <a href="/tags/k8s/" style="font-size: 10px;">k8s</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/lock-free/" style="font-size: 10px;">lock-free</a> <a href="/tags/quant-interview/" style="font-size: 14.29px;">quant interview</a> <a href="/tags/raft/" style="font-size: 12.86px;">raft</a> <a href="/tags/ucore/" style="font-size: 17.14px;">ucore</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 12.86px;">双指针</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18.57px;">算法</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 11.43px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/26/Prometheus-Histograms-Observation%E7%9A%84%E6%97%A0%E9%94%81%E5%AE%9E%E7%8E%B0/">Prometheus笔记</a>
          </li>
        
          <li>
            <a href="/2021/08/09/k8s%E5%AE%9E%E6%93%8D%E7%AC%94%E8%AE%B0/">k8s实操笔记</a>
          </li>
        
          <li>
            <a href="/2021/07/16/golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">golang垃圾回收</a>
          </li>
        
          <li>
            <a href="/2021/06/03/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%A4%87%E5%BF%98%E5%BD%95/">golang测试备忘录</a>
          </li>
        
          <li>
            <a href="/2021/05/02/defer%E8%AF%A6%E8%A7%A3/">defer详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Husy<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>