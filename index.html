<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://husy-dev.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Husy">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://husy-dev.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Prometheus-Histograms-Observation的无锁实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/26/Prometheus-Histograms-Observation%E7%9A%84%E6%97%A0%E9%94%81%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2021-08-26T01:48:56.000Z" itemprop="datePublished">2021-08-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/26/Prometheus-Histograms-Observation%E7%9A%84%E6%97%A0%E9%94%81%E5%AE%9E%E7%8E%B0/">Prometheus笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="无锁实现"><a href="#无锁实现" class="headerlink" title="无锁实现"></a>无锁实现</h2><p>本文参考自<a target="_blank" rel="noopener" href="https://grafana.com/blog/2020/01/08/lock-free-observations-for-prometheus-histograms/">Lock-free Observations for Prometheus Histograms</a>，一般来讲多线程共同修改共享变量是需要锁的，但是prometheus的逻辑里数据的写非常频繁，而写的逻辑很简单，因此这里用到了乐观锁的思想，通过原子操作以及一个很tricky的状态值维护，去掉了锁。</p>
<h2 id="Counter-Vs-CounterVec"><a href="#Counter-Vs-CounterVec" class="headerlink" title="Counter Vs CounterVec"></a>Counter Vs CounterVec</h2><p>前者是没有label的，后者有label。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2021/08/26/Prometheus-Histograms-Observation%E7%9A%84%E6%97%A0%E9%94%81%E5%AE%9E%E7%8E%B0/" data-id="cl0t1ddcb005i8slfe0fvcd1y" data-title="Prometheus笔记" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lock-free/" rel="tag">lock-free</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-k8s实操笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/09/k8s%E5%AE%9E%E6%93%8D%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-08-09T02:23:32.000Z" itemprop="datePublished">2021-08-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/k8s/">k8s</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/09/k8s%E5%AE%9E%E6%93%8D%E7%AC%94%E8%AE%B0/">k8s实操笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="k8s-yaml文件的规则"><a href="#k8s-yaml文件的规则" class="headerlink" title="k8s yaml文件的规则"></a>k8s yaml文件的规则</h2><ol>
<li><p>如果是简单的tab锁进，则是map类型，如果是 - key，则是list类型，说明同样的key可能有多个。</p>
</li>
<li><p>dockerfile里的cmd和entrypoint的区别其实就是entrypoint可以接受docker run时后面添加自己要传入的参数，cmd不行，必须dockerfile里写好。因此一般用entrypoint，执行一个脚本，然后这个脚本接收一些参数。这个参数可以写在k8s的yaml文件里。</p>
</li>
<li><p>所有对资源的描述yaml文件都有下面的属性。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment">#这个api资源的版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment">#资源类型（由k8s预先定义的类型）</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 资源的属性</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span>  <span class="comment"># 资源的限制条件</span></span><br><span class="line">  <span class="string">......</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="deployment"><a href="#deployment" class="headerlink" title="deployment"></a>deployment</h3><p>deployment的yaml文件可以参考<a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/">Deployments官网说明</a>，有几个点记录一下。</p>
<ol>
<li><p>k8s的deployment.yaml文件有好几处name，label等。主要是要分清一份deployment.yaml文件既要metadata描述deployment资源对象（供管理deployment的对象筛选），又要描述其管理的pod资源对象（定义在template下面）。因此</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">	<span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<p>这里的selector也很好理解，就是为了匹配管理的pod的label。</p>
</li>
</ol>
<h2 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h2><p><a target="_blank" rel="noopener" href="https://blog.haohtml.com/archives/19945">https://blog.haohtml.com/archives/19945</a><br>主要就是介绍了service和ingress在k8s集群里的作用。首先你要知道从k8s集群外部访问集群的方式有四种：</p>
<ol>
<li>ClusterIP </li>
<li>NodePort</li>
<li>LoadBalance</li>
<li>ExternalName<br>实际上这个是一层层依赖和放开的。k8s集群会将各种业务抽象成一个个的service，那么每一个service都会分配一个VIP去访问，这个访问方式就是ClusterIP的方式。NodePort是第一层可以外部访问的方式，只要将Node的IP和端口暴露出去就可以通过这个NodeIP：NodePort将请求打到同步创建的ClusterIP去。然后LoadBalance由云服务商来提供一种负载均衡的模式，然后将请求打到service的NodePort或者ClusterIP上去。</li>
</ol>
<p>最后ExternalName的话就更上一层楼，前面都是默认一个IP一个service，ExternalName 类型的 Service，其实是在 kube-dns 里为你添加了一条 CNAME 记录。这里是通过将多个service合成一个服务名称去访问。</p>
<p>Ingress则是在service上面又包了一层，通过URL做一个service的映射，客户端可以通过访问一个反向代理来请求到不同的service。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2021/08/09/k8s%E5%AE%9E%E6%93%8D%E7%AC%94%E8%AE%B0/" data-id="cl0t1ddc9005c8slf86470k8c" data-title="k8s实操笔记" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-golang垃圾回收" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/16/golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="article-date">
  <time class="dt-published" datetime="2021-07-16T09:34:50.000Z" itemprop="datePublished">2021-07-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/16/golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">golang垃圾回收</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>为什么计算机程序需要垃圾回收这里不再赘述了，但是作为一个开发为什么需要了解垃圾回收算法呢？要知道垃圾回收机制再设计之初就是为了让程序员可以专心写业务，不用关心太多内存的问题。所以答案显然易见，如果你不满足于调用api写业务接口，想要做一些性能优化，甚至只是想写一份优雅的业务代码，你就需要关心垃圾回收机制。当然，最重要的，面试的时候可以用来装逼。</p>
<p>那么，关于Golang垃圾回收程序员应该知道些什么？你要深入每一行代码去了解每一个细节，我当然佩服你的勇气。但我认为，主要是知道下面几点：</p>
<ol>
<li>垃圾回收几种思路其各自的优缺点；</li>
<li>Golang语言的垃圾回收有什么特点，是如何做到的；</li>
<li>我们可以从Golang的垃圾回收的设计里学习到什么？</li>
</ol>
<h2 id="垃圾回收的几种思路"><a href="#垃圾回收的几种思路" class="headerlink" title="垃圾回收的几种思路"></a>垃圾回收的几种思路</h2><p>主流上一种是引用计数算法，一种是标记清除算法。但是前者会有循环引用的问题，并且对每一个对象进行引用计数也是一笔不小的开支。本文主要是讲标记清除算法。</p>
<h3 id="1-跟踪收集法"><a href="#1-跟踪收集法" class="headerlink" title="1. 跟踪收集法"></a>1. 跟踪收集法</h3><p>垃圾回收要解决的问题无非是，把不再要用的对象占用的内存销毁掉，让别的对象可以继续使用。跟踪收集法的原理就是不断地去扫描所有对象，然后进行标记（是否需要清除），然后去回收需要清除的。而我们判断是否需要清除的标准是，该对象是否有合理的路径去访问，比如被一个全局变量引用，或者被函数栈里使用。如果可达，则不能被清除。不可达了则可以被清除。具体精确的定义可以参考</p>
<blockquote>
<ol>
<li>A distinguished set of roots: objects that are assumed to be reachable. Typically, these include all the objects referenced from anywhere in the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Call_stack">call stack</a> (that is, all <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Local_variable">local variables</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Parameter_(computer_science)">parameters</a> in the functions currently being invoked), and any <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Global_variable">global variables</a>.</li>
<li>Anything referenced from a reachable object is itself reachable; more formally, reachability is a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transitive_closure">transitive closure</a>.</li>
</ol>
<p><em>摘自<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">Tracing garbage collection</a></em></p>
</blockquote>
<h3 id="2-三色标记法"><a href="#2-三色标记法" class="headerlink" title="2. 三色标记法"></a>2. 三色标记法</h3><p>那么具体是如何实现跟踪收集的呢？其中一种比较主流的算法就是三色标记法，黑白灰实际上对应着内存对象的三种状态，白色集合里放待回收的对象和其候选人（最开始GC会把所有的内存对象都置为白色），灰色表示该对象是可达的，但是还需要扫描其各个引用。而黑色则表示该对象没有任何引用了，并且可达不能被清除。</p>
<blockquote>
<p>Three sets are created – <em>white</em>, <em>black</em> and <em>gray</em>:</p>
<ul>
<li>The white set, or <em>condemned set</em>, is the set of objects that are candidates for having their memory recycled.</li>
<li>The black set is the set of objects that can be shown to have no outgoing references to objects in the white set, and to be reachable from the roots. Objects in the black set are not candidates for collection.</li>
<li>The gray set contains all objects reachable from the roots but yet to be scanned for references to “white” objects. Since they are known to be reachable from the roots, they cannot be garbage-collected and will end up in the black set after being scanned.</li>
</ul>
<p><em>摘自<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">Tracing garbage collection</a></em></p>
</blockquote>
<p>大概步骤就是：</p>
<ol>
<li>首先将所有对象都置为白色；</li>
<li>然后将所有全局变量和main函数栈和堆里的对象都放入灰色集合；</li>
<li>开始扫描灰色集合里的对象是否有引用，有的话将其引用放入灰色集合，扫描完后的对象都放入黑色集合。</li>
<li>清除掉白色集合里的对象。</li>
</ol>
<p>上述是一个很简单的标记清除逻辑，看起来一切都很简单。标记，然后清除。但是Golang的垃圾回收器和业务程序是并发执行的，也就是说，在GC标记和清除的过程中，程序是一直是动态地在创建对象的，对象的引用也可能在变化。那么新创建的对象应该放入什么颜色的集合呢？或者说对象的引用变化了怎么办呢？不难知道会出现多写和漏写的问题（可参考<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/777750">底层原理：垃圾回收算法是如何设计的?</a>读写屏障部分）。</p>
<p>多写的现象是本该删除的白色对象在这一轮没有删除，但是如果下一轮该白色对象依旧保持原有的引用关系的话，下一轮的GC会将其删除，所以这个问题不伤害准确性。但是漏写问题则是将本不该删除的对象删除了，因此一定要避免。漏写情况的出现需要满足一个条件：灰色对象（在扫描前）删除了对白色对象的引用，但是黑色对象又对其进行了引用。</p>
<p>那么只需要破坏这个条件，就可以避免这个问题。</p>
<h3 id="3-STW与读-x2F-写屏障"><a href="#3-STW与读-x2F-写屏障" class="headerlink" title="3. STW与读&#x2F;写屏障"></a>3. STW与读&#x2F;写屏障</h3><p>解决方法有很多种。最简单的做法就是，把程序停止，让其不要继续创建新对象和修改引用了。也就是早期的串形GC，很明显，这样会影响业务程序的运行，而且因为GC的执行导致整个程序宕机的时机不可控。</p>
<p>另一种做法就是读&#x2F;写屏障。对某对象的引用改变或者创建新的对象都会涉及左值对象的写和右值对象的读，因此，只需要对读或者对写作一层封装处理，去破坏掉上述条件，这个概念叫做读&#x2F;写屏障，它不是一种特定的算法，而是一种触发机制。垃圾回收算法可以选择对被读对象进行操作，或者是对被写对象进行操作。</p>
<p>一种思路叫做增量更新，就是将在GC标记过程中变化的对象，无论之前是在什么集合，都立即放回灰色集合，等待下一轮GC的扫描。</p>
<p>另一种思路叫SATB（Snapshot At The Begining），当灰色对象删除对白色对象的引用时，它将白色对象置为灰色；当黑色对象新引用一个白色对象时，将白色对象置为黑色。这样会造成浮动垃圾，也就是本该在这轮回收的对象没有回收，但是again，这不影响其正确性，只是影响效率，所以也是可以接受的。</p>
<h3 id="4-Golang-GC"><a href="#4-Golang-GC" class="headerlink" title="4. Golang GC"></a>4. Golang GC</h3><p>终于说到本文的主角了。Golang里采用的GC是并发增量GC，其中并发和增量的目的都是为了减少STW的时间。抽象的逻辑上面已经说完了，谈到具体的实现，有几个点可以说一下。</p>
<ol>
<li>首先是内存分配会分有指针和无指针的对象分配，这就是为GC扫描做的优化。分配在无指针内存上的对象在扫描时可以直接变成黑色而不是灰色。</li>
<li>GC的标记完成后，并不是立马就把不在需要的内存释放掉而是等待下次分配的时候才释放。因此GC完毕后也不是立马就可以看到程序占用的内存变小。</li>
<li>其次是GC具体的触发时机，默认是堆内存达到原来的两倍或者每隔2分钟开始一次GC。分配的资源限制是启用CPU的1&#x2F;4来做GC。这里有一个问题就是一般业务都是用的k8s的pod部署业务，pod request里的分配的内核数一般都很小，而golang创建的process数和物理内核数是一致的。</li>
<li>如果扫描的速度小于业务请求内存分配的速度，需要分配多的goroutine执行Mark Assist逻辑，来减缓分配速度。</li>
<li>然后就是要清除虽然GC做了很多优化减少STW的时间，但并不是没有STW，在并发标记和清除时不需要STW，但是在GC开始时需要STW打开写屏障，结束时需要STW关闭写屏障，GC结束的STW需要计算下一次GC的时间和一些临时变量的清理。</li>
<li>最后就是要学会查看GC的一些调试数据，以及可以解释出该现象的原因。可以看一下参考1和参考2两篇博文。</li>
</ol>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>GC对应用程序的影响在两个时段：1. marking的时候，会占用一个物理线程，从而导致Go业务代码无法跑慢CPU；2. STW的时候会暂停所有的业务goroutine。</p>
<p>GC调优的宗旨在于在有限的堆内存上获得最大的吞吐量，也就是在两次GC之间尽可能地做多一些业务操作，老生常谈的思路就是：</p>
<ol>
<li>减少堆的内存申请，尽量复用代码，或者尽量分配在栈中。</li>
<li>找到一个合适的GC执行节奏，也就是决定下一次GC什么时候开始的算法，比如调整GC percentage option。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="golang内存模型与内存屏障"><a href="#golang内存模型与内存屏障" class="headerlink" title="golang内存模型与内存屏障"></a>golang内存模型与内存屏障</h3><p><a target="_blank" rel="noopener" href="https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/">https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/</a><br>这篇文章介绍了内存模型是什么。由于CPU的优化，会导致指令重排。那么程序语言就需要约定一个内存模型，去告诉编译器和cpu怎么在优化性能的同时，保证指令的正确执行。不同的语言的处理方式不一样，比较主流的方法是内存屏障。在内存屏障指令中间的指令是不允许cpu优化的。C++里有很多关键字和处理方法，Golang的话大部分都被封装了没有暴露给上层业务代码。<br><a target="_blank" rel="noopener" href="https://go101.org/article/memory-model.html">https://go101.org/article/memory-model.html</a> </p>
<ol>
<li><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976">Go: How Does the Garbage Collector Mark the Memory?</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-watch-your-application-dbef99be2c35">Go: How Does the Garbage Collector Watch Your Application?</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html">Garbage Collection In Go : Part I - Semantics</a></li>
<li><a target="_blank" rel="noopener" href="https://making.pusher.com/go-tool-trace/">https://making.pusher.com/go-tool-trace/</a></li>
<li><a target="_blank" rel="noopener" href="https://rakyll.medium.com/debugging-latency-in-go-1-11-9f97a7910d68">https://rakyll.medium.com/debugging-latency-in-go-1-11-9f97a7910d68</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2021/07/16/golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" data-id="cl0t1dd0z004h8slf5y9xelbb" data-title="golang垃圾回收" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gc/" rel="tag">gc</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-golang单元测试备忘录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/03/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%A4%87%E5%BF%98%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2021-06-03T08:16:08.000Z" itemprop="datePublished">2021-06-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/03/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%A4%87%E5%BF%98%E5%BD%95/">golang测试备忘录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://zhounanjun.gitbook.io/nanjun/ji-shu-tiao-yan/gomonkey">gomonkey调研文档和学习</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/343300926">如何高效编写Go单元测试（二）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/catch/p/10973611.html">gohook 一个支持运行时替换 golang 函数的库实现</a></li>
<li><a target="_blank" rel="noopener" href="https://elliotchance.medium.com/mocking-redis-in-unit-tests-in-go-28aff285b98">https://elliotchance.medium.com/mocking-redis-in-unit-tests-in-go-28aff285b98</a></li>
<li><a target="_blank" rel="noopener" href="https://codertang.com/2020/10/21/postman/">postman功能详解</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2021/06/03/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%A4%87%E5%BF%98%E5%BD%95/" data-id="cl0t1dd0v00498slfde271wr9" data-title="golang测试备忘录" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Test/" rel="tag">Test</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-defer详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/02/defer%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2021-05-02T09:01:39.000Z" itemprop="datePublished">2021-05-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/02/defer%E8%AF%A6%E8%A7%A3/">defer详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>defer关键字的作用是预先准备，延迟执行。主要是要注意三个关键问题：</p>
<ol>
<li>defer是栈式存储，先声明的后执行。</li>
<li>defer会预先准备好参数和执行上下文。<code>defer foo(a,b)</code>和<code>defer func()&#123;foo(a,b)&#125;</code>是不一样的。</li>
<li>defer和return的执行顺序是，在return的ret汇编执行之前执行defer声明的函数。要注意return的底层操作包含三步，如果是匿名返回，就先声明和初始化一个匿名变量，然后将要返回出去的数据赋值给该变量，最后执行RET，才算是解释函数，将返回值又赋值给外部的接收者。可以参考[<a target="_blank" rel="noopener" href="https://my.oschina.net/henrylee2cn/blog/505535">Golang中defer、return、返回值之间执行顺序的坑</a>]，匿名返回值的那个匿名变量，我们是拿不到的，因此也就不存在会在return的过程中修改该匿名变量的可能。而有名返回值在函数调用时就已经被初始化了返回值，这个值defer是可以拿到的，也就可能在defer中改变了返回值（还要注意defer的取值是否是指针取值）。</li>
</ol>
<h2 id="2-例子"><a href="#2-例子" class="headerlink" title="2. 例子"></a>2. 例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintTimeCost</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  now:=time.Now()</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    duration:=time.Since(now)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;func costs:%v&quot;</span>,duration)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在想要记录耗时的函数里可以这么使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">defer</span> PrintTimeCost()()</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就涉及到函数的闭包以及defer的准备工作。</p>
<h2 id="3-defer原理剖析"><a href="#3-defer原理剖析" class="headerlink" title="3. defer原理剖析"></a>3. defer原理剖析</h2><p>首先写一个简单的测试用例来看一下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">recover</span>()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照golang语言深度解析里的方法，我们可以找到其汇编里的实现是先调用<code>runtime.deferprocStack</code>做一些数据准备，然后调用<code>runtime.deferreturn</code>调用执行。</p>
<p>先看一下_defer的结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A _defer holds an entry on the list of deferred calls.</span></span><br><span class="line"><span class="comment">// If you add a field here, add code to clear it in freedefer and deferProcStack</span></span><br><span class="line"><span class="comment">// This struct must match the code in cmd/compile/internal/gc/reflect.go:deferstruct</span></span><br><span class="line"><span class="comment">// and cmd/compile/internal/gc/ssa.go:(*state).call.</span></span><br><span class="line"><span class="comment">// Some defers will be allocated on the stack and some on the heap.</span></span><br><span class="line"><span class="comment">// All defers are logically part of the stack, so write barriers to</span></span><br><span class="line"><span class="comment">// initialize them are not required. All defers must be manually scanned,</span></span><br><span class="line"><span class="comment">// and for heap defers, marked.</span></span><br><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">	siz     <span class="type">int32</span> <span class="comment">// includes both arguments and results</span></span><br><span class="line">	started <span class="type">bool</span></span><br><span class="line">	heap    <span class="type">bool</span></span><br><span class="line">	<span class="comment">// openDefer indicates that this _defer is for a frame with open-coded</span></span><br><span class="line">	<span class="comment">// defers. We have only one defer record for the entire frame (which may</span></span><br><span class="line">	<span class="comment">// currently have 0, 1, or more defers active).</span></span><br><span class="line">	openDefer <span class="type">bool</span></span><br><span class="line">	sp        <span class="type">uintptr</span>  <span class="comment">// sp at time of defer</span></span><br><span class="line">	pc        <span class="type">uintptr</span>  <span class="comment">// pc at time of defer</span></span><br><span class="line">	fn        *funcval <span class="comment">// can be nil for open-coded defers</span></span><br><span class="line">	_panic    *_panic  <span class="comment">// panic that is running defer</span></span><br><span class="line">	link      *_defer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If openDefer is true, the fields below record values about the stack</span></span><br><span class="line">	<span class="comment">// frame and associated function that has the open-coded defer(s). sp</span></span><br><span class="line">	<span class="comment">// above will be the sp for the frame, and pc will be address of the</span></span><br><span class="line">	<span class="comment">// deferreturn call in the function.</span></span><br><span class="line">	fd   unsafe.Pointer <span class="comment">// funcdata for the function associated with the frame</span></span><br><span class="line">	varp <span class="type">uintptr</span>        <span class="comment">// value of varp for the stack frame</span></span><br><span class="line">	<span class="comment">// framepc is the current pc associated with the stack frame. Together,</span></span><br><span class="line">	<span class="comment">// with sp above (which is the sp associated with the stack frame),</span></span><br><span class="line">	<span class="comment">// framepc/sp can be used as pc/sp pair to continue a stack trace via</span></span><br><span class="line">	<span class="comment">// gentraceback().</span></span><br><span class="line">	framepc <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以deferprocStack实际上就是在当前运行的goroutine的_defer链表增加了一个_defer对象，因为是从链表头插入，因此可以解释为什么defer是先声明的后执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferprocStack</span><span class="params">(d *_defer)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	<span class="keyword">if</span> gp.m.curg != gp &#123;</span><br><span class="line">		<span class="comment">// go code on the system stack can&#x27;t defer</span></span><br><span class="line">		throw(<span class="string">&quot;defer on system stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	d.started = <span class="literal">false</span></span><br><span class="line">	d.heap = <span class="literal">false</span></span><br><span class="line">	d.openDefer = <span class="literal">false</span></span><br><span class="line">	d.sp = getcallersp()</span><br><span class="line">	d.pc = getcallerpc()</span><br><span class="line">	d.framepc = <span class="number">0</span></span><br><span class="line">	d.varp = <span class="number">0</span></span><br><span class="line">	<span class="comment">// The lines below implement:</span></span><br><span class="line">	<span class="comment">//   d.panic = nil</span></span><br><span class="line">	<span class="comment">//   d.fd = nil</span></span><br><span class="line">	<span class="comment">//   d.link = gp._defer</span></span><br><span class="line">	<span class="comment">//   gp._defer = d</span></span><br><span class="line">	<span class="comment">// But without write barriers. The first three are writes to</span></span><br><span class="line">	<span class="comment">// the stack so they don&#x27;t need a write barrier, and furthermore</span></span><br><span class="line">	<span class="comment">// are to uninitialized memory, so they must not use a write barrier.</span></span><br><span class="line">	<span class="comment">// The fourth write does not require a write barrier because we</span></span><br><span class="line">	<span class="comment">// explicitly mark all the defer structures, so we don&#x27;t need to</span></span><br><span class="line">	<span class="comment">// keep track of pointers to them with a write barrier.</span></span><br><span class="line">	*(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;d._panic)) = <span class="number">0</span></span><br><span class="line">	*(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;d.fd)) = <span class="number">0</span></span><br><span class="line">	*(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;d.link)) = <span class="type">uintptr</span>(unsafe.Pointer(gp._defer))</span><br><span class="line">	*(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;gp._defer)) = <span class="type">uintptr</span>(unsafe.Pointer(d))</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run a deferred function if there is one.</span></span><br><span class="line"><span class="comment">// The compiler inserts a call to this at the end of any</span></span><br><span class="line"><span class="comment">// function which calls defer.</span></span><br><span class="line"><span class="comment">// If there is a deferred function, this will call runtime·jmpdefer,</span></span><br><span class="line"><span class="comment">// which will jump to the deferred function such that it appears</span></span><br><span class="line"><span class="comment">// to have been called by the caller of deferreturn at the point</span></span><br><span class="line"><span class="comment">// just before deferreturn was called. The effect is that deferreturn</span></span><br><span class="line"><span class="comment">// is called again and again until there are no more deferred functions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Declared as nosplit, because the function should not be preempted once we start</span></span><br><span class="line"><span class="comment">// modifying the caller&#x27;s frame in order to reuse the frame to call the deferred</span></span><br><span class="line"><span class="comment">// function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The single argument isn&#x27;t actually used - it just has its address</span></span><br><span class="line"><span class="comment">// taken so it can be matched against pending defers.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferreturn</span><span class="params">(arg0 <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	d := gp._defer</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	sp := getcallersp()</span><br><span class="line">	<span class="keyword">if</span> d.sp != sp &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> d.openDefer &#123;</span><br><span class="line">		done := runOpenDeferFrame(gp, d)</span><br><span class="line">		<span class="keyword">if</span> !done &#123;</span><br><span class="line">			throw(<span class="string">&quot;unfinished open-coded defers in deferreturn&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		gp._defer = d.link</span><br><span class="line">		freedefer(d)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Moving arguments around.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Everything called after this point must be recursively</span></span><br><span class="line">	<span class="comment">// nosplit because the garbage collector won&#x27;t know the form</span></span><br><span class="line">	<span class="comment">// of the arguments until the jmpdefer can flip the PC over to</span></span><br><span class="line">	<span class="comment">// fn.</span></span><br><span class="line">	<span class="keyword">switch</span> d.siz &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// Do nothing.</span></span><br><span class="line">	<span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">		*(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;arg0)) = *(*<span class="type">uintptr</span>)(deferArgs(d))</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		memmove(unsafe.Pointer(&amp;arg0), deferArgs(d), <span class="type">uintptr</span>(d.siz))</span><br><span class="line">	&#125;</span><br><span class="line">	fn := d.fn</span><br><span class="line">	d.fn = <span class="literal">nil</span></span><br><span class="line">	gp._defer = d.link</span><br><span class="line">	freedefer(d)</span><br><span class="line">	<span class="comment">// If the defer function pointer is nil, force the seg fault to happen</span></span><br><span class="line">	<span class="comment">// here rather than in jmpdefer. gentraceback() throws an error if it is</span></span><br><span class="line">	<span class="comment">// called with a callback on an LR architecture and jmpdefer is on the</span></span><br><span class="line">	<span class="comment">// stack, because the stack trace can be incorrect in that case - see</span></span><br><span class="line">	<span class="comment">// issue #8153).</span></span><br><span class="line">	_ = fn.fn</span><br><span class="line">	jmpdefer(fn, <span class="type">uintptr</span>(unsafe.Pointer(&amp;arg0)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-背景说明"><a href="#4-背景说明" class="headerlink" title="4. 背景说明"></a>4. 背景说明</h2><ol>
<li>write barrier，可以参考golang垃圾回收的说明。</li>
<li>Go:nosplit <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016743220">Go 语言编译器的 “&#x2F;&#x2F;go:” 详解</a></li>
<li>Open coded-defer</li>
</ol>
<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903936508297223">深入理解Go-defer的原理剖析</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2021/05/02/defer%E8%AF%A6%E8%A7%A3/" data-id="cl0t1dd0v00468slf4b4890co" data-title="defer详解" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-pprof备忘录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/28/pprof%E5%A4%87%E5%BF%98%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2021-04-28T03:50:20.000Z" itemprop="datePublished">2021-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/28/pprof%E5%A4%87%E5%BF%98%E5%BD%95/">pprof备忘录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    pprof原理是go runtime对运行的程序进行一定频率的抽样，将数据保存为profile.proto格式，然后通过go tool pprof来读取。但是就我观察，线上能跑很久的程序用pprof是观察不到什么性能问题的，因为top命令下榜上有名的都是一些runtime级别的函数操作。这些操作在大部分业务逻辑里都会触及到，几乎无法定位到底是哪一部分逻辑有问题。</p>
<p>​    因此，pprof不是银色子弹，过多的研究pprof这个工具是没有多大性价比的。我在此文中不过是想记录下一些网上博客（复制黏贴）泛泛而谈的pprof“详解”里没有说清楚的东西（至少是我自己当时没看懂的东西）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://github.com/google/pprof/blob/master/doc/README.md">pprof</a>里解释了一些指标的意思，还有callgraph里各图形的含义。有两个地方要注意：</p>
<ol>
<li>对于每一个抽样点都会有两个衡量数据：</li>
</ol>
<blockquote>
<ul>
<li><em>flat</em>: the value of the location itself.</li>
<li><em>cum</em>: the value of the location plus all its descendants.</li>
</ul>
</blockquote>
<p>大白话来讲就是，flat的值只在抽样的时候正好处于该处代码逻辑的CPU时间或者内存等，cum的值为抽样时程序堆栈没有在处理该处代码，但是其逻辑是由该处代码触发的。也会汇总算到该处代码的cum值上去。所以flat&lt;&#x3D;cum。</p>
<ol start="2">
<li>既然是抽样，那么也要考虑到业务的代码覆盖率。比如有一个if A else B的业务逻辑，虽然pprof里看到A的耗时更多，但是并不代表B的耗时就一定比A少，有可能只是B被命中的少。</li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.golang.org/pprof">Profiling Go Programs</a>详细介绍了一个具体的调优过程。</p>
</li>
<li><p>很多时候我们都是在远程机器上把生成的pprof文件下载下来到本地机器上去查看分析，因此代码路径会变化。如果用list显示错误，很有可能是编译的位置和go tool pprof的位置不一致导致的，可以看看下面的问答，主要是把编译的位置写到–trim_path，把源码的位置写到–source_path。参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/59592086/go-tool-pprof-how-to-specify-source-when-using-go-modules">go tool pprof - how to specify source when using go modules?</a></p>
</li>
<li><p><code>curl -o trace.out http://host:port/debug/pprof/trace?seconds=15</code> 可以观察到15秒的一个运行情况。trace.out可以放到本地终端然后<code>go tool trace trace.out </code>会自动打开浏览器有结果的展示。（⚠️要用chrome浏览器，如果view trace还是空白的话，需要升级本地go版本看看）。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://about.sourcegraph.com/go/an-introduction-to-go-tool-trace-rhys-hiltner/">An introduction to go tool trace</a>参考一下怎么看trace信息。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://software.intel.com/content/www/us/en/develop/blogs/debugging-performance-issues-in-go-programs.html">Debugging performance issues in Go* programs</a></p>
</li>
<li><p>获取goroutine的 <code>curl http://ip:8430/debug/pprof/goroutine?debug=2 -o g.txt</code></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2021/04/28/pprof%E5%A4%87%E5%BF%98%E5%BD%95/" data-id="cl0t1ddcc005m8slfdb7u93js" data-title="pprof备忘录" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pprof/" rel="tag">Pprof</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hexo博客配置备忘录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/28/hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%A4%87%E5%BF%98%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2021-04-28T02:48:03.000Z" itemprop="datePublished">2021-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hexo/">Hexo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/28/hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%A4%87%E5%BF%98%E5%BD%95/">hexo博客配置备忘录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="hexo博客的迁移"><a href="#hexo博客的迁移" class="headerlink" title="hexo博客的迁移"></a>hexo博客的迁移</h2><p>hexo+github搭建博客的教程有很多，但是为了后续更换电脑能够快速切换环境，这里做一下笔记。</p>
<ol>
<li>首先github的master分支是hexo自动生成和上传的，这一部分不需要在本地有所保存。</li>
<li>在本地开辟一个分支叫做source，和远程的source连接起来。</li>
<li>更换电脑后，将source分支的clone到本地然后执行,前提是把git，npm和nodejs都安装好了。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h2 id="新增标签和分类页面"><a href="#新增标签和分类页面" class="headerlink" title="新增标签和分类页面"></a>新增标签和分类页面</h2><p><a target="_blank" rel="noopener" href="https://geneliunx.com/2019/09/12/new-tags-and-categories/">Hexo 使用指南 —— 添加分类及标签</a></p>
<h2 id="支持latex语法"><a href="#支持latex语法" class="headerlink" title="支持latex语法"></a>支持latex语法</h2><p><a target="_blank" rel="noopener" href="https://cps.ninja/2019/03/16/hexo-with-latex/">让 Hexo 搭建的博客支持 LaTeX</a> </p>
<p>但每次hexo g都会有一个错误输出，<code>Plugin load failed: %s hexo-math</code></p>
<h2 id="支持图片"><a href="#支持图片" class="headerlink" title="支持图片"></a>支持图片</h2><p><a target="_blank" rel="noopener" href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">Hexo博客搭建之在文章中插入图片</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2021/04/28/hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%A4%87%E5%BF%98%E5%BD%95/" data-id="cl0t1dd1700558slfbndl20p9" data-title="hexo博客配置备忘录" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-golang反射详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/golang%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T10:28:04.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/golang%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3/">golang反射详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    描述一个变量无非是从type和value下手，分别对应reflect的TypeOf和ValueOf接口。前者返回一个Type接口变量（其真正实现是rtype），后者返回一个Value结构体对象。这两个对象分别都有很多方法，要注意的是不是每一个类型都可以调用所有方法，用的时候可以看看接口的注释，看某些方法是针对某些类型的。</p>
<p>对变量type的描述则用rtype来定义，其中那个kind的后五位（因为一共定义了27个类型）则用来描述基本类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> rtype <span class="keyword">struct</span> &#123;</span><br><span class="line">	size       <span class="type">uintptr</span></span><br><span class="line">	ptrdata    <span class="type">uintptr</span>  <span class="comment">// number of bytes in the type that can contain pointers</span></span><br><span class="line">	hash       <span class="type">uint32</span>   <span class="comment">// hash of type; avoids computation in hash tables</span></span><br><span class="line">	tflag      tflag    <span class="comment">// extra type information flags</span></span><br><span class="line">	align      <span class="type">uint8</span>    <span class="comment">// alignment of variable with this type</span></span><br><span class="line">	fieldAlign <span class="type">uint8</span>    <span class="comment">// alignment of struct field with this type</span></span><br><span class="line">	kind       <span class="type">uint8</span>    <span class="comment">// enumeration for C</span></span><br><span class="line">	alg        *typeAlg <span class="comment">// algorithm table</span></span><br><span class="line">	gcdata     *<span class="type">byte</span>    <span class="comment">// garbage collection data</span></span><br><span class="line">	str        nameOff  <span class="comment">// string form</span></span><br><span class="line">	ptrToThis  typeOff  <span class="comment">// type for pointer to this type, may be zero</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reflect包定义了最基本的类型，并将类型的类型（有点拗口）定义为Kind。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Kind <span class="type">uint</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Invalid Kind = <span class="literal">iota</span></span><br><span class="line">	Bool</span><br><span class="line">	Int</span><br><span class="line">	Int8</span><br><span class="line">	Int16</span><br><span class="line">	Int32</span><br><span class="line">	Int64</span><br><span class="line">	Uint</span><br><span class="line">	Uint8</span><br><span class="line">	Uint16</span><br><span class="line">	Uint32</span><br><span class="line">	Uint64</span><br><span class="line">	Uintptr</span><br><span class="line">	Float32</span><br><span class="line">	Float64</span><br><span class="line">	Complex64</span><br><span class="line">	Complex128</span><br><span class="line">	Array</span><br><span class="line">	Chan</span><br><span class="line">	Func</span><br><span class="line">	Interface</span><br><span class="line">	Map</span><br><span class="line">	Ptr</span><br><span class="line">	Slice</span><br><span class="line">	String</span><br><span class="line">	Struct</span><br><span class="line">	UnsafePointer</span><br><span class="line">)	</span><br></pre></td></tr></table></figure>

<h2 id="函数的反射"><a href="#函数的反射" class="headerlink" title="函数的反射"></a>函数的反射</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013532622">go rpc 源码分析</a>，rpc的调用就使用了反射机制。</p>
<h2 id="三大定理"><a href="#三大定理" class="headerlink" title="三大定理"></a>三大定理</h2><p><a target="_blank" rel="noopener" href="https://blog.golang.org/laws-of-reflection">The Laws of Reflection</a> 前两条讲的是interface{}和其反射对象的相互转化，第三条比较重要。当我们用ValueOf获取到的反射对象来修改原来变量的值的时候，需要首先将变量的指针作为参数传入，然后要用到Elem()方法获取到变量的值，才能够修改。原因可以看看参考的原文。</p>
<h3 id="尽量少使用"><a href="#尽量少使用" class="headerlink" title="尽量少使用"></a>尽量少使用</h3><p>原因一是使用不当就很可能panic；原因二是性能非常低。拿利用反射调用函数来说，其性能大概慢了将近1800倍（8核 16GB）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2021/04/07/golang%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3/" data-id="cl0t1dd0y004f8slfgt7o1j7g" data-title="golang反射详解" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-linux环境开发备忘录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/02/linux%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2021-04-02T09:01:28.703Z" itemprop="datePublished">2021-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/02/linux%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98%E5%BD%95/">linux环境开发备忘录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="linux环境开发备忘录"><a href="#linux环境开发备忘录" class="headerlink" title="linux环境开发备忘录"></a>linux环境开发备忘录</h1><h2 id="linux基本命令"><a href="#linux基本命令" class="headerlink" title="linux基本命令"></a>linux基本命令</h2><h3 id="Shell语法"><a href="#Shell语法" class="headerlink" title="Shell语法"></a>Shell语法</h3><ol>
<li>最开头需要添加<code>*#!/bin/bash*</code>。</li>
<li>变量的定义是<code>your_name=“runoob.com”</code>，不要有空格。用双引号可以解析变量，单引号则原封不动地输出。</li>
<li>使用变量用${parm}</li>
<li>预置变量</li>
</ol>
<table>
<thead>
<tr>
<th align="center">参数处理</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$#</td>
<td align="center">传递到脚本的参数个数,包括命令本身，其变量为$0</td>
</tr>
<tr>
<td align="center">$*</td>
<td align="center">以一个单字符串显示所有向脚本传递的参数,以”$1 $2 … $n”的形式输出所有参数。</td>
</tr>
<tr>
<td align="center">$$</td>
<td align="center">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td align="center">$!</td>
<td align="center">后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td align="center">$@</td>
<td align="center">与$*相同，但是以“$1”  “$2” … “$n”的形式将所有参数分开成多个字符串输出。</td>
</tr>
<tr>
<td align="center">$?</td>
<td align="center">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
<tr>
<td align="center">5. 使用$(command)来获取执行命令后的结果作为代码。</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol>
<li><code>wc -l &#123;文件名&#125;</code>是用来查看文件的newline的数量的。在linux系统中，newline字符就是 \n 字符。</li>
<li>查找字符串，其中搜寻字符串支持正则匹配式，注意为了避免shell的元字符对正则表达式的影响，请用单引号（’’）括起来，千万不要用双引号括起来（””）或者不括起来。</li>
</ol>
<blockquote>
<p>grep [-acinv] [–color&#x3D;auto] [-A n] [-B n] ‘搜寻字符串’ 文件名<br>参数说明：<br>-a：将二进制文档以文本方式处理<br>-c：显示匹配次数<br>-i：忽略大小写差异<br>-n：在行首显示行号<br>-A：After的意思，显示匹配字符串后n行的数据<br>-B：before的意思，显示匹配字符串前n行的数据<br>-v：显示没有匹配行<br>-A：After的意思，显示匹配部分之后n行<br>-B：before的意思，显示匹配部分之前n行<br>–color：以特定颜色高亮显示匹配关键字</p>
</blockquote>
<table>
<thead>
<tr>
<th>元数据</th>
<th>意义和范例</th>
</tr>
</thead>
<tbody><tr>
<td>^word</td>
<td>搜寻以word开头的行。 例如：搜寻以#开头的脚本注释行 grep –n ‘^#’ regular.txt word$    搜寻以word结束的行</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意一个字符。 例如：grep –n ‘e.e’ regular.txt 匹配e和e之间有任意一个字符，可以匹配eee，eae，eve，但是不匹配ee。</td>
</tr>
<tr>
<td>\</td>
<td>转义字符。 例如：搜寻’，’是一个特殊字符，在正则表达式中有特殊含义。必须要先转义。grep –n ‘,” regular.txt</td>
</tr>
<tr>
<td>*</td>
<td>前面的字符重复0到多次。 例如匹配gle，gogle，google，gooogle等等 grep –n ‘go*gle’ regular.txt</td>
</tr>
<tr>
<td>[list]</td>
<td>匹配一系列字符中的一个。 例如：匹配gl，gf。grep –n ‘g[lf]’ regular.txt</td>
</tr>
<tr>
<td>[n1-n2]</td>
<td>匹配一个字符范围中的一个字符。 例如：匹配数字字符 grep –n ‘[0-9]’ regular.txt</td>
</tr>
<tr>
<td>[^list]</td>
<td>匹配字符集以外的字符 例如：grep –n ‘[^o]‘ regular.txt 匹配非o字符</td>
</tr>
</tbody></table>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><h2 id="IO过程"><a href="#IO过程" class="headerlink" title="IO过程"></a>IO过程</h2><h3 id="1-1-iotop"><a href="#1-1-iotop" class="headerlink" title="1.1 iotop"></a>1.1 iotop</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Total DISK READ :       0.00 B/s | Total DISK WRITE :       0.00 B/s</span><br><span class="line">Actual DISK READ:       0.00 B/s | Actual DISK WRITE:      19.68 K/s</span><br><span class="line">  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND                                                                                                                          </span><br><span class="line">27159 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.01 % [kworker/4:1]</span><br><span class="line"> 2847 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % containerd</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure>

<ol>
<li>TID可以理解为线程ID，在linux下线程和进程是同等调度的。</li>
<li>PRIO是io的优先级，具体可以看看man ionice。只有io调度队列为cfq，才会有这些优先级的概念。</li>
</ol>
<h3 id="1-2-iostat"><a href="#1-2-iostat" class="headerlink" title="1.2 iostat"></a>1.2 iostat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ iostat -x 1</span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.38    0.00    0.15    0.01    0.00   99.47</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">vda               0.00     2.61    0.03    1.90     0.83    57.89    61.06     0.01    4.03    5.54    4.01   0.43   0.08</span><br><span class="line">vdb               0.00     0.10    0.00    0.10     0.00     0.80    16.00     0.00    0.13    0.56    0.13   0.10   0.00</span><br><span class="line">scd0              0.00     0.00    0.00    0.00     0.00     0.00     7.23     0.00    0.27    0.27    0.00   0.27   0.00</span><br></pre></td></tr></table></figure>

<ol>
<li>iowait和%util是比较关键的，vad，vdb代表了磁盘。avgrq-sz表示对io的请求大小（多少个扇区），avgqu-sz是io队列的长度。具体都可以man iostat看，比较好理解。</li>
<li>%util的值可以衡量当前io的使用率但可能存在误差，比如raid的磁盘阵列，比如向三块磁盘写数据，实际上是同时写到三个磁盘上去的，这样能提高效率，但是%util一般指表示一个磁盘的io占用率。</li>
</ol>
<h3 id="1-3-sar"><a href="#1-3-sar" class="headerlink" title="1.3 sar"></a>1.3 sar</h3><p>这是linux下的一个瑞士军刀，但没什么新鲜的信息。</p>
<h3 id="1-4-lsof"><a href="#1-4-lsof" class="headerlink" title="1.4 lsof"></a>1.4 lsof</h3><p>一直只用<code>lsof -i:&lt;port&gt;</code>，但其实lsof是list open file的缩写，它会展示所有打开的文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ lsof -p $$</span><br><span class="line">COMMAND  PID USER   FD   TYPE DEVICE  SIZE/OFF  NODE NAME</span><br><span class="line">zsh     5447 root  cwd    DIR  252,1      4096 52566 /root</span><br><span class="line">zsh     5447 root  rtd    DIR  252,1      4096     2 /</span><br><span class="line">zsh     5447 root  txt    REG  252,1    736312 51229 /usr/bin/zsh</span><br><span class="line">zsh     5447 root  mem    REG  252,1     70248 51238 /usr/lib64/zsh/5.0.2/zsh/computil.so</span><br><span class="line">......</span><br><span class="line">zsh     5447 root    0u   CHR  136,0       0t0     3 /dev/pts/0</span><br><span class="line">zsh     5447 root    1u   CHR  136,0       0t0     3 /dev/pts/0</span><br><span class="line">zsh     5447 root    2u   CHR  136,0       0t0     3 /dev/pts/0</span><br><span class="line">zsh     5447 root   10u   CHR  136,0       0t0     3 /dev/pts/0</span><br></pre></td></tr></table></figure>

<ol>
<li>FD的具体含义可以</li>
</ol>
<h2 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h2><h3 id="2-1-free"><a href="#2-1-free" class="headerlink" title="2.1 free"></a>2.1 free</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          15714        2178        3221         305       10315       13121</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure>

<p>别的不多说，主要说一下buff&#x2F;cacheh。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fanren224/article/details/89455109">内存free命令的含义 buffers和cache</a>里和man free里的说法是buff是块设备的内存，cache是普通文件和slab的内存。</p>
<h3 id="vmstate"><a href="#vmstate" class="headerlink" title="vmstate"></a>vmstate</h3><h2 id="3-网络"><a href="#3-网络" class="headerlink" title="3. 网络"></a>3. 网络</h2><h3 id="3-1-ping"><a href="#3-1-ping" class="headerlink" title="3.1 ping"></a>3.1 ping</h3><p>原理是利用网络协议网络层的ICMP协议，来确认网络是否可达。它没有单独的网络包结构，是嵌入IP包里的。具体可以参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaolincoding/p/12571184.html">20 张图解： ping 的工作原理</a></p>
<h3 id="3-2-ncat-x2F-nc"><a href="#3-2-ncat-x2F-nc" class="headerlink" title="3.2 ncat&#x2F;nc"></a>3.2 ncat&#x2F;nc</h3><p>是一整套网络工具，用于做一些简单的测试。</p>
<h3 id="3-3-netstat"><a href="#3-3-netstat" class="headerlink" title="3.3 netstat"></a>3.3 netstat</h3><p>用于监控网络出入包等情况。可以参考<a target="_blank" rel="noopener" href="https://www.howtogeek.com/513003/how-to-use-netstat-on-linux/">How to Use netstat on Linux</a>和<a target="_blank" rel="noopener" href="https://www.tecmint.com/20-netstat-commands-for-linux-network-management/">20 Netstat Commands for Linux Network Management</a></p>
<h2 id="linux基础"><a href="#linux基础" class="headerlink" title="linux基础"></a>linux基础</h2><h3 id="x2F-bin-x2F-sbin-x2F-usr-x2F-sbin-x2F-usr-x2F-bin-目录的区别"><a href="#x2F-bin-x2F-sbin-x2F-usr-x2F-sbin-x2F-usr-x2F-bin-目录的区别" class="headerlink" title="&#x2F;bin,&#x2F;sbin,&#x2F;usr&#x2F;sbin,&#x2F;usr&#x2F;bin 目录的区别"></a>&#x2F;bin,&#x2F;sbin,&#x2F;usr&#x2F;sbin,&#x2F;usr&#x2F;bin 目录的区别</h3><blockquote>
<p>/bin 是系统的一些指令。bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。<br> /sbin 一般是指超级用户指令。主要放置一些系统管理的必备程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。<br> /usr/bin 是你在后期安装的一些软件的运行脚本。主要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb、wget等。<br> /usr/sbin 放置一些用户安装的系统管理的必备程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等。</p>
</blockquote>
<h2 id="开发环境配置问题"><a href="#开发环境配置问题" class="headerlink" title="开发环境配置问题"></a>开发环境配置问题</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34024112">yum install的版本会落后很多，Linux 下安装python制定版本</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/778416">让Curl支持HTTP 2.0</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ohmyzsh/ohmyzsh/issues/8038">zsh终端配置失败 source ~&#x2F;.zshrc error #8038</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a20964b88f98">Mac 上 npm 升级</a></p>
<h3 id="vscode配置"><a href="#vscode配置" class="headerlink" title="vscode配置"></a>vscode配置</h3><ol>
<li><code>Error loading workspace: unsupported version of go</code> 一般是安装的一些tools和go的版本不一致，ctrl+shift+p调出控制命令框，然后Go install&#x2F;update Tools。参考<a target="_blank" rel="noopener" href="https://github.com/microsoft/vscode-go/issues/3092">After upgrade every time I open VS Code I get a <code>Error loading workspace folders</code></a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2021/04/02/linux%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98%E5%BD%95/" data-id="cl0t1ddca005g8slffadi1p2b" data-title="linux环境开发备忘录" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/code/" rel="tag">code</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-GMP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/02/GMP/" class="article-date">
  <time class="dt-published" datetime="2021-04-02T06:46:41.000Z" itemprop="datePublished">2021-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/02/GMP/">goroutine详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-Goroutine的堆栈输出说明"><a href="#1-Goroutine的堆栈输出说明" class="headerlink" title="1. Goroutine的堆栈输出说明"></a>1. Goroutine的堆栈输出说明</h2><p><img src="/Users/husyhu/Library/Mobile%20Documents/com~apple~CloudDocs/husy1994.github.io/source/_posts/image-20210324142746220.png" alt="image-20210324142746220"></p>
<p>​    大部分都很容易理解，主要是说明一下其中红色框框里的数据是什么。参考<a target="_blank" rel="noopener" href="https://www.joeshaw.org/understanding-go-panic-output/">Understanding Go panic output</a>和<a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2015/01/stack-traces-in-go.html">Stack Traces In Go</a> 主要结论如下：</p>
<ol>
<li>如果是一个有接收者的函数调用，先是接收者的一个数据打印；</li>
<li>然后以此是从左到右的参数的结构打印。</li>
<li>最后是返回值的结构打印。</li>
<li>最多打印十个字段，多了的就截断了。</li>
</ol>
<p>​    要注意的是，不同类型的数据打印的数量和方式不一样。比如int类型就是一个简单的十六进制数字，就是其值本身。而string类型要打印两个字段，第一个是该字段长度，第二个是指向字符串的指针。等等，这些可以去查看具体的类型定义来查看。</p>
<p>​    另外，<code>groutine 1[chan receive]</code>里的chan receive是一系列枚举值，在go语言里的类型为waitReason，用于描述goroutine挂起的原因。具体的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitReason <span class="type">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	waitReasonZero                  waitReason = <span class="literal">iota</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line">	waitReasonGCAssistMarking                         <span class="comment">// &quot;GC assist marking&quot;</span></span><br><span class="line">	waitReasonIOWait                                  <span class="comment">// &quot;IO wait&quot;</span></span><br><span class="line">	waitReasonChanReceiveNilChan                      <span class="comment">// &quot;chan receive (nil chan)&quot;</span></span><br><span class="line">	waitReasonChanSendNilChan                         <span class="comment">// &quot;chan send (nil chan)&quot;</span></span><br><span class="line">	waitReasonDumpingHeap                             <span class="comment">// &quot;dumping heap&quot;</span></span><br><span class="line">	waitReasonGarbageCollection                       <span class="comment">// &quot;garbage collection&quot;</span></span><br><span class="line">	waitReasonGarbageCollectionScan                   <span class="comment">// &quot;garbage collection scan&quot;</span></span><br><span class="line">	waitReasonPanicWait                               <span class="comment">// &quot;panicwait&quot;</span></span><br><span class="line">	waitReasonSelect                                  <span class="comment">// &quot;select&quot;</span></span><br><span class="line">	waitReasonSelectNoCases                           <span class="comment">// &quot;select (no cases)&quot;</span></span><br><span class="line">	waitReasonGCAssistWait                            <span class="comment">// &quot;GC assist wait&quot;</span></span><br><span class="line">	waitReasonGCSweepWait                             <span class="comment">// &quot;GC sweep wait&quot;</span></span><br><span class="line">	waitReasonGCScavengeWait                          <span class="comment">// &quot;GC scavenge wait&quot;</span></span><br><span class="line">	waitReasonChanReceive                             <span class="comment">// &quot;chan receive&quot;</span></span><br><span class="line">	waitReasonChanSend                                <span class="comment">// &quot;chan send&quot;</span></span><br><span class="line">	waitReasonFinalizerWait                           <span class="comment">// &quot;finalizer wait&quot;</span></span><br><span class="line">	waitReasonForceGGIdle                             <span class="comment">// &quot;force gc (idle)&quot;</span></span><br><span class="line">	waitReasonSemacquire                              <span class="comment">// &quot;semacquire&quot;</span></span><br><span class="line">	waitReasonSleep                                   <span class="comment">// &quot;sleep&quot;</span></span><br><span class="line">	waitReasonSyncCondWait                            <span class="comment">// &quot;sync.Cond.Wait&quot;</span></span><br><span class="line">	waitReasonTimerGoroutineIdle                      <span class="comment">// &quot;timer goroutine (idle)&quot;</span></span><br><span class="line">	waitReasonTraceReaderBlocked                      <span class="comment">// &quot;trace reader (blocked)&quot;</span></span><br><span class="line">	waitReasonWaitForGCCycle                          <span class="comment">// &quot;wait for GC cycle&quot;</span></span><br><span class="line">	waitReasonGCWorkerIdle                            <span class="comment">// &quot;GC worker (idle)&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>用一个例子来作为线索看其源码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> ()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    z := x + y</span><br><span class="line">		<span class="keyword">return</span> z </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">0x100</span></span><br><span class="line">    y := <span class="number">0x200</span></span><br><span class="line">		<span class="keyword">go</span> add(x, y) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//编译</span><br><span class="line">go build -o ex1 ex1.go</span><br><span class="line">go tool objdump -s &quot;main\.main&quot; ./ex1</span><br><span class="line">TEXT main.main(SB) /root/workspace/ex/ex1.go</span><br><span class="line">  ex1.go:6              0x4525d0                64488b0c25f8ffffff      MOVQ FS:0xfffffff8, CX</span><br><span class="line">  ex1.go:6              0x4525d9                483b6110                CMPQ 0x10(CX), SP</span><br><span class="line">  ex1.go:6              0x4525dd                7642                    JBE 0x452621</span><br><span class="line">  ex1.go:6              0x4525df                4883ec30                SUBQ $0x30, SP</span><br><span class="line">  ex1.go:6              0x4525e3                48896c2428              MOVQ BP, 0x28(SP)</span><br><span class="line">  ex1.go:6              0x4525e8                488d6c2428              LEAQ 0x28(SP), BP</span><br><span class="line">  ex1.go:9              0x4525ed                c7042418000000          MOVL $0x18, 0(SP)</span><br><span class="line">  ex1.go:9              0x4525f4                488d058d580200          LEAQ 0x2588d(IP), AX</span><br><span class="line">  ex1.go:9              0x4525fb                4889442408              MOVQ AX, 0x8(SP)</span><br><span class="line">  ex1.go:9              0x452600                48c744241000010000      MOVQ $0x100, 0x10(SP)</span><br><span class="line">  ex1.go:9              0x452609                48c744241800020000      MOVQ $0x200, 0x18(SP)</span><br><span class="line">  ex1.go:9              0x452612                e879b7fdff              CALL runtime.newproc(SB)</span><br><span class="line">  ex1.go:9              0x452617                488b6c2428              MOVQ 0x28(SP), BP</span><br><span class="line">  ex1.go:9              0x45261c                4883c430                ADDQ $0x30, SP</span><br><span class="line">  ex1.go:9              0x452620                c3                      RET</span><br><span class="line">  ex1.go:6              0x452621                e8da7affff              CALL runtime.morestack_noctxt(SB)</span><br><span class="line">  ex1.go:6              0x452626                eba8                    JMP main.main(SB)</span><br></pre></td></tr></table></figure>

<p>可以看到main.main部分的函数实际的汇编如上，做了一系列准备后，调用了runtime.newproc函数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb ex1</span><br><span class="line">(gdb) b runtime.newproc</span><br><span class="line">Breakpoint 2 at 0x42dd90: file /usr/local/go/src/runtime/proc.go, line 3251.</span><br></pre></td></tr></table></figure>

<p>于是去上述文件里找到对应的函数观察(后续基本都是这样子找函数的，不再赘述。)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器讲go关键字转化成调用该函数，fn为goroutine要运行的函数，size为fn的参数的内存大小。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="type">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">  <span class="comment">//在fn内存地址的基础上加上一个指针的长度（也就是fn存储的长度），由于这是栈，因此就可以指向在压fn之前的第一个参数的地址。</span></span><br><span class="line">	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">	gp := getg()</span><br><span class="line">	pc := getcallerpc() <span class="comment">//获取当前groutine的PC，也就是go func的位置。</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		newproc1(fn, (*<span class="type">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看看newproc1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new g running fn with narg bytes of arguments starting</span></span><br><span class="line"><span class="comment">// at argp. callerpc is the address of the go statement that created</span></span><br><span class="line"><span class="comment">// this. The new g is put on the queue of g&#x27;s waiting to run.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="type">uint8</span>, narg <span class="type">int32</span>, callergp *g, callerpc <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">		_g_.m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">		throw(<span class="string">&quot;go of nil func value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	acquirem() <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">	siz := narg</span><br><span class="line">	siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span> <span class="comment">//内存对齐</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// We could allocate a larger initial stack if necessary.</span></span><br><span class="line">	<span class="comment">// Not worth it: this is almost always an error.</span></span><br><span class="line">	<span class="comment">// 4*sizeof(uintreg): extra space added below</span></span><br><span class="line">	<span class="comment">// sizeof(uintreg): caller&#x27;s LR (arm) or return address (x86, in gostartcall).</span></span><br><span class="line">	<span class="keyword">if</span> siz &gt;= _StackMin<span class="number">-4</span>*sys.RegSize-sys.RegSize &#123;</span><br><span class="line">		throw(<span class="string">&quot;newproc: function arguments too large for new goroutine&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从当前p的空闲链表里获取goroutine,如果没有先从global runqueue里获取一批（保持32个）</span></span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">	newg := gfget(_p_)</span><br><span class="line">	<span class="keyword">if</span> newg == <span class="literal">nil</span> &#123; <span class="comment">//如果没获取到空闲goroutine，则创建一个goroutine</span></span><br><span class="line">		newg = malg(_StackMin)</span><br><span class="line">		casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">		allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#x27;t look at uninitialized stack.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> newg.stack.hi == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;newproc1: newg missing stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class="line">		throw(<span class="string">&quot;newproc1: new g is not Gdead&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	totalSize := <span class="number">4</span>*sys.RegSize + <span class="type">uintptr</span>(siz) + sys.MinFrameSize <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line">	totalSize += -totalSize &amp; (sys.SpAlign - <span class="number">1</span>)                  <span class="comment">// align to spAlign</span></span><br><span class="line">	sp := newg.stack.hi - totalSize</span><br><span class="line">	spArg := sp</span><br><span class="line">	<span class="keyword">if</span> usesLR &#123;</span><br><span class="line">		<span class="comment">// caller&#x27;s LR</span></span><br><span class="line">		*(*<span class="type">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">		prepGoExitFrame(sp)</span><br><span class="line">		spArg += sys.MinFrameSize</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> narg &gt; <span class="number">0</span> &#123;</span><br><span class="line">		memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), <span class="type">uintptr</span>(narg))</span><br><span class="line">		<span class="comment">// This is a stack-to-stack copy. If write barriers</span></span><br><span class="line">		<span class="comment">// are enabled and the source stack is grey (the</span></span><br><span class="line">		<span class="comment">// destination is always black), then perform a</span></span><br><span class="line">		<span class="comment">// barrier copy. We do this *after* the memmove</span></span><br><span class="line">		<span class="comment">// because the destination stack may have garbage on</span></span><br><span class="line">		<span class="comment">// it.</span></span><br><span class="line">		<span class="keyword">if</span> writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone &#123;</span><br><span class="line">			f := findfunc(fn.fn)</span><br><span class="line">			stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))</span><br><span class="line">			<span class="keyword">if</span> stkmap.nbit &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// We&#x27;re in the prologue, so it&#x27;s always stack map index 0.</span></span><br><span class="line">				bv := stackmapdata(stkmap, <span class="number">0</span>)</span><br><span class="line">				bulkBarrierBitmap(spArg, spArg, <span class="type">uintptr</span>(bv.n)*sys.PtrSize, <span class="number">0</span>, bv.bytedata)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">	newg.sched.sp = sp</span><br><span class="line">	newg.stktopsp = sp</span><br><span class="line">	newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">	newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">	gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">	newg.gopc = callerpc</span><br><span class="line">	newg.ancestors = saveAncestors(callergp)</span><br><span class="line">	newg.startpc = fn.fn</span><br><span class="line">	<span class="keyword">if</span> _g_.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">		newg.labels = _g_.m.curg.labels</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> isSystemGoroutine(newg, <span class="literal">false</span>) &#123;</span><br><span class="line">		atomic.Xadd(&amp;sched.ngsys, +<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	newg.gcscanvalid = <span class="literal">false</span></span><br><span class="line">	casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _p_.goidcache == _p_.goidcacheend &#123;</span><br><span class="line">		<span class="comment">// Sched.goidgen is the last allocated id,</span></span><br><span class="line">		<span class="comment">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span></span><br><span class="line">		<span class="comment">// At startup sched.goidgen=0, so main goroutine receives goid=1.</span></span><br><span class="line">		_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</span><br><span class="line">		_p_.goidcache -= _GoidCacheBatch - <span class="number">1</span></span><br><span class="line">		_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</span><br><span class="line">	&#125;</span><br><span class="line">	newg.goid = <span class="type">int64</span>(_p_.goidcache)</span><br><span class="line">	_p_.goidcache++</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		newg.racectx = racegostart(callerpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoCreate(newg, newg.startpc)</span><br><span class="line">	&#125;</span><br><span class="line">	runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &amp;&amp; mainStarted &#123;</span><br><span class="line">		wakep()</span><br><span class="line">	&#125;</span><br><span class="line">	releasem(_g_.m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考<a target="_blank" rel="noopener" href="https://medium.com/@ankur_anand/illustrated-tales-of-go-runtime-scheduler-74809ef6d19b">Illustrated Tales of Go Runtime Scheduler.</a>和<a target="_blank" rel="noopener" href="https://morsmachine.dk/go-scheduler">The Go scheduler</a>，<a target="_blank" rel="noopener" href="https://morsmachine.dk/netpoller">The Go netpoller</a>，<a target="_blank" rel="noopener" href="https://yizhi.ren/2019/06/03/goscheduler/">golang scheduler</a>，<a target="_blank" rel="noopener" href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/">也谈goroutine调度器 </a></p>
<h3 id="1-为什么会有goroutine？"><a href="#1-为什么会有goroutine？" class="headerlink" title="1.为什么会有goroutine？"></a>1.为什么会有goroutine？</h3><ol>
<li>线程依旧太expensive（还有一些是不需要的逻辑，比如signal mask）</li>
<li>gc的算法是stop the world，需要在数据一致时才能调用。如果单纯用thread的话，go runtime无法获取这一信息。</li>
</ol>
<h2 id="4-2-GMP"><a href="#4-2-GMP" class="headerlink" title="4.2 GMP"></a>4.2 GMP</h2><p>​    线程和Goroutine的映射关系模型有三种：1:1，M：1和M：N。GMP使用的是M：N模型，原因很简单，为了尽可能的压榨CPU的性能，缺点是调度器的设计会非常复杂。</p>
<p>​    用大白话简单说就是：G代表goroutine，有三种状态，running，runable和waiting，分别是正在运行，可运行和阻塞。M代表machine，也就是实际执行体（对应os thread），P代表process，通过P来连接G和M，管理相应的资源和调度，因此每一个P都有自己的context。P通过维护一个runqueue来管理可运行状态的goroutine，一个个依次执行，遇到阻塞的就放入阻塞队列中去，等阻塞完成后修改goroutine的状态重新放回runqueue里去。很简单对不对？如果不涉及细节的话，这一套结构和OS的线程调度大同小异。</p>
<p>​    深入一丢丢看看。</p>
<h4 id="4-2-1-获取可运行goroutine"><a href="#4-2-1-获取可运行goroutine" class="headerlink" title="4.2.1 获取可运行goroutine"></a>4.2.1 获取可运行goroutine</h4><p>先往本地runqueue去获取待运行的goroutine，如果没有再去全局runqueue去获取，再没有就去别的线程里的global runqueue里获取。</p>
<h4 id="4-2-2-阻塞goroutine的处理"><a href="#4-2-2-阻塞goroutine的处理" class="headerlink" title="4.2.2 阻塞goroutine的处理"></a>4.2.2 阻塞goroutine的处理</h4><p>阻塞的goroutine的情况无非是，channel接收和发送阻塞，请求锁，定时器，网络I&#x2F;O和阻塞的系统调用。</p>
<p>可以分为两个部分：</p>
<ol>
<li>一个是用户级别的阻塞，以channel的操作为例，当某goroutine A发送数据到channel阻塞后，channel会主动gopark这个goroutine，正常情况下，一定会有另一个goroutine B接收channel里的数据成功，goroutine B会唤醒goroutine A将其加入对应的runqueue中去。因此，当goroutine阻塞时，thread是不会阻塞的。</li>
<li>另一个是涉及系统调用。go的上层设计把所有的syscall封装一层，**runtime.entersyscall(SB)<strong>和</strong>runtime.exitsyscall(SB)**。如果系统调用是阻塞的，就把该M和P分离，让P去执行别的M里的G。后者则让M重新找到之前对应的P，让G加入其runqueue队列里继续执行。如果没找到就找一个idle的P，还没找到就将G加入global runqueue里去，然后将该M状态改为idle。</li>
</ol>
<h4 id="4-2-3-如何保证公平和效率？"><a href="#4-2-3-如何保证公平和效率？" class="headerlink" title="4.2.3 如何保证公平和效率？"></a>4.2.3 如何保证公平和效率？</h4><ol>
<li>goroutine每运行10ms就会被标记成可抢占，然后在该goroutine的下一次函数调用入口有编译器插入的协作抢占点。但这不是preemptive的，也就是说如果没有这个协作抢占点入口，那么该goroutine是不会被替换的。（在1.13版本之前）。</li>
<li>每隔N个调度就会去检查一下global runqueue，拉取一批goroutine去本地runqueue，防止饥饿。</li>
<li>在runtime初始化的sysmom那个函数里，会定时把fd注册到netpoller上，而一旦fd准备好了，就异步通知goroutine，将其放入runqueue中。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://husy-dev.github.io/2021/04/02/GMP/" data-id="cl0t1dd0x004d8slfaihi9p2q" data-title="goroutine详解" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mit6-824/">mit6.824</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/quant%E9%9D%A2%E8%AF%95%E7%BA%A2%E5%AE%9D%E4%B9%A6/">quant面试红宝书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">数据结构笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E5%AE%9D%E5%85%B8/">面试算法宝典</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APUE/" rel="tag">APUE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algroithm/" rel="tag">Algroithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/I-O/" rel="tag">I&#x2F;O</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pprof/" rel="tag">Pprof</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test/" rel="tag">Test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/" rel="tag">code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/distributed/" rel="tag">distributed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gc/" rel="tag">gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lock-free/" rel="tag">lock-free</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quant-interview/" rel="tag">quant interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raft/" rel="tag">raft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ucore/" rel="tag">ucore</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/APUE/" style="font-size: 10px;">APUE</a> <a href="/tags/Algroithm/" style="font-size: 18.57px;">Algroithm</a> <a href="/tags/CSAPP/" style="font-size: 20px;">CSAPP</a> <a href="/tags/Golang/" style="font-size: 17.14px;">Golang</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/I-O/" style="font-size: 10px;">I/O</a> <a href="/tags/Leetcode/" style="font-size: 18.57px;">Leetcode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a> <a href="/tags/OS/" style="font-size: 15.71px;">OS</a> <a href="/tags/Pprof/" style="font-size: 10px;">Pprof</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/code/" style="font-size: 10px;">code</a> <a href="/tags/distributed/" style="font-size: 11.43px;">distributed</a> <a href="/tags/gc/" style="font-size: 10px;">gc</a> <a href="/tags/golang/" style="font-size: 12.86px;">golang</a> <a href="/tags/k8s/" style="font-size: 10px;">k8s</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/lock-free/" style="font-size: 10px;">lock-free</a> <a href="/tags/quant-interview/" style="font-size: 14.29px;">quant interview</a> <a href="/tags/raft/" style="font-size: 12.86px;">raft</a> <a href="/tags/ucore/" style="font-size: 17.14px;">ucore</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 12.86px;">双指针</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18.57px;">算法</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 11.43px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/26/Prometheus-Histograms-Observation%E7%9A%84%E6%97%A0%E9%94%81%E5%AE%9E%E7%8E%B0/">Prometheus笔记</a>
          </li>
        
          <li>
            <a href="/2021/08/09/k8s%E5%AE%9E%E6%93%8D%E7%AC%94%E8%AE%B0/">k8s实操笔记</a>
          </li>
        
          <li>
            <a href="/2021/07/16/golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">golang垃圾回收</a>
          </li>
        
          <li>
            <a href="/2021/06/03/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%A4%87%E5%BF%98%E5%BD%95/">golang测试备忘录</a>
          </li>
        
          <li>
            <a href="/2021/05/02/defer%E8%AF%A6%E8%A7%A3/">defer详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Husy<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>