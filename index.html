<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Husy">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-csapp-ch3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/12/csapp-ch3/" class="article-date">
  <time class="dt-published" datetime="2022-03-12T08:21:59.048Z" itemprop="datePublished">2022-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="计算机编码"><a href="#计算机编码" class="headerlink" title="计算机编码"></a>计算机编码</h2><p>计算机有原码，反吗吗</p>
<p>CSAPP练习题</p>
<p>2.16 </p>
<table>
<thead>
<tr>
<th>A</th>
<th>1010</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>sda</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/12/csapp-ch3/" data-id="cl0t1dd0u00438slfgkz828jr" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-一道算法题的思考" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/05/%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/" class="article-date">
  <time class="dt-published" datetime="2022-03-05T08:53:27.312Z" itemprop="datePublished">2022-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>关于递归</li>
<li>关于数据类型的转换<br> 首先要知道int32能表示的最大值是2^32-1，换做二进制来表示就是除了第一位是0，其余的都是1； 负数的表示范围需要</li>
<li></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/05/%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/" data-id="cl0t1dd0s00408slfblv0ca3s" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/08/%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-02-08T12:56:35.419Z" itemprop="datePublished">2022-02-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>#mit6_824<br>#code </p>
<h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>2PL（2-phase lock）</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>2PC(2-phase commit)</p>
<h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p>wirtten-ahead log</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/08/%E7%AC%94%E8%AE%B0/" data-id="cl0t1dcyv00238slf871ba118" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Prometheus-Histograms-Observation的无锁实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/26/Prometheus-Histograms-Observation%E7%9A%84%E6%97%A0%E9%94%81%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2021-08-26T01:48:56.000Z" itemprop="datePublished">2021-08-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/26/Prometheus-Histograms-Observation%E7%9A%84%E6%97%A0%E9%94%81%E5%AE%9E%E7%8E%B0/">Prometheus Histograms Observation的无锁实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文参考自<a target="_blank" rel="noopener" href="https://grafana.com/blog/2020/01/08/lock-free-observations-for-prometheus-histograms/">Lock-free Observations for Prometheus Histograms</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>golang的设计原则是CSP（communicating sequential process)，但是在prometheus的逻辑里</p>
<h2 id="Counter-Vs-CounterVec"><a href="#Counter-Vs-CounterVec" class="headerlink" title="Counter Vs CounterVec"></a>Counter Vs CounterVec</h2><p>前者是没有label的，后者有label。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/26/Prometheus-Histograms-Observation%E7%9A%84%E6%97%A0%E9%94%81%E5%AE%9E%E7%8E%B0/" data-id="cl0t1ddcb005i8slfe0fvcd1y" data-title="Prometheus Histograms Observation的无锁实现" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lock-free/" rel="tag">lock-free</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-k8s实操笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/09/k8s%E5%AE%9E%E6%93%8D%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-08-09T02:23:32.000Z" itemprop="datePublished">2021-08-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/k8s/">k8s</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/09/k8s%E5%AE%9E%E6%93%8D%E7%AC%94%E8%AE%B0/">k8s实操笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="k8s-yaml文件的规则"><a href="#k8s-yaml文件的规则" class="headerlink" title="k8s yaml文件的规则"></a>k8s yaml文件的规则</h2><ol>
<li><p>如果是简单的tab锁进，则是map类型，如果是 - key，则是list类型，说明同样的key可能有多个。</p>
</li>
<li><p>dockerfile里的cmd和entrypoint的区别其实就是entrypoint可以接受docker run时后面添加自己要传入的参数，cmd不行，必须dockerfile里写好。因此一般用entrypoint，执行一个脚本，然后这个脚本接收一些参数。这个参数可以写在k8s的yaml文件里。</p>
</li>
<li><p>所有对资源的描述yaml文件都有下面的属性。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment">#这个api资源的版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment">#资源类型（由k8s预先定义的类型）</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 资源的属性</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span>  <span class="comment"># 资源的限制条件</span></span><br><span class="line">  <span class="string">......</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="deployment"><a href="#deployment" class="headerlink" title="deployment"></a>deployment</h3><p>deployment的yaml文件可以参考<a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/">Deployments官网说明</a>，有几个点记录一下。</p>
<ol>
<li><p>k8s的deployment.yaml文件有好几处name，label等。主要是要分清一份deployment.yaml文件既要metadata描述deployment资源对象（供管理deployment的对象筛选），又要描述其管理的pod资源对象（定义在template下面）。因此</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">	<span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<p>这里的selector也很好理解，就是为了匹配管理的pod的label。</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/09/k8s%E5%AE%9E%E6%93%8D%E7%AC%94%E8%AE%B0/" data-id="cl0t1ddc9005c8slf86470k8c" data-title="k8s实操笔记" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-golang垃圾回收" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/16/golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="article-date">
  <time class="dt-published" datetime="2021-07-16T09:34:50.000Z" itemprop="datePublished">2021-07-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/16/golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">golang垃圾回收</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>为什么计算机程序需要垃圾回收这里不再赘述了，但是作为一个开发为什么需要了解垃圾回收算法呢？要知道垃圾回收机制再设计之初就是为了让程序员可以专心写业务，不用关心太多内存的问题。所以答案显然易见，如果你不满足于调用api写业务接口，想要做一些性能优化，甚至只是想写一份优雅的业务代码，你就需要关心垃圾回收机制。当然，最重要的，面试的时候可以用来装逼。</p>
<p>那么，关于Golang垃圾回收程序员应该知道些什么？你要深入每一行代码去了解每一个细节，我当然佩服你的勇气。但我认为，主要是知道下面几点：</p>
<ol>
<li>垃圾回收几种思路其各自的优缺点；</li>
<li>Golang语言的垃圾回收有什么特点，是如何做到的；</li>
<li>我们可以从Golang的垃圾回收的设计里学习到什么？</li>
</ol>
<h2 id="垃圾回收的几种思路"><a href="#垃圾回收的几种思路" class="headerlink" title="垃圾回收的几种思路"></a>垃圾回收的几种思路</h2><p>主流上一种是引用计数算法，一种是标记清除算法。但是前者会有循环引用的问题，并且对每一个对象进行引用计数也是一笔不小的开支。本文主要是讲标记清除算法。</p>
<h3 id="1-跟踪收集法"><a href="#1-跟踪收集法" class="headerlink" title="1. 跟踪收集法"></a>1. 跟踪收集法</h3><p>垃圾回收要解决的问题无非是，把不再要用的对象占用的内存销毁掉，让别的对象可以继续使用。跟踪收集法的原理就是不断地去扫描所有对象，然后进行标记（是否需要清除），然后去回收需要清除的。而我们判断是否需要清除的标准是，该对象是否有合理的路径去访问，比如被一个全局变量引用，或者被函数栈里使用。如果可达，则不能被清除。不可达了则可以被清除。具体精确的定义可以参考</p>
<blockquote>
<ol>
<li>A distinguished set of roots: objects that are assumed to be reachable. Typically, these include all the objects referenced from anywhere in the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Call_stack">call stack</a> (that is, all <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Local_variable">local variables</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Parameter_(computer_science)">parameters</a> in the functions currently being invoked), and any <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Global_variable">global variables</a>.</li>
<li>Anything referenced from a reachable object is itself reachable; more formally, reachability is a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transitive_closure">transitive closure</a>.</li>
</ol>
<p><em>摘自<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">Tracing garbage collection</a></em></p>
</blockquote>
<h3 id="2-三色标记法"><a href="#2-三色标记法" class="headerlink" title="2. 三色标记法"></a>2. 三色标记法</h3><p>那么具体是如何实现跟踪收集的呢？其中一种比较主流的算法就是三色标记法，黑白灰实际上对应着内存对象的三种状态，白色集合里放待回收的对象和其候选人（最开始GC会把所有的内存对象都置为白色），灰色表示该对象是可达的，但是还需要扫描其各个引用。而黑色则表示该对象没有任何引用了，并且可达不能被清除。</p>
<blockquote>
<p>Three sets are created – <em>white</em>, <em>black</em> and <em>gray</em>:</p>
<ul>
<li>The white set, or <em>condemned set</em>, is the set of objects that are candidates for having their memory recycled.</li>
<li>The black set is the set of objects that can be shown to have no outgoing references to objects in the white set, and to be reachable from the roots. Objects in the black set are not candidates for collection.</li>
<li>The gray set contains all objects reachable from the roots but yet to be scanned for references to “white” objects. Since they are known to be reachable from the roots, they cannot be garbage-collected and will end up in the black set after being scanned.</li>
</ul>
<p><em>摘自<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">Tracing garbage collection</a></em></p>
</blockquote>
<p>大概步骤就是：</p>
<ol>
<li>首先将所有对象都置为白色；</li>
<li>然后将所有全局变量和main函数栈和堆里的对象都放入灰色集合；</li>
<li>开始扫描灰色集合里的对象是否有引用，有的话将其引用放入灰色集合，扫描完后的对象都放入黑色集合。</li>
<li>清除掉白色集合里的对象。</li>
</ol>
<p>上述是一个很简单的标记清除逻辑，看起来一切都很简单。标记，然后清除。但是Golang的垃圾回收器和业务程序是并发执行的，也就是说，在GC标记和清除的过程中，程序是一直是动态地在创建对象的，对象的引用也可能在变化。那么新创建的对象应该放入什么颜色的集合呢？或者说对象的引用变化了怎么办呢？不难知道会出现多写和漏写的问题（可参考<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/777750">底层原理：垃圾回收算法是如何设计的?</a>读写屏障部分）。</p>
<p>多写的现象是本该删除的白色对象在这一轮没有删除，但是如果下一轮该白色对象依旧保持原有的引用关系的话，下一轮的GC会将其删除，所以这个问题不伤害准确性。但是漏写问题则是将本不该删除的对象删除了，因此一定要避免。漏写情况的出现需要满足一个条件：灰色对象（在扫描前）删除了对白色对象的引用，但是黑色对象又对其进行了引用。</p>
<p>那么只需要破坏这个条件，就可以避免这个问题。</p>
<h3 id="3-STW与读-x2F-写屏障"><a href="#3-STW与读-x2F-写屏障" class="headerlink" title="3. STW与读&#x2F;写屏障"></a>3. STW与读&#x2F;写屏障</h3><p>解决方法有很多种。最简单的做法就是，把程序停止，让其不要继续创建新对象和修改引用了。也就是早期的串形GC，很明显，这样会影响业务程序的运行，而且因为GC的执行导致整个程序宕机的时机不可控。</p>
<p>另一种做法就是读&#x2F;写屏障。对某对象的引用改变或者创建新的对象都会涉及左值对象的写和右值对象的读，因此，只需要对读或者对写作一层封装处理，去破坏掉上述条件，这个概念叫做读&#x2F;写屏障，它不是一种特定的算法，而是一种触发机制。垃圾回收算法可以选择对被读对象进行操作，或者是对被写对象进行操作。</p>
<p>一种思路叫做增量更新，就是将在GC标记过程中变化的对象，无论之前是在什么集合，都立即放回灰色集合，等待下一轮GC的扫描。</p>
<p>另一种思路叫SATB（Snapshot At The Begining），当灰色对象删除对白色对象的引用时，它将白色对象置为灰色；当黑色对象新引用一个白色对象时，将白色对象置为黑色。这样会造成浮动垃圾，也就是本该在这轮回收的对象没有回收，但是again，这不影响其正确性，只是影响效率，所以也是可以接受的。</p>
<h3 id="4-Golang-GC"><a href="#4-Golang-GC" class="headerlink" title="4. Golang GC"></a>4. Golang GC</h3><p>终于说到本文的主角了。Golang里采用的GC是并发增量GC，其中并发和增量的目的都是为了减少STW的时间。抽象的逻辑上面已经说完了，谈到具体的实现，有几个点可以说一下。</p>
<ol>
<li>首先是内存分配会分有指针和无指针的对象分配，这就是为GC扫描做的优化。分配在无指针内存上的对象在扫描时可以直接变成黑色而不是灰色。</li>
<li>GC的标记完成后，并不是立马就把不在需要的内存释放掉而是等待下次分配的时候才释放。因此GC完毕后也不是立马就可以看到程序占用的内存变小。</li>
<li>其次是GC具体的触发时机，默认是堆内存达到原来的两倍或者每隔2分钟开始一次GC。分配的资源限制是启用CPU的1&#x2F;4来做GC。这里有一个问题就是一般业务都是用的k8s的pod部署业务，pod request里的分配的内核数一般都很小，而golang创建的process数和物理内核数是一致的。</li>
<li>如果扫描的速度小于业务请求内存分配的速度，需要分配多的goroutine执行Mark Assist逻辑，来减缓分配速度。</li>
<li>然后就是要清除虽然GC做了很多优化减少STW的时间，但并不是没有STW，在并发标记和清除时不需要STW，但是在GC开始时需要STW打开写屏障，结束时需要STW关闭写屏障，GC结束的STW需要计算下一次GC的时间和一些临时变量的清理。</li>
<li>最后就是要学会查看GC的一些调试数据，以及可以解释出该现象的原因。可以看一下参考1和参考2两篇博文。</li>
</ol>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>GC对应用程序的影响在两个时段：1. marking的时候，会占用一个物理线程，从而导致Go业务代码无法跑慢CPU；2. STW的时候会暂停所有的业务goroutine。</p>
<p>GC调优的宗旨在于在有限的堆内存上获得最大的吞吐量，也就是在两次GC之间尽可能地做多一些业务操作，老生常谈的思路就是：</p>
<ol>
<li>减少堆的内存申请，尽量复用代码，或者尽量分配在栈中。</li>
<li>找到一个合适的GC执行节奏，也就是决定下一次GC什么时候开始的算法，比如调整GC percentage option。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976">Go: How Does the Garbage Collector Mark the Memory?</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-watch-your-application-dbef99be2c35">Go: How Does the Garbage Collector Watch Your Application?</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html">Garbage Collection In Go : Part I - Semantics</a></li>
<li><a target="_blank" rel="noopener" href="https://making.pusher.com/go-tool-trace/">https://making.pusher.com/go-tool-trace/</a></li>
<li><a target="_blank" rel="noopener" href="https://rakyll.medium.com/debugging-latency-in-go-1-11-9f97a7910d68">https://rakyll.medium.com/debugging-latency-in-go-1-11-9f97a7910d68</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/16/golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" data-id="cl0t1dd0z004h8slf5y9xelbb" data-title="golang垃圾回收" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gc/" rel="tag">gc</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-golang单元测试备忘录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/03/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%A4%87%E5%BF%98%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2021-06-03T08:16:08.000Z" itemprop="datePublished">2021-06-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/03/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%A4%87%E5%BF%98%E5%BD%95/">golang测试备忘录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://zhounanjun.gitbook.io/nanjun/ji-shu-tiao-yan/gomonkey">gomonkey调研文档和学习</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/343300926">如何高效编写Go单元测试（二）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/catch/p/10973611.html">gohook 一个支持运行时替换 golang 函数的库实现</a></li>
<li><a target="_blank" rel="noopener" href="https://elliotchance.medium.com/mocking-redis-in-unit-tests-in-go-28aff285b98">https://elliotchance.medium.com/mocking-redis-in-unit-tests-in-go-28aff285b98</a></li>
<li><a target="_blank" rel="noopener" href="https://codertang.com/2020/10/21/postman/">postman功能详解</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/03/golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%A4%87%E5%BF%98%E5%BD%95/" data-id="cl0t1dd0v00498slfde271wr9" data-title="golang测试备忘录" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Test/" rel="tag">Test</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-defer详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/02/defer%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2021-05-02T09:01:39.000Z" itemprop="datePublished">2021-05-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/02/defer%E8%AF%A6%E8%A7%A3/">defer详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>defer关键字的作用是预先准备，延迟执行。主要是要注意三个关键问题：</p>
<ol>
<li>defer是栈式存储，先声明的后执行。</li>
<li>defer会预先准备好参数和执行上下文。<code>defer foo(a,b)</code>和<code>defer func()&#123;foo(a,b)&#125;</code>是不一样的。</li>
<li>defer和return的执行顺序是，在return的ret汇编执行之前执行defer声明的函数。要注意return的底层操作包含三步，如果是匿名返回，就先声明和初始化一个匿名变量，然后将要返回出去的数据赋值给该变量，最后执行RET，才算是解释函数，将返回值又赋值给外部的接收者。可以参考[<a target="_blank" rel="noopener" href="https://my.oschina.net/henrylee2cn/blog/505535">Golang中defer、return、返回值之间执行顺序的坑</a>]，匿名返回值的那个匿名变量，我们是拿不到的，因此也就不存在会在return的过程中修改该匿名变量的可能。而有名返回值在函数调用时就已经被初始化了返回值，这个值defer是可以拿到的，也就可能在defer中改变了返回值（还要注意defer的取值是否是指针取值）。</li>
</ol>
<h2 id="2-例子"><a href="#2-例子" class="headerlink" title="2. 例子"></a>2. 例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintTimeCost</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  now:=time.Now()</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    duration:=time.Since(now)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;func costs:%v&quot;</span>,duration)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在想要记录耗时的函数里可以这么使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">defer</span> PrintTimeCost()()</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就涉及到函数的闭包以及defer的准备工作。</p>
<h2 id="3-defer原理剖析"><a href="#3-defer原理剖析" class="headerlink" title="3. defer原理剖析"></a>3. defer原理剖析</h2><p>首先写一个简单的测试用例来看一下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">recover</span>()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照golang语言深度解析里的方法，我们可以找到其汇编里的实现是先调用<code>runtime.deferprocStack</code>做一些数据准备，然后调用<code>runtime.deferreturn</code>调用执行。</p>
<p>先看一下_defer的结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A _defer holds an entry on the list of deferred calls.</span></span><br><span class="line"><span class="comment">// If you add a field here, add code to clear it in freedefer and deferProcStack</span></span><br><span class="line"><span class="comment">// This struct must match the code in cmd/compile/internal/gc/reflect.go:deferstruct</span></span><br><span class="line"><span class="comment">// and cmd/compile/internal/gc/ssa.go:(*state).call.</span></span><br><span class="line"><span class="comment">// Some defers will be allocated on the stack and some on the heap.</span></span><br><span class="line"><span class="comment">// All defers are logically part of the stack, so write barriers to</span></span><br><span class="line"><span class="comment">// initialize them are not required. All defers must be manually scanned,</span></span><br><span class="line"><span class="comment">// and for heap defers, marked.</span></span><br><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">	siz     <span class="type">int32</span> <span class="comment">// includes both arguments and results</span></span><br><span class="line">	started <span class="type">bool</span></span><br><span class="line">	heap    <span class="type">bool</span></span><br><span class="line">	<span class="comment">// openDefer indicates that this _defer is for a frame with open-coded</span></span><br><span class="line">	<span class="comment">// defers. We have only one defer record for the entire frame (which may</span></span><br><span class="line">	<span class="comment">// currently have 0, 1, or more defers active).</span></span><br><span class="line">	openDefer <span class="type">bool</span></span><br><span class="line">	sp        <span class="type">uintptr</span>  <span class="comment">// sp at time of defer</span></span><br><span class="line">	pc        <span class="type">uintptr</span>  <span class="comment">// pc at time of defer</span></span><br><span class="line">	fn        *funcval <span class="comment">// can be nil for open-coded defers</span></span><br><span class="line">	_panic    *_panic  <span class="comment">// panic that is running defer</span></span><br><span class="line">	link      *_defer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If openDefer is true, the fields below record values about the stack</span></span><br><span class="line">	<span class="comment">// frame and associated function that has the open-coded defer(s). sp</span></span><br><span class="line">	<span class="comment">// above will be the sp for the frame, and pc will be address of the</span></span><br><span class="line">	<span class="comment">// deferreturn call in the function.</span></span><br><span class="line">	fd   unsafe.Pointer <span class="comment">// funcdata for the function associated with the frame</span></span><br><span class="line">	varp <span class="type">uintptr</span>        <span class="comment">// value of varp for the stack frame</span></span><br><span class="line">	<span class="comment">// framepc is the current pc associated with the stack frame. Together,</span></span><br><span class="line">	<span class="comment">// with sp above (which is the sp associated with the stack frame),</span></span><br><span class="line">	<span class="comment">// framepc/sp can be used as pc/sp pair to continue a stack trace via</span></span><br><span class="line">	<span class="comment">// gentraceback().</span></span><br><span class="line">	framepc <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以deferprocStack实际上就是在当前运行的goroutine的_defer链表增加了一个_defer对象，因为是从链表头插入，因此可以解释为什么defer是先声明的后执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferprocStack</span><span class="params">(d *_defer)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	<span class="keyword">if</span> gp.m.curg != gp &#123;</span><br><span class="line">		<span class="comment">// go code on the system stack can&#x27;t defer</span></span><br><span class="line">		throw(<span class="string">&quot;defer on system stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	d.started = <span class="literal">false</span></span><br><span class="line">	d.heap = <span class="literal">false</span></span><br><span class="line">	d.openDefer = <span class="literal">false</span></span><br><span class="line">	d.sp = getcallersp()</span><br><span class="line">	d.pc = getcallerpc()</span><br><span class="line">	d.framepc = <span class="number">0</span></span><br><span class="line">	d.varp = <span class="number">0</span></span><br><span class="line">	<span class="comment">// The lines below implement:</span></span><br><span class="line">	<span class="comment">//   d.panic = nil</span></span><br><span class="line">	<span class="comment">//   d.fd = nil</span></span><br><span class="line">	<span class="comment">//   d.link = gp._defer</span></span><br><span class="line">	<span class="comment">//   gp._defer = d</span></span><br><span class="line">	<span class="comment">// But without write barriers. The first three are writes to</span></span><br><span class="line">	<span class="comment">// the stack so they don&#x27;t need a write barrier, and furthermore</span></span><br><span class="line">	<span class="comment">// are to uninitialized memory, so they must not use a write barrier.</span></span><br><span class="line">	<span class="comment">// The fourth write does not require a write barrier because we</span></span><br><span class="line">	<span class="comment">// explicitly mark all the defer structures, so we don&#x27;t need to</span></span><br><span class="line">	<span class="comment">// keep track of pointers to them with a write barrier.</span></span><br><span class="line">	*(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;d._panic)) = <span class="number">0</span></span><br><span class="line">	*(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;d.fd)) = <span class="number">0</span></span><br><span class="line">	*(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;d.link)) = <span class="type">uintptr</span>(unsafe.Pointer(gp._defer))</span><br><span class="line">	*(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;gp._defer)) = <span class="type">uintptr</span>(unsafe.Pointer(d))</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run a deferred function if there is one.</span></span><br><span class="line"><span class="comment">// The compiler inserts a call to this at the end of any</span></span><br><span class="line"><span class="comment">// function which calls defer.</span></span><br><span class="line"><span class="comment">// If there is a deferred function, this will call runtime·jmpdefer,</span></span><br><span class="line"><span class="comment">// which will jump to the deferred function such that it appears</span></span><br><span class="line"><span class="comment">// to have been called by the caller of deferreturn at the point</span></span><br><span class="line"><span class="comment">// just before deferreturn was called. The effect is that deferreturn</span></span><br><span class="line"><span class="comment">// is called again and again until there are no more deferred functions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Declared as nosplit, because the function should not be preempted once we start</span></span><br><span class="line"><span class="comment">// modifying the caller&#x27;s frame in order to reuse the frame to call the deferred</span></span><br><span class="line"><span class="comment">// function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The single argument isn&#x27;t actually used - it just has its address</span></span><br><span class="line"><span class="comment">// taken so it can be matched against pending defers.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferreturn</span><span class="params">(arg0 <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	d := gp._defer</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	sp := getcallersp()</span><br><span class="line">	<span class="keyword">if</span> d.sp != sp &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> d.openDefer &#123;</span><br><span class="line">		done := runOpenDeferFrame(gp, d)</span><br><span class="line">		<span class="keyword">if</span> !done &#123;</span><br><span class="line">			throw(<span class="string">&quot;unfinished open-coded defers in deferreturn&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		gp._defer = d.link</span><br><span class="line">		freedefer(d)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Moving arguments around.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Everything called after this point must be recursively</span></span><br><span class="line">	<span class="comment">// nosplit because the garbage collector won&#x27;t know the form</span></span><br><span class="line">	<span class="comment">// of the arguments until the jmpdefer can flip the PC over to</span></span><br><span class="line">	<span class="comment">// fn.</span></span><br><span class="line">	<span class="keyword">switch</span> d.siz &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// Do nothing.</span></span><br><span class="line">	<span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">		*(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;arg0)) = *(*<span class="type">uintptr</span>)(deferArgs(d))</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		memmove(unsafe.Pointer(&amp;arg0), deferArgs(d), <span class="type">uintptr</span>(d.siz))</span><br><span class="line">	&#125;</span><br><span class="line">	fn := d.fn</span><br><span class="line">	d.fn = <span class="literal">nil</span></span><br><span class="line">	gp._defer = d.link</span><br><span class="line">	freedefer(d)</span><br><span class="line">	<span class="comment">// If the defer function pointer is nil, force the seg fault to happen</span></span><br><span class="line">	<span class="comment">// here rather than in jmpdefer. gentraceback() throws an error if it is</span></span><br><span class="line">	<span class="comment">// called with a callback on an LR architecture and jmpdefer is on the</span></span><br><span class="line">	<span class="comment">// stack, because the stack trace can be incorrect in that case - see</span></span><br><span class="line">	<span class="comment">// issue #8153).</span></span><br><span class="line">	_ = fn.fn</span><br><span class="line">	jmpdefer(fn, <span class="type">uintptr</span>(unsafe.Pointer(&amp;arg0)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-背景说明"><a href="#4-背景说明" class="headerlink" title="4. 背景说明"></a>4. 背景说明</h2><ol>
<li>write barrier，可以参考golang垃圾回收的说明。</li>
<li>Go:nosplit <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016743220">Go 语言编译器的 “&#x2F;&#x2F;go:” 详解</a></li>
<li>Open coded-defer</li>
</ol>
<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903936508297223">深入理解Go-defer的原理剖析</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/02/defer%E8%AF%A6%E8%A7%A3/" data-id="cl0t1dd0v00468slf4b4890co" data-title="defer详解" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-pprof备忘录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/28/pprof%E5%A4%87%E5%BF%98%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2021-04-28T03:50:20.000Z" itemprop="datePublished">2021-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/28/pprof%E5%A4%87%E5%BF%98%E5%BD%95/">pprof备忘录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    pprof原理是go runtime对运行的程序进行一定频率的抽样，将数据保存为profile.proto格式，然后通过go tool pprof来读取。但是就我观察，线上能跑很久的程序用pprof是观察不到什么性能问题的，因为top命令下榜上有名的都是一些runtime级别的函数操作。这些操作在大部分业务逻辑里都会触及到，几乎无法定位到底是哪一部分逻辑有问题。</p>
<p>​    因此，pprof不是银色子弹，过多的研究pprof这个工具是没有多大性价比的。我在此文中不过是想记录下一些网上博客（复制黏贴）泛泛而谈的pprof“详解”里没有说清楚的东西（至少是我自己当时没看懂的东西）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://github.com/google/pprof/blob/master/doc/README.md">pprof</a>里解释了一些指标的意思，还有callgraph里各图形的含义。有两个地方要注意：</p>
<ol>
<li>对于每一个抽样点都会有两个衡量数据：</li>
</ol>
<blockquote>
<ul>
<li><em>flat</em>: the value of the location itself.</li>
<li><em>cum</em>: the value of the location plus all its descendants.</li>
</ul>
</blockquote>
<p>大白话来讲就是，flat的值只在抽样的时候正好处于该处代码逻辑的CPU时间或者内存等，cum的值为抽样时程序堆栈没有在处理该处代码，但是其逻辑是由该处代码触发的。也会汇总算到该处代码的cum值上去。所以flat&lt;&#x3D;cum。</p>
<ol start="2">
<li>既然是抽样，那么也要考虑到业务的代码覆盖率。比如有一个if A else B的业务逻辑，虽然pprof里看到A的耗时更多，但是并不代表B的耗时就一定比A少，有可能只是B被命中的少。</li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.golang.org/pprof">Profiling Go Programs</a>详细介绍了一个具体的调优过程。</p>
</li>
<li><p>很多时候我们都是在远程机器上把生成的pprof文件下载下来到本地机器上去查看分析，因此代码路径会变化。如果用list显示错误，很有可能是编译的位置和go tool pprof的位置不一致导致的，可以看看下面的问答，主要是把编译的位置写到–trim_path，把源码的位置写到–source_path。参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/59592086/go-tool-pprof-how-to-specify-source-when-using-go-modules">go tool pprof - how to specify source when using go modules?</a></p>
</li>
<li><p><code>curl -o trace.out http://host:port/debug/pprof/trace?seconds=15</code> 可以观察到15秒的一个运行情况。trace.out可以放到本地终端然后<code>go tool trace trace.out </code>会自动打开浏览器有结果的展示。（⚠️要用chrome浏览器，如果view trace还是空白的话，需要升级本地go版本看看）。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://about.sourcegraph.com/go/an-introduction-to-go-tool-trace-rhys-hiltner/">An introduction to go tool trace</a>参考一下怎么看trace信息。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://software.intel.com/content/www/us/en/develop/blogs/debugging-performance-issues-in-go-programs.html">Debugging performance issues in Go* programs</a></p>
</li>
<li><p>获取goroutine的 <code>curl http://ip:8430/debug/pprof/goroutine?debug=2 -o g.txt</code></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/28/pprof%E5%A4%87%E5%BF%98%E5%BD%95/" data-id="cl0t1ddcc005m8slfdb7u93js" data-title="pprof备忘录" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pprof/" rel="tag">Pprof</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hexo博客配置备忘录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/28/hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%A4%87%E5%BF%98%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2021-04-28T02:48:03.000Z" itemprop="datePublished">2021-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hexo/">Hexo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/28/hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%A4%87%E5%BF%98%E5%BD%95/">hexo博客配置备忘录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="hexo博客的迁移"><a href="#hexo博客的迁移" class="headerlink" title="hexo博客的迁移"></a>hexo博客的迁移</h2><p>hexo+github搭建博客的教程有很多，但是为了后续更换电脑能够快速切换环境，这里做一下笔记。</p>
<ol>
<li>首先github的master分支是hexo自动生成和上传的，这一部分不需要在本地有所保存。</li>
<li>在本地开辟一个分支叫做source，和远程的source连接起来。</li>
<li>更换电脑后，将source分支的clone到本地然后执行,前提是把git，npm和nodejs都安装好了。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h2 id="新增标签和分类页面"><a href="#新增标签和分类页面" class="headerlink" title="新增标签和分类页面"></a>新增标签和分类页面</h2><p><a target="_blank" rel="noopener" href="https://geneliunx.com/2019/09/12/new-tags-and-categories/">Hexo 使用指南 —— 添加分类及标签</a></p>
<h2 id="支持latex语法"><a href="#支持latex语法" class="headerlink" title="支持latex语法"></a>支持latex语法</h2><p><a target="_blank" rel="noopener" href="https://cps.ninja/2019/03/16/hexo-with-latex/">让 Hexo 搭建的博客支持 LaTeX</a> </p>
<p>但每次hexo g都会有一个错误输出，<code>Plugin load failed: %s hexo-math</code></p>
<h2 id="支持图片"><a href="#支持图片" class="headerlink" title="支持图片"></a>支持图片</h2><p><a target="_blank" rel="noopener" href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">Hexo博客搭建之在文章中插入图片</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/28/hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%A4%87%E5%BF%98%E5%BD%95/" data-id="cl0t1dd1700558slfbndl20p9" data-title="hexo博客配置备忘录" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP%E7%B3%BB%E5%88%97/">CSAPP系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mit6-824/">mit6.824</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/quant%E9%9D%A2%E8%AF%95%E7%BA%A2%E5%AE%9D%E4%B9%A6/">quant面试红宝书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">数据结构笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E5%AE%9D%E5%85%B8/">面试算法宝典</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APUE/" rel="tag">APUE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algroithm/" rel="tag">Algroithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/I-O/" rel="tag">I&#x2F;O</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pprof/" rel="tag">Pprof</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test/" rel="tag">Test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/" rel="tag">code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/distributed/" rel="tag">distributed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gc/" rel="tag">gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lock-free/" rel="tag">lock-free</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quant-interview/" rel="tag">quant interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raft/" rel="tag">raft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ucore/" rel="tag">ucore</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/APUE/" style="font-size: 10px;">APUE</a> <a href="/tags/Algroithm/" style="font-size: 18.57px;">Algroithm</a> <a href="/tags/CSAPP/" style="font-size: 20px;">CSAPP</a> <a href="/tags/Golang/" style="font-size: 15.71px;">Golang</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/I-O/" style="font-size: 10px;">I/O</a> <a href="/tags/Leetcode/" style="font-size: 18.57px;">Leetcode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a> <a href="/tags/OS/" style="font-size: 15.71px;">OS</a> <a href="/tags/Pprof/" style="font-size: 10px;">Pprof</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/code/" style="font-size: 10px;">code</a> <a href="/tags/distributed/" style="font-size: 11.43px;">distributed</a> <a href="/tags/gc/" style="font-size: 10px;">gc</a> <a href="/tags/golang/" style="font-size: 12.86px;">golang</a> <a href="/tags/k8s/" style="font-size: 10px;">k8s</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/lock-free/" style="font-size: 10px;">lock-free</a> <a href="/tags/quant-interview/" style="font-size: 14.29px;">quant interview</a> <a href="/tags/raft/" style="font-size: 12.86px;">raft</a> <a href="/tags/ucore/" style="font-size: 17.14px;">ucore</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 12.86px;">双指针</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18.57px;">算法</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 11.43px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/12/csapp-ch3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/05/%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/02/08/%E7%AC%94%E8%AE%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/26/Prometheus-Histograms-Observation%E7%9A%84%E6%97%A0%E9%94%81%E5%AE%9E%E7%8E%B0/">Prometheus Histograms Observation的无锁实现</a>
          </li>
        
          <li>
            <a href="/2021/08/09/k8s%E5%AE%9E%E6%93%8D%E7%AC%94%E8%AE%B0/">k8s实操笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Husy<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>